# VP-066: LTV Calculation Precision

**Category:** Collateral Ratios
**Verification tool:** Kani

## What Can Go Wrong
Loan-to-Value (LTV) ratio is calculated as loan_value / collateral_value, typically expressed in basis points. When both values are scaled by different decimal precisions or oracle price feeds, intermediate multiplication can overflow or division can truncate to zero. An LTV that is off by even 1 basis point can mean the difference between a healthy position and one that should be liquidated.

## Why It Matters
An attacker exploits LTV precision loss to borrow slightly more than the collateral allows. Over many positions, these small excesses accumulate into significant protocol risk. When prices move, the protocol discovers it is undercollateralized but cannot recover the excess borrowing. Precision errors also allow positions to avoid liquidation when they should be eligible.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. LTV calculation precision issues have been flagged as critical in multiple lending protocol audits. The Solend protocol audit identified edge cases where u64 arithmetic produced LTV values that differed from the expected u128 calculation by up to 3 basis points.

## Invariant

### Formal Property
```
For loan_value, collateral_value > 0:
  ltv_bps = loan_value * 10000 / collateral_value
  |ltv_computed - ltv_exact| <= 1 bps
  ltv_bps <= 10000 (100%) when position is healthy
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_ltv_precision() {
    let loan: u64 = kani::any();
    let collateral: u64 = kani::any();

    kani::assume!(loan > 0 && loan < 1_000_000_000_000);
    kani::assume!(collateral > 0 && collateral < 1_000_000_000_000);
    kani::assume!(loan <= collateral);

    let ltv_u128 = (loan as u128) * 10_000 / (collateral as u128);
    let ltv_u64 = ((loan as u64) / (collateral / 10_000).max(1)) as u128;

    // u128 path must not exceed 10000 bps for healthy position
    kani::assert!(ltv_u128 <= 10_000);
    // u128 path must be within 1 bps of the naive u64 path
    let diff = if ltv_u128 > ltv_u64 { ltv_u128 - ltv_u64 } else { ltv_u64 - ltv_u128 };
    kani::assert!(diff <= 1 || collateral < 10_000);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn ltv_precision_within_tolerance(
        loan in 1u64..1_000_000_000,
        collateral in 1u64..1_000_000_000,
    ) {
        prop_assume!(loan <= collateral && collateral >= 10_000);

        let ltv_bps = (loan as u128) * 10_000 / (collateral as u128);
        let exact = (loan as f64) * 10_000.0 / (collateral as f64);

        prop_assert!(ltv_bps <= 10_000);
        prop_assert!((ltv_bps as f64 - exact).abs() <= 1.0,
            "off by more than 1 bps: computed={} exact={}", ltv_bps, exact);
    }
}
```

### LiteSVM Assertion
```rust
let position = create_position(&mut ctx, borrower, collateral_amount, loan_amount).await;
let state = get_position_state(&ctx, position).await;

let expected_ltv = (loan_amount as u128) * 10_000 / (collateral_value as u128);
assert_eq!(state.ltv_bps as u128, expected_ltv, "on-chain LTV must match expected");
assert!(state.ltv_bps <= max_ltv_bps, "LTV must not exceed maximum at creation");
```

## Suggested Fix
```rust
pub fn calculate_ltv_bps(loan_value: u64, collateral_value: u64) -> Result<u64> {
    require!(collateral_value > 0, LendingError::ZeroCollateral);
    let ltv = (loan_value as u128)
        .checked_mul(10_000)
        .ok_or(LendingError::Overflow)?
        .checked_div(collateral_value as u128)
        .ok_or(LendingError::DivisionByZero)?;
    require!(ltv <= 10_000, LendingError::LtvExceedsMax);
    Ok(ltv as u64)
}
```
