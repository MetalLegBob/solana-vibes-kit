# AI-Generated Code Pitfalls: Web Application Security
<!-- Domain: web -->
<!-- Relevant auditors: WEB-01, WEB-02, WEB-03, WEB-04 -->

Common security mistakes AI code generators make when producing web application code. These patterns appear frequently in code generated by ChatGPT, Claude, Copilot, and similar LLMs. They look correct and often pass basic tests, but introduce serious security vulnerabilities.

---

## AIP-041: Generating dangerouslySetInnerHTML Without Sanitization

**Affects patterns:** OC-082, OC-084
**Severity:** HIGH

AI generators frequently use `dangerouslySetInnerHTML` when asked to render HTML content in React, without adding DOMPurify or any sanitization layer. The generated code works perfectly for the intended use case, but creates a direct stored XSS vector.

```typescript
// AI-generated: "Create a component to render rich text from API"
function RichContent({ html }: { html: string }) {
  // AI generates this because it works -- but it's an XSS vector
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// SECURE alternative:
import DOMPurify from 'dompurify';
function RichContent({ html }: { html: string }) {
  return <div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(html) }} />;
}
```

**Why AI does this:** LLMs optimize for "working code" and `dangerouslySetInnerHTML` is the simplest way to render HTML in React. The LLM knows about `DOMPurify` but doesn't include it unless explicitly prompted about security.

**Detection:** `grep -rn "dangerouslySetInnerHTML" --include="*.tsx" --include="*.jsx" | grep -v "DOMPurify\|sanitize\|purify"`

---

## AIP-042: CORS Configuration With `origin: true` or Wildcard

**Affects patterns:** OC-088, OC-089
**Severity:** HIGH

When AI is asked to "fix CORS errors" or "enable CORS for my API," it consistently generates the most permissive configuration possible. The `cors({ origin: true, credentials: true })` pattern appears in nearly every AI-generated Express setup, effectively disabling the Same-Origin Policy.

```typescript
// AI-generated: "Add CORS to my Express API"
import cors from 'cors';
app.use(cors({
  origin: true,        // Reflects any origin -- essentially a wildcard
  credentials: true,   // Allows cookies -- makes it exploitable
}));

// SECURE alternative:
app.use(cors({
  origin: ['https://app.example.com'],
  credentials: true,
}));
```

**Why AI does this:** LLMs learn from Stack Overflow answers where the goal is "make the error go away." The permissive config universally solves CORS errors, so it appears in training data as the "correct" answer.

**Detection:** `grep -rn "origin:\s*true\|origin:\s*\*" --include="*.ts" --include="*.js"`

---

## AIP-043: Missing Security Headers in Express/Fastify Setup

**Affects patterns:** OC-090, OC-092, OC-093, OC-094
**Severity:** MEDIUM

AI-generated server setups almost never include security headers (CSP, X-Frame-Options, HSTS, X-Content-Type-Options). When asked to "set up an Express server," the generated code includes body parsing, routing, and error handling but omits `helmet` or any manual header configuration. The resulting server responds with zero security headers.

```typescript
// AI-generated: "Set up an Express server with API routes"
import express from 'express';
const app = express();
app.use(express.json());
// Routes follow...
// NO security headers whatsoever

// SECURE alternative:
import express from 'express';
import helmet from 'helmet';
const app = express();
app.use(helmet()); // Sets CSP, X-Frame-Options, HSTS, noSniff, and more
app.use(express.json());
```

**Why AI does this:** Security headers are not required for functionality. LLMs generate the minimal setup that satisfies the user's request. Since missing headers don't cause errors or test failures, they are consistently omitted.

**Detection:** `grep -rn "express()" --include="*.ts" --include="*.js" -l | xargs grep -L "helmet\|Content-Security-Policy\|X-Frame-Options"`

---

## AIP-044: CSRF Protection Not Included in Form-Based Applications

**Affects patterns:** OC-095, OC-096
**Severity:** HIGH

AI generators produce form-handling code that processes POST requests without CSRF protection. When asked to "create a form that updates user settings" or "add an endpoint to change email," the generated code includes the route handler and form HTML but never includes CSRF tokens or middleware like `csrf-csrf` or `csurf`.

```typescript
// AI-generated: "Create endpoint to change user email"
app.post('/settings/email', (req, res) => {
  db.users.update(req.session.userId, { email: req.body.email });
  res.redirect('/settings');
});
// No CSRF middleware, no token validation

// SECURE alternative: Apply csrf-csrf middleware and validate token
const { doubleCsrfProtection } = doubleCsrf({ /* config */ });
app.use(doubleCsrfProtection);
```

**Why AI does this:** CSRF protection requires middleware configuration, token generation, and client-side integration. It adds complexity that the LLM avoids when generating a "simple" form handler.

**Detection:** `grep -rn "app\.post\|router\.post" --include="*.ts" --include="*.js" -l | xargs grep -L "csrf"`

---

## AIP-045: Using innerHTML Instead of textContent for Dynamic Content

**Affects patterns:** OC-083, OC-084
**Severity:** MEDIUM

When generating vanilla JavaScript or TypeScript for DOM manipulation, AI consistently uses `innerHTML` to insert dynamic content even when the content is plain text. This creates DOM XSS vulnerabilities where `textContent` (which auto-escapes) would be both safer and more appropriate.

```typescript
// AI-generated: "Display search results count on page"
const results = document.getElementById('results');
results.innerHTML = `Found ${count} results for "${query}"`;
// If query comes from URL params, this is DOM XSS

// SECURE alternative:
results.textContent = `Found ${count} results for "${query}"`;
```

**Why AI does this:** `innerHTML` is more versatile than `textContent` and allows HTML formatting. LLMs default to it because it appears more frequently in training data and handles both text and HTML use cases.

**Detection:** `grep -rn "\.innerHTML\s*=" --include="*.ts" --include="*.js" | grep -v "sanitize\|purify\|DOMPurify"`

---

## AIP-046: Open Redirect in Login/OAuth Return URLs

**Affects patterns:** OC-099, OC-100
**Severity:** MEDIUM

AI-generated authentication flows commonly accept a `returnTo` or `redirect` query parameter and use it directly in a `res.redirect()` call after login, without validating that the URL is a relative path or on an allowed domain. This creates an open redirect that is especially dangerous in OAuth flows.

```typescript
// AI-generated: "Add login with redirect back to original page"
app.post('/login', (req, res) => {
  authenticate(req.body);
  const returnUrl = req.query.returnTo || '/dashboard';
  res.redirect(returnUrl); // Open redirect to any URL
});

// SECURE alternative:
function isSafeRedirect(url) {
  return url.startsWith('/') && !url.startsWith('//');
}
const safeUrl = isSafeRedirect(returnUrl) ? returnUrl : '/dashboard';
res.redirect(safeUrl);
```

**Why AI does this:** The redirect pattern itself is valid and common. LLMs implement the happy path (redirect user back after login) without considering the security implications of unvalidated external URLs.

**Detection:** `grep -rn "res\.redirect.*req\.query\|res\.redirect.*req\.body\|res\.redirect.*req\.params" --include="*.ts" --include="*.js"`

---

## AIP-047: postMessage Without Origin Validation

**Affects patterns:** OC-087
**Severity:** HIGH

When AI generates cross-origin communication code using `postMessage`, it consistently omits origin validation in the message event listener and uses wildcard `"*"` as the target origin when sending messages. Both patterns create significant security vulnerabilities.

```typescript
// AI-generated: "Add postMessage communication between parent and iframe"
window.addEventListener('message', (event) => {
  // No origin check -- trusts messages from any source
  handleMessage(event.data);
});

iframe.contentWindow.postMessage(sensitiveData, '*'); // Broadcasts to anyone

// SECURE alternative:
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://trusted.example.com') return;
  handleMessage(event.data);
});
iframe.contentWindow.postMessage(data, 'https://trusted.example.com');
```

**Why AI does this:** Origin validation and specific target origins are "extra" code that the LLM omits for simplicity. The wildcard and missing validation produce working code with fewer lines.

**Detection:** `grep -rn "addEventListener.*message" --include="*.ts" --include="*.js" -A5 | grep -v "origin"`

---

## AIP-048: SVG Files Accepted in Upload Validators

**Affects patterns:** OC-086
**Severity:** MEDIUM

AI-generated file upload validation often includes SVG in the list of allowed image types, treating it the same as raster formats. SVG files can contain embedded JavaScript that executes when the file is served with its MIME type, creating a stored XSS vector.

```typescript
// AI-generated: "Create image upload endpoint"
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'];
// SVG is an image format, but it can contain executable JavaScript

// SECURE alternative:
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
// Re-encode uploaded images through sharp to strip embedded content
```

**Why AI does this:** SVG is technically an image format and appears in many training data examples of "allowed image types." The LLM does not distinguish between safe raster formats and potentially dangerous vector formats.

**Detection:** `grep -rn "svg\|image/svg" --include="*.ts" --include="*.js" | grep -i "allow\|accept\|valid\|type"`

---

## AIP-049: CSP with unsafe-inline Generated by Default

**Affects patterns:** OC-091
**Severity:** MEDIUM

When AI is asked to add a Content-Security-Policy, it frequently includes `'unsafe-inline'` and `'unsafe-eval'` in the `script-src` directive to avoid breaking inline scripts and event handlers. This effectively negates the XSS protection that CSP provides, creating a false sense of security.

```typescript
// AI-generated: "Add CSP headers to my Express app"
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
    styleSrc: ["'self'", "'unsafe-inline'"],
  },
}));
// unsafe-inline and unsafe-eval completely negate script-src protection

// SECURE alternative: Use nonce-based CSP
const nonce = crypto.randomBytes(16).toString('base64');
scriptSrc: ["'self'", `'nonce-${nonce}'`];
```

**Why AI does this:** Without `unsafe-inline`, many applications break because they use inline scripts. The LLM adds these directives to prevent errors, prioritizing functionality over security.

**Detection:** `grep -rn "unsafe-inline\|unsafe-eval" --include="*.ts" --include="*.js"`

---

## AIP-050: Missing SameSite Attribute on Cookie Configuration

**Affects patterns:** OC-098, OC-104
**Severity:** MEDIUM

AI-generated cookie configuration often omits the `SameSite` attribute entirely, or sets it to `'none'` when working with cross-origin scenarios. While Chrome defaults to `Lax` when `SameSite` is not specified, explicitly omitting it leads to inconsistent behavior across browsers and demonstrates a lack of intentional security configuration.

```typescript
// AI-generated: "Set up session middleware"
app.use(session({
  secret: 'keyboard cat',
  cookie: {
    httpOnly: true,
    secure: true,
    // SameSite not specified -- relies on browser defaults
  },
}));

// SECURE alternative:
app.use(session({
  secret: process.env.SESSION_SECRET,
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
  },
}));
```

**Why AI does this:** `SameSite` was not always a standard attribute, so much of the training data omits it. LLMs also sometimes generate `sameSite: 'none'` to "fix" cross-site cookie issues, which completely removes CSRF protection.

**Detection:** `grep -rn "cookie:\s*{" --include="*.ts" --include="*.js" -A 10 | grep -v "sameSite\|samesite"`
