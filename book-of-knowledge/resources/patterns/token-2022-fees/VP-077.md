# VP-077: Epoch-Based Fee Update Boundary

**Category:** Token-2022 Fees
**Verification tool:** LiteSVM

## What Can Go Wrong
Token-2022 allows fee schedule updates that take effect at a future epoch. A transfer at exactly the epoch boundary must apply the correct rate. If the comparison uses `>` instead of `>=`, the old fee persists one epoch too long. If it uses `>=` where `>` was intended, the new fee activates one epoch too early. Either off-by-one creates a window where the wrong rate applies.

## Why It Matters
An attacker monitors pending fee increases and front-runs the epoch boundary to execute large transfers at the old, lower rate. If the check is `epoch > change_epoch` instead of `>=`, the attacker gets one extra epoch at the old rate. On high-volume tokens, this single-epoch window can represent millions in avoided fees.

## Real-World Incident
No single named exploit, but epoch boundary timing issues have been identified in Solana program audits. The SPL Token-2022 source uses `>=` for the newer-config-epoch check. Off-by-one boundary bugs are a pervasive class of timing vulnerabilities across all smart contract platforms.

## Invariant

### Formal Property
```
For current_epoch E, change_epoch C, old_fee, new_fee:
  E >= C  implies  active_fee == new_fee
  E < C   implies  active_fee == old_fee
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_epoch_fee_boundary() {
    let current_epoch: u64 = kani::any();
    let change_epoch: u64 = kani::any();
    let old_bps: u16 = kani::any();
    let new_bps: u16 = kani::any();
    kani::assume!(change_epoch > 0 && change_epoch < u64::MAX);
    kani::assume!(old_bps <= 10_000 && new_bps <= 10_000);

    let active = if current_epoch >= change_epoch { new_bps } else { old_bps };

    if current_epoch == change_epoch { kani::assert!(active == new_bps); }
    if current_epoch == change_epoch - 1 { kani::assert!(active == old_bps); }
    if current_epoch > change_epoch { kani::assert!(active == new_bps); }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn epoch_boundary_correct_fee(
        change_epoch in 1u64..1_000_000,
        old_bps in 0u16..=500,
        new_bps in 0u16..=500
    ) {
        let get_fee = |e: u64| if e >= change_epoch { new_bps } else { old_bps };

        prop_assert_eq!(get_fee(change_epoch - 1), old_bps, "wrong fee before boundary");
        prop_assert_eq!(get_fee(change_epoch), new_bps, "wrong fee at boundary");
        prop_assert_eq!(get_fee(change_epoch + 1), new_bps, "wrong fee after boundary");
    }
}
```

### LiteSVM Assertion
```rust
// Schedule fee change: old=50bps, new=100bps, effective at epoch 10
process_transaction(&mut banks_client, set_fee_schedule_ix(50, 100, 10), &payer).await.unwrap();

// Epoch 9: old fee (50 bps on 1M = 5000)
warp_to_epoch(&mut ctx, 9);
process_transaction(&mut banks_client, transfer_ix(1_000_000), &payer).await.unwrap();
let fee_9 = get_last_transfer_fee(&banks_client, dest_account).await;
assert_eq!(fee_9, 5_000, "epoch 9 should use old fee of 50 bps");

// Epoch 10 (boundary): new fee (100 bps on 1M = 10000)
warp_to_epoch(&mut ctx, 10);
process_transaction(&mut banks_client, transfer_ix(1_000_000), &payer).await.unwrap();
let fee_10 = get_last_transfer_fee(&banks_client, dest_account).await;
assert_eq!(fee_10, 10_000, "epoch 10 should use new fee of 100 bps");

// Epoch 11: still new fee
warp_to_epoch(&mut ctx, 11);
process_transaction(&mut banks_client, transfer_ix(1_000_000), &payer).await.unwrap();
let fee_11 = get_last_transfer_fee(&banks_client, dest_account).await;
assert_eq!(fee_11, 10_000, "epoch 11 should use new fee of 100 bps");
```

## Suggested Fix
```rust
pub fn get_active_fee_bps(current_epoch: u64, change_epoch: u64, old_bps: u16, new_bps: u16) -> u16 {
    if current_epoch >= change_epoch { new_bps } else { old_bps }
}
```
