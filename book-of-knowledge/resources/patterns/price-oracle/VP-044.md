# VP-044: Price Feed Manipulation Resistance

**Category:** Price Oracle
**Verification tool:** LiteSVM

## What Can Go Wrong
On-chain price oracles derived from AMM pool reserves can be manipulated within a single transaction. An attacker makes a large swap to move the price, uses the manipulated price for a protocol action (borrow, liquidate), then swaps back. The oracle must resist single-block manipulation.

## Why It Matters
Price oracle manipulation is the most common DeFi attack vector. Without TWAP or multi-block averaging, any lending or perpetual protocol using spot AMM prices is immediately exploitable with flash loans.

## Real-World Incident
Mango Markets (Oct 2022, $116M), Cream Finance (Oct 2021, $130M), and dozens of other protocols fell to oracle manipulation. The pattern is nearly always the same: manipulate spot price, exploit protocol, restore price.

## Invariant

### Formal Property
```
|price_used - true_market_price| / true_market_price <= max_deviation
For TWAP-based oracle: single-block manipulation impact <= 1/N (N = observation window)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_twap_limits_manipulation() {
    let observations: u8 = kani::any();
    let normal_price: u64 = kani::any();
    let manipulated_price: u64 = kani::any();

    kani::assume!(observations >= 10 && observations <= 100);
    kani::assume!(normal_price > 0 && normal_price < u64::MAX / 2);
    kani::assume!(manipulated_price > 0);

    // One manipulated observation out of N
    let twap = ((normal_price as u128) * ((observations - 1) as u128)
        + (manipulated_price as u128))
        / (observations as u128);

    let impact_pct = if twap > normal_price as u128 {
        (twap - normal_price as u128) * 10_000 / (normal_price as u128)
    } else {
        (normal_price as u128 - twap) * 10_000 / (normal_price as u128)
    };

    // Impact bounded by 1/N of the manipulation
    kani::assert!(impact_pct <= 10_000); // max 100% in extreme case
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn single_block_manipulation_bounded(
        normal_price in 1_000_000u64..1_000_000_000,
        manipulation_factor in 2u64..10, // 2x-10x manipulation
        window_size in 10u32..100
    ) {
        let manip_price = normal_price.saturating_mul(manipulation_factor);
        let twap = (normal_price as u128 * (window_size - 1) as u128 + manip_price as u128)
            / window_size as u128;
        let impact = (twap as f64 / normal_price as f64 - 1.0).abs();
        let max_impact = manipulation_factor as f64 / window_size as f64;
        prop_assert!(impact <= max_impact + 0.01);
    }
}
```

### LiteSVM Assertion
```rust
// Record TWAP over 20 observations
for _ in 0..20 {
    advance_slot(&mut ctx).await;
    update_oracle(&mut ctx).await.unwrap();
}
let twap_before = get_twap(&ctx).await;
// Simulate manipulation: large swap moves spot price 50%
execute_large_swap(&mut ctx, massive_amount).await.unwrap();
update_oracle(&mut ctx).await.unwrap();
let twap_after = get_twap(&ctx).await;
let impact = (twap_after as f64 / twap_before as f64 - 1.0).abs();
assert!(impact < 0.05, "TWAP moved {}% from single-block manipulation", impact * 100.0);
```

## Suggested Fix
```rust
/// Use TWAP with minimum observation window
pub fn get_twap_price(oracle: &OracleState, min_observations: u32) -> Result<u64> {
    require!(oracle.num_observations >= min_observations, OracleError::InsufficientHistory);
    let twap = oracle.cumulative_price / oracle.cumulative_duration;
    Ok(twap as u64)
}
```
