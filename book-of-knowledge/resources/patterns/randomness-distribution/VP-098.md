# VP-098: Seed Derivation Determinism

**Category:** Randomness/Distribution
**Verification tool:** Kani

## What Can Go Wrong
If the same seed doesn't always produce the same random output, the VRF/PRNG is broken. Non-determinism can creep in through: floating-point operations, uninitialized memory, timestamp inclusion without documentation, or hash function implementation differences.

## Why It Matters
Determinism is the core property of VRFs — anyone can verify the output matches the seed. If the function is non-deterministic, verification fails and the randomness can't be audited. For on-chain programs, non-determinism across validators would cause consensus failures.

## Real-World Incident
Solana programs must be deterministic — non-determinism causes validator disagreement and consensus failure. Several early programs accidentally introduced non-determinism through floating-point usage.

## Invariant

### Formal Property
```
∀ seed: derive(seed) == derive(seed)  (always)
∀ seed1 ≠ seed2: P(derive(seed1) == derive(seed2)) ≈ 1/2^256 (collision resistance)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_seed_determinism() {
    let seed: [u8; 32] = kani::any();

    let output1 = derive_random(&seed);
    let output2 = derive_random(&seed);

    kani::assert!(output1 == output2, "non-deterministic derivation");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn deterministic_derivation(seed in prop::array::uniform32(0u8..)) {
        let a = derive_random(&seed);
        let b = derive_random(&seed);
        prop_assert_eq!(a, b, "non-deterministic for same seed");
    }

    #[test]
    fn different_seeds_different_outputs(
        seed1 in prop::array::uniform32(0u8..),
        seed2 in prop::array::uniform32(0u8..)
    ) {
        prop_assume!(seed1 != seed2);
        let out1 = derive_random(&seed1);
        let out2 = derive_random(&seed2);
        prop_assert_ne!(out1, out2, "collision on different seeds");
    }
}
```

### LiteSVM Assertion
```rust
let seed = [42u8; 32];
let result1 = derive_random_on_chain(&mut ctx, seed).await;
let result2 = derive_random_on_chain(&mut ctx, seed).await;
assert_eq!(result1, result2, "on-chain derivation not deterministic");
```

## Suggested Fix
```rust
pub fn derive_random(seed: &[u8; 32]) -> [u8; 32] {
    // SHA-256 is deterministic and collision-resistant
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(seed);
    hasher.finalize().into()
}
```
