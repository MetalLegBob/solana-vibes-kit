# VP-022: Late Staker Advantage Prevention

**Category:** Staking Rewards
**Verification tool:** LiteSVM

## What Can Go Wrong
If the reward calculation doesn't properly snapshot the accumulator at deposit time, late stakers can claim rewards for periods before they deposited. This is a variant of the dilution bug but specifically about temporal boundaries â€” the staker arrives late but earns as if they were present from the start.

## Why It Matters
An attacker monitoring the reward pool can wait for a large reward deposit, stake immediately after, and claim a share of rewards they didn't contribute to earning. This extracts value from loyal stakers.

## Real-World Incident
The "just-in-time liquidity" and "just-in-time staking" patterns have been widely exploited. Multiple Solana farm programs (Raydium Farms, Orca Aquafarms) addressed this through per-user reward debt snapshots.

## Invariant

### Formal Property
```
User who stakes at time T earns 0 rewards for any period [0, T]
user.pending_reward(T) = 0 immediately after staking
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_late_staker_advantage() {
    let global_rpt: u128 = kani::any();
    let stake_amount: u64 = kani::any();

    kani::assume!(global_rpt > 0 && global_rpt < u128::MAX / 2);
    kani::assume!(stake_amount > 0 && stake_amount < u64::MAX / 2);

    // On deposit, set user's reward_debt = global_rpt * amount / PRECISION
    let reward_debt = global_rpt * (stake_amount as u128) / PRECISION;
    // Immediately after deposit, pending = global_rpt * amount / PRECISION - debt
    let pending = global_rpt * (stake_amount as u128) / PRECISION - reward_debt;

    kani::assert!(pending == 0);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn late_staker_earns_nothing_retroactively(
        early_stake in 1_000u64..1_000_000,
        late_stake in 1_000u64..1_000_000,
        reward_periods in 1u32..100
    ) {
        let mut pool = create_pool();
        stake(&mut pool, "alice", early_stake, 0);
        // Advance time, accrue rewards
        for t in 1..=reward_periods {
            pool.update(t as u64);
        }
        // Bob stakes late
        stake(&mut pool, "bob", late_stake, reward_periods as u64);
        // Bob's pending is 0
        let bob_pending = pool.pending("bob");
        prop_assert_eq!(bob_pending, 0, "late staker has {} pending", bob_pending);
    }
}
```

### LiteSVM Assertion
```rust
// Alice stakes at T=0
stake(&mut ctx, &alice, 1_000_000).await.unwrap();
// Advance 100 seconds with rewards
advance_clock(&mut ctx, 100).await;
update_pool(&mut ctx).await.unwrap();

// Bob stakes at T=100
stake(&mut ctx, &bob, 1_000_000).await.unwrap();
let bob_pending = get_pending(&ctx, &bob).await;
assert_eq!(bob_pending, 0, "Bob earned {} retroactive rewards", bob_pending);
```

## Suggested Fix
```rust
pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
    update_pool_rewards(&mut ctx.accounts.pool)?;
    let user = &mut ctx.accounts.user_stake;
    // Critical: snapshot reward_per_token at deposit time
    let pending = harvest_pending(user, &ctx.accounts.pool)?;
    user.staked_amount = user.staked_amount.checked_add(amount)?;
    user.reward_debt = ctx.accounts.pool.reward_per_token_stored
        * (user.staked_amount as u128) / PRECISION;
    // Transfer pending rewards + deposit tokens...
    Ok(())
}
```
