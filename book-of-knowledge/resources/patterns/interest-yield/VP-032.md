# VP-032: Rate Update Mid-Accrual Period

**Category:** Interest/Yield
**Verification tool:** LiteSVM

## What Can Go Wrong
When the interest rate changes mid-period, accrued interest must be correctly split: time_before_change * old_rate + time_after_change * new_rate. If the protocol doesn't accrue pending interest at the old rate before updating, the new rate applies retroactively to the entire period.

## Why It Matters
Retroactive rate application means users can be overcharged (if rate increased) or undercharged (if rate decreased) for time that already passed. Governance can exploit this to extract value from borrowers.

## Real-World Incident
Compound Finance on Ethereum addressed this with their accrueInterest() function that must be called before any rate change. Several Solana lending forks missed this pattern.

## Invariant

### Formal Property
```
On rate change at time T:
  1. Accrue interest at old_rate for [last_update, T]
  2. Set new_rate
  3. Future accrual uses new_rate from T onwards
  total_interest = old_rate * (T - last_update) + new_rate * (current - T)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rate_update_splits_correctly() {
    let old_rate: u64 = kani::any();
    let new_rate: u64 = kani::any();
    let time_before: u64 = kani::any();
    let time_after: u64 = kani::any();

    kani::assume!(old_rate < 10_000 && new_rate < 10_000);
    kani::assume!(time_before > 0 && time_before < 86400);
    kani::assume!(time_after > 0 && time_after < 86400);

    let correct = (old_rate as u128) * (time_before as u128) + (new_rate as u128) * (time_after as u128);
    let wrong_retroactive = (new_rate as u128) * ((time_before + time_after) as u128);

    // If rates differ, retroactive application gives wrong result
    if old_rate != new_rate {
        kani::assert!(correct != wrong_retroactive);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn rate_change_splits_accrual(
        old_rate in 1u64..5000,
        new_rate in 1u64..5000,
        t_before in 1u64..43200,
        t_after in 1u64..43200
    ) {
        let correct = old_rate as u128 * t_before as u128 + new_rate as u128 * t_after as u128;
        let retroactive = new_rate as u128 * (t_before + t_after) as u128;
        if old_rate != new_rate {
            prop_assert_ne!(correct, retroactive, "split should differ from retroactive");
        }
    }
}
```

### LiteSVM Assertion
```rust
// Accrue at 5% for 100 slots, then change to 10%
set_rate(&mut ctx, 500).await.unwrap();
advance_slots(&mut ctx, 100).await;
// This must accrue at old rate BEFORE updating
set_rate(&mut ctx, 1000).await.unwrap();
advance_slots(&mut ctx, 100).await;
accrue(&mut ctx).await.unwrap();

let interest = get_accrued_interest(&ctx).await;
// Should NOT be 10% applied to all 200 slots
let wrong = principal as u128 * 1000 * 200 / SLOTS_PER_YEAR as u128 / 10_000;
assert!(interest as u128 != wrong, "rate applied retroactively");
```

## Suggested Fix
```rust
pub fn update_rate(market: &mut Market, new_rate: u16, clock: &Clock) -> Result<()> {
    // MUST accrue at old rate first
    accrue_interest(market, clock)?;
    // Then update
    market.interest_rate_bps = new_rate;
    Ok(())
}
```
