# VP-099: Mask Error in Bit Field Extraction

**Category:** Bit Packing
**Verification tool:** Kani

## What Can Go Wrong
Extracting a bit field from a packed integer requires the correct mask and shift. A wrong mask (e.g., 0xFF instead of 0xF for a 4-bit field) includes extra bits from adjacent fields. A wrong shift extracts bits from the wrong position. Both produce garbage values silently.

## Why It Matters
Packed account data is common on Solana to minimize account size (rent savings). If extraction masks are wrong, the protocol reads one field's data as another's â€” e.g., reading a 4-bit status flag as part of an 8-bit amount, producing nonsensical values that pass numeric checks.

## Real-World Incident
No specific public incident documented, but bit-packing bugs have been found in Solana program audits. SPL Token-2022 uses packed data structures with careful masking.

## Invariant

### Formal Property
```
For field at bit position P with width W:
  mask = ((1 << W) - 1) << P
  extract(packed, P, W) = (packed & mask) >> P
  extract(packed, P, W) < (1 << W)  (fits in W bits)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_mask_extracts_correctly() {
    let packed: u64 = kani::any();
    let position: u8 = kani::any();
    let width: u8 = kani::any();

    kani::assume!(width > 0 && width <= 64);
    kani::assume!(position + width <= 64);

    let mask = if width == 64 { u64::MAX } else { ((1u64 << width) - 1) << position };
    let extracted = (packed & mask) >> position;

    // Extracted value must fit in `width` bits
    if width < 64 {
        kani::assert!(extracted < (1u64 << width), "extracted value exceeds field width");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn extract_within_bounds(
        packed in 0u64..u64::MAX,
        position in 0u8..60,
        width in 1u8..8
    ) {
        prop_assume!(position + width <= 64);
        let value = extract_field(packed, position, width);
        prop_assert!(value < (1u64 << width), "extracted {} >= 2^{}", value, width);
    }
}
```

### LiteSVM Assertion
```rust
// Pack two 4-bit values, extract and verify
let packed = pack_fields(0xA, 4, 0, 0xB, 4, 4);
assert_eq!(extract_field(packed, 0, 4), 0xA);
assert_eq!(extract_field(packed, 4, 4), 0xB);
```

## Suggested Fix
```rust
pub fn extract_field(packed: u64, position: u8, width: u8) -> u64 {
    debug_assert!(position + width <= 64);
    let mask = if width == 64 { u64::MAX } else { (1u64 << width) - 1 };
    (packed >> position) & mask
}

pub fn insert_field(packed: u64, value: u64, position: u8, width: u8) -> u64 {
    debug_assert!(position + width <= 64);
    let mask = if width == 64 { u64::MAX } else { (1u64 << width) - 1 };
    debug_assert!(value <= mask, "value too large for field");
    (packed & !(mask << position)) | ((value & mask) << position)
}
```
