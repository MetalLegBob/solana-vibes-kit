# VP-094: Unrealized vs Realized Gain Tracking

**Category:** Leverage/Perpetuals
**Verification tool:** LiteSVM

## What Can Go Wrong
When closing a position, unrealized PnL becomes realized. If the accounting doesn't properly transition from unrealized to realized — e.g., the unrealized amount isn't zeroed out, or the realized amount double-counts — the user's balance is wrong. Partial closes are especially tricky.

## Why It Matters
Double-counting PnL means users can withdraw more than they earned. Not accounting for it means users lose money on winning trades. Either breaks trust in the platform.

## Real-World Incident
No specific public incident documented, but PnL accounting bugs between unrealized and realized states are common in perpetual protocol audits. Drift Protocol has explicit unrealized/realized separation.

## Invariant

### Formal Property
```
On position close:
  realized_pnl += position.unrealized_pnl
  position.unrealized_pnl = 0
  user.balance += realized_pnl (may be negative)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_pnl_transition() {
    let unrealized: i64 = kani::any();
    let balance_before: u64 = kani::any();

    kani::assume!(balance_before > 0);

    // Closing position
    let balance_after = if unrealized >= 0 {
        balance_before.checked_add(unrealized as u64)
    } else {
        balance_before.checked_sub(unrealized.unsigned_abs())
    };

    // Balance change must equal unrealized PnL
    if let Some(after) = balance_after {
        let change = after as i128 - balance_before as i128;
        kani::assert!(change == unrealized as i128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn close_transfers_unrealized_to_realized(
        entry in 1_000_000u64..1_000_000_000,
        current in 1_000_000u64..1_000_000_000,
        size in 1u64..1_000_000
    ) {
        let unrealized = (current as i128 - entry as i128) * size as i128;
        let mut realized = 0i128;
        // Close position
        realized += unrealized;
        let new_unrealized = 0i128;
        prop_assert_eq!(new_unrealized, 0);
        prop_assert_eq!(realized, unrealized);
    }
}
```

### LiteSVM Assertion
```rust
let balance_before = get_balance(&ctx, &user).await;
let unrealized = get_unrealized_pnl(&ctx, &user).await;
close_position(&mut ctx, &user).await.unwrap();
let balance_after = get_balance(&ctx, &user).await;
let change = balance_after as i128 - balance_before as i128;
assert_eq!(change, unrealized, "balance change doesn't match unrealized PnL");
```

## Suggested Fix
```rust
pub fn close_position(position: &mut Position, user: &mut User) -> Result<()> {
    let pnl = compute_pnl(position)?;
    if pnl >= 0 {
        user.balance = user.balance.checked_add(pnl as u64)?;
    } else {
        user.balance = user.balance.checked_sub(pnl.unsigned_abs() as u64)?;
    }
    position.size = 0;
    position.unrealized_pnl = 0;
    Ok(())
}
```
