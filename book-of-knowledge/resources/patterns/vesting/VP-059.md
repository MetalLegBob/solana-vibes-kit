# VP-059: Total Claimed Never Exceeds Allocation

**Category:** Vesting
**Verification tool:** Kani

## What Can Go Wrong
If the sum of all claims against a vesting schedule exceeds the total grant, the protocol transfers tokens it does not have. This occurs when multiple claim transactions race against each other, each reading the same `claimed_so_far` value and each succeeding independently. Accumulated rounding errors over many partial claims can also slowly drain more than was allocated, one dust amount at a time.

## Why It Matters
An attacker submits multiple concurrent claim transactions within the same slot. Each reads the same `claimed_so_far` value from account state and each computes a positive claimable amount. Without atomic read-modify-write protection, all transactions succeed and the total claimed exceeds the grant amount, draining the vesting vault of tokens belonging to other beneficiaries.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Race condition vulnerabilities in vesting claim functions have been found in multiple audits. The pattern mirrors classic double-spend attacks adapted to Solana's parallel execution model.

## Invariant

### Formal Property
```
forall vesting_schedule:
  sum(all_claims) <= total_grant
  claimed_so_far + new_claim <= total_grant
  new_claim = min(vested_amount - claimed_so_far, vault_balance)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_claim_never_exceeds_grant() {
    let total_grant: u64 = kani::any();
    let claimed_so_far: u64 = kani::any();
    let vested_amount: u64 = kani::any();

    kani::assume!(total_grant > 0 && total_grant <= 10_000_000_000);
    kani::assume!(claimed_so_far <= total_grant);
    kani::assume!(vested_amount <= total_grant);

    // Compute claimable: what has vested minus what was already claimed
    let claimable = vested_amount.saturating_sub(claimed_so_far);
    let new_claimed = claimed_so_far.checked_add(claimable);

    kani::assert!(new_claimed.is_some(), "overflow in claimed total");
    kani::assert!(
        new_claimed.unwrap() <= total_grant,
        "total claimed exceeds grant"
    );
    kani::assert!(
        new_claimed.unwrap() == vested_amount,
        "claimed should equal vested after claim"
    );
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn cumulative_claims_bounded(
        grant in 1_000u64..10_000_000_000,
        num_claims in 1usize..20,
        claim_pcts in prop::collection::vec(1u64..100, 1..20)
    ) {
        let mut claimed_so_far: u64 = 0;
        let duration = 31_536_000u64; // 1 year

        for (i, pct) in claim_pcts.iter().take(num_claims).enumerate() {
            let elapsed = (duration as u128 * (i as u128 + 1) * (*pct as u128))
                .min(duration as u128 * 100) / (num_claims as u128 * 100);
            let elapsed = (elapsed as u64).min(duration);

            let vested = (grant as u128 * elapsed as u128 / duration as u128) as u64;
            let claimable = vested.saturating_sub(claimed_so_far);
            claimed_so_far = claimed_so_far.checked_add(claimable).unwrap();

            prop_assert!(
                claimed_so_far <= grant,
                "after claim {}: claimed {} > grant {}", i, claimed_so_far, grant
            );
        }
    }
}
```

### LiteSVM Assertion
```rust
let schedule = create_vesting_schedule(&mut ctx, admin, beneficiary, grant, start_ts, duration);

let mut total_claimed: u64 = 0;
// Claim at multiple points throughout the vesting period
for step in 1..=10 {
    let warp_ts = start_ts + (duration * step / 10);
    ctx.warp_to_timestamp(warp_ts);

    let claimable = get_claimable_amount(&ctx, schedule);
    if claimable > 0 {
        execute_claim(&mut ctx, beneficiary, schedule);
        total_claimed += claimable;
    }

    let state = get_vesting_state(&ctx, schedule);
    assert!(
        state.claimed_so_far <= grant,
        "step {}: claimed {} exceeds grant {}", step, state.claimed_so_far, grant
    );
    assert_eq!(state.claimed_so_far, total_claimed, "claimed tracking mismatch");
}

// After full duration, claimed should equal grant
assert_eq!(total_claimed, grant, "did not unlock full grant: {} != {}", total_claimed, grant);
```

## Suggested Fix
```rust
pub fn claim(ctx: Context<Claim>) -> Result<()> {
    let schedule = &mut ctx.accounts.vesting_schedule;
    let clock = Clock::get()?;

    let vested = compute_vested(
        schedule.total_grant, clock.unix_timestamp as u64,
        schedule.start_ts, schedule.duration,
    )?;

    let claimable = vested
        .checked_sub(schedule.claimed_so_far)
        .ok_or(VestingError::Underflow)?;
    require!(claimable > 0, VestingError::NothingToClaim);

    // Update claimed_so_far BEFORE transfer (checks-effects-interactions)
    schedule.claimed_so_far = schedule.claimed_so_far
        .checked_add(claimable)
        .ok_or(VestingError::Overflow)?;
    require!(
        schedule.claimed_so_far <= schedule.total_grant,
        VestingError::ExceedsGrant
    );

    transfer_tokens(ctx.accounts, claimable)?;
    Ok(())
}
```
