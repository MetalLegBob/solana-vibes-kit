# Solana Exploit Patterns — Incident-Derived (EP-098 to EP-118)
<!-- Part 3 of 4: Patterns discovered from real-world audits, bounties, and cross-chain analysis -->
<!-- See also: exploit-patterns-core.md, exploit-patterns-advanced.md, exploit-patterns-recent.md -->
<!-- Full index: exploit-patterns-index.md -->
<!-- Last updated: 2026-02-06 -->

## Categories in This File
15. [Wave 3-4: Audit & Incident Patterns](#wave-3-4-audit--incident-patterns) (EP-098 to EP-105)
16. [Wave 5: Bug Bounty & Disclosure Patterns](#wave-5-bug-bounty--disclosure-patterns) (EP-106 to EP-110)
17. [Wave 6: Niche Exploit Patterns](#wave-6-niche-exploit-patterns) (EP-111 to EP-113)
18. [Wave 7: Cross-Chain Lessons](#wave-7-cross-chain-lessons) (EP-114 to EP-118)

---

### EP-098: CPI Destination Account Injection in Multi-Step Operations
**Category:** CPI / Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Texture Finance ($2.2M, Jul 2025 — vault rebalance missing ownership check)

**Description:** In multi-step operations (rebalance, migrate, compound), the program sends tokens via CPI to a destination account. If the destination account is not validated as belonging to the expected PDA/vault, an attacker can substitute their own account and intercept the tokens.

**Vulnerable Pattern:**
```rust
// Texture: Vault rebalances USDC into SuperLendy pools for LP tokens
// BUG: lp_token_account not validated as owned by vault
pub fn rebalance(ctx: Context<Rebalance>) -> Result<()> {
    let amount = ctx.accounts.vault.available_balance()?;
    // CPI to SuperLendy — deposits USDC, receives LP tokens
    superlend::cpi::deposit(
        CpiContext::new(
            ctx.accounts.superlend_program.to_account_info(),
            superlend::cpi::Deposit {
                depositor: ctx.accounts.vault.to_account_info(),
                lp_token_account: ctx.accounts.lp_token_account.to_account_info(), // NOT VALIDATED
                // ...
            },
        ),
        amount,
    )?;
    Ok(())
}
```
**Secure Pattern:**
```rust
#[derive(Accounts)]
pub struct Rebalance<'info> {
    #[account(mut)]
    pub vault: Account<'info, Vault>,
    #[account(
        mut,
        // CRITICAL: Verify LP token account is owned by vault PDA
        constraint = lp_token_account.owner == vault.key() @ ErrorCode::InvalidAccountOwner,
        // Also verify correct mint
        constraint = lp_token_account.mint == expected_lp_mint @ ErrorCode::InvalidMint,
    )]
    pub lp_token_account: Account<'info, TokenAccount>,
    // ...
}
```
**Detection:** In multi-step operations (rebalance, compound, migrate), verify every CPI destination account has ownership/authority constraints. Look for `token_account` parameters without `constraint = ... .owner ==` checks. Especially audit any function that moves tokens through intermediate steps.

---

### EP-099: Business Logic Inversion / Algorithm Direction Error
**Category:** Logic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Marinade SAM ($5M, 126 epochs — unstake algorithm implemented backward)

**Description:** Core business logic comparison operators are reversed (ascending vs descending, min vs max, greater-than vs less-than). Unlike off-by-one errors, the algorithm produces plausible but incorrect results that may not be caught by basic testing. Particularly dangerous in staking/delegation/auction systems where the effects accumulate over time.

**Vulnerable Pattern:**
```rust
// Marinade SAM: INTENDED to unstake lowest bidders first
// ACTUAL: sorted highest-first, protecting lowest bidders from unstaking
fn get_unstake_priority(validators: &mut Vec<ValidatorStake>) {
    // BUG: sort direction is backwards — should be ascending, not descending
    validators.sort_by(|a, b| b.bid_lamports.cmp(&a.bid_lamports));
    // Now "lowest bidders" are at the end and never get unstaked
}

// Gaming pattern: validator bids high to get stake, then reduces bid to 1 lamport
// Backward logic protects the low bid from unstaking for 126+ epochs
```
**Secure Pattern:**
```rust
fn get_unstake_priority(validators: &mut Vec<ValidatorStake>) {
    // CORRECT: ascending order — lowest bidders unstaked first
    validators.sort_by(|a, b| a.bid_lamports.cmp(&b.bid_lamports));
}

// Additional safeguard: prevent bid reduction after stake assignment
fn update_bid(validator: &mut ValidatorStake, new_bid: u64) -> Result<()> {
    require!(
        new_bid >= validator.current_bid * MIN_BID_RETENTION_PCT / 100,
        ErrorCode::BidReductionTooLarge
    );
    Ok(())
}
```
**Detection:** Identify all sorting, comparison, and priority functions. Verify sort direction matches specification/comments. Check for auction/bidding systems where participants can modify bids after winning. Test with adversarial scenarios where participants game the ordering. Look for `cmp` calls where `a` and `b` may be swapped.

**Sub-pattern: Fee Routing Inversion** (Halborn/Vaultka, Critical — withdraw fee sent to user instead of fee vault):
For every fee transfer instruction, verify: (a) fee destination matches the protocol's fee vault/treasury, not the user, (b) fee amount is deducted from user proceeds, not added to them. Trace the actual token flow in fee-related CPIs — a simple destination account mix-up can silently rebate fees to users.

---

### EP-100: ZK Proof Forgery / Verification Bypass
**Category:** Cryptography  **Severity:** CRITICAL  **Solana-Specific:** Yes (ZK ElGamal Proof program)
**Historical Exploits:** Solana ZK ElGamal Bug #1 (Apr 2025 — unhashed algebraic components in Fiat-Shamir, reported by LonelySloth, patched in 2 days), ZK ElGamal Bug #2 (Jun 2025 — separate Fiat-Shamir omission, reported by zksecurityXYZ, confidential transfers disabled, ZK ElGamal Proof program disabled at epoch 805), ZK ElGamal Bug #3 (Jan/Feb 2026 — third vulnerability found during re-audit before re-enabling program, patched by Anza+Firedancer+Jito engineers, no exploit). Same class of vulnerability found THREE TIMES — ZK proof systems are extremely fragile.

**Description:** Zero-knowledge proof verification logic contains flaws that allow forged or invalid proofs to pass validation. In confidential transfer systems, this can enable unauthorized minting or withdrawals without detection, as the amounts are encrypted and hidden from public view.

**Vulnerable Pattern:**
```rust
// Conceptual: ZK proof verifier with incomplete validation
pub fn verify_transfer_proof(proof: &ConfidentialTransferProof) -> Result<()> {
    // BUG: Verification does not check all proof components
    // Attacker can craft proof that passes partial checks but represents invalid statement
    verify_range_proof(&proof.range_proof)?;
    // MISSING: verify_equality_proof, verify_ciphertext_validity, etc.
    Ok(())
}
```
**Secure Pattern:**
```rust
// Use well-audited, complete ZK verification from official Solana programs
// Do NOT implement custom ZK verification logic
// Verify the ZK ElGamal Proof program is enabled and at expected version
pub fn verify_confidential_transfer(ctx: &Context) -> Result<()> {
    // Verify using official program, not custom logic
    require!(
        ctx.accounts.zk_proof_program.key() == ZK_ELGAMAL_PROOF_PROGRAM_ID,
        ErrorCode::InvalidProofProgram
    );
    // Check program is enabled (was disabled after Apr 2025 vulnerability)
    // Use latest program version with all patches applied
    Ok(())
}
```
**Detection:** Identify any use of Token-2022 confidential transfers. Verify the ZK ElGamal Proof program version is current and enabled. Check for custom ZK proof verification logic (extremely high risk). Audit any protocol that hides amounts — verify the hiding mechanism's cryptographic soundness. Check if ConfidentialTransfer, ConfidentialTransferFee, ConfidentialMint, ConfidentialBurn extensions are used.

---

### EP-101: Liquidity Extraction by Privileged Account
**Category:** Rug Pull / Access Control  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** LIBRA ($286M, Feb 2025 — $85M liquidity withdrawn in 2 hours), MELANIA ($200M, Jan 2025 — $26M liquidity withdrawn), SolFire ($4M, Jan 2022 — deposited funds drained by admin)

**Description:** Protocol deployer or admin retains the ability to withdraw liquidity from AMM pools, drain vaults, or extract deposited funds without restriction. This is the on-chain mechanism behind most rug pulls. The contract may appear legitimate but contains a privileged withdrawal path with no timelock, multisig, or community governance requirement.

**Vulnerable Pattern:**
```rust
// Deployer can remove all liquidity from AMM pool at any time
pub fn remove_liquidity(ctx: Context<RemoveLiquidity>, amount: u64) -> Result<()> {
    // Only checks deployer signature — no timelock, no multisig
    require!(ctx.accounts.authority.key() == DEPLOYER_PUBKEY);
    // Drains pool liquidity to deployer wallet
    transfer_from_pool(ctx.accounts.pool, ctx.accounts.authority_token_account, amount)?;
    Ok(())
}

// Variations:
// - LP token holder can burn and withdraw (LIBRA pattern)
// - Admin wallet holds majority of LP tokens from launch
// - "Migration" function moves all funds to new contract (actually attacker wallet)
```
**Secure Pattern:**
```rust
// Liquidity locked with timelock + multisig + community veto
pub fn remove_liquidity(ctx: Context<RemoveLiquidity>, amount: u64) -> Result<()> {
    let lock = &ctx.accounts.liquidity_lock;
    // Require timelock period has passed since proposal
    require!(
        Clock::get()?.unix_timestamp >= lock.proposed_at + LIQUIDITY_LOCK_PERIOD,
        ErrorCode::TimelockNotExpired
    );
    // Require multisig approval
    require!(lock.approvals >= REQUIRED_APPROVALS, ErrorCode::InsufficientApprovals);
    // Cap withdrawal amount per period
    require!(amount <= lock.max_withdrawal_per_period, ErrorCode::WithdrawalCapExceeded);
    // Emit event for off-chain monitoring
    emit!(LiquidityRemoved { amount, authority: ctx.accounts.authority.key() });
    transfer_from_pool(ctx.accounts.pool, ctx.accounts.destination, amount)?;
    Ok(())
}
```
**Detection:** Check who holds LP tokens after launch (concentrated ownership = rug risk). Verify liquidity lock contracts and timelock durations. Audit admin withdrawal functions for caps and multisig requirements. Check if deployer can call `remove_liquidity` or `withdraw` without restrictions. Look for "migration" or "upgrade" functions that move all funds. Verify LP token vesting schedules.

---

### EP-102: Registry / List Composition Attack (Omission/Duplication)
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Partial
**Historical Exploits:** Hylo (2 Critical, May 2025 — collateral ratio manipulation via LST registry omission/duplication)

**Description:** Protocol loads a registry, list, or set of items from variable-length input (e.g., `remaining_accounts`, instruction data) without enforcing canonical membership. Attacker omits unfavorable entries or duplicates favorable ones to skew calculations — collateral ratios, index compositions, voting weight, etc. The individual data may be valid, but the *composition of the set* is attacker-controlled.

**Vulnerable Pattern:**
```rust
// Registry loaded from variable-length remaining_accounts without canonical validation
pub fn calculate_collateral_ratio(ctx: Context<CalcRatio>) -> Result<u64> {
    let mut total_value = 0u64;
    for acc in ctx.remaining_accounts {
        let lst_block = LstBlock::deserialize(&acc.data.borrow())?;
        // BUG: No check for duplicates — attacker passes the same high-value LST 3x
        // BUG: No check for missing entries — attacker omits low-value LSTs
        total_value += lst_block.value;
    }
    Ok(total_value)
}
```
**Secure Pattern:**
```rust
pub fn calculate_collateral_ratio(
    ctx: Context<CalcRatio>,
    expected_mints: &[Pubkey],
) -> Result<u64> {
    let mut seen = HashSet::new();
    let mut total_value = 0u64;
    for acc in ctx.remaining_accounts {
        let lst_block = LstBlock::deserialize(&acc.data.borrow())?;
        // Prevent duplicates
        require!(!seen.contains(&lst_block.mint), ErrorCode::DuplicateEntry);
        seen.insert(lst_block.mint);
        total_value += lst_block.value;
    }
    // Verify all required entries are present
    require!(seen.len() == expected_mints.len(), ErrorCode::IncompleteRegistry);
    for mint in expected_mints {
        require!(seen.contains(mint), ErrorCode::MissingRequiredEntry);
    }
    Ok(total_value)
}
```
**Detection:** Look for functions loading variable-length registries, lists, or account sets from `remaining_accounts` or instruction data. Verify: (a) no duplicates allowed, (b) canonical/required entries enforced against on-chain state, (c) omission of entries cannot skew ratios or calculations. Applies to multi-collateral lending, index products, basket tokens, weighted voting.

---

### EP-103: ATA Assumption Failure in Migration/Claim
**Category:** Account Validation  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Cytonic Network (Medium, Jul 2024 — non-ATA deposits broke migration function)

**Description:** Protocol derives a user's Associated Token Account (ATA) to locate their tokens for migration, claim, airdrop, or refund operations. If a user deposited to a non-ATA token account (which is valid on Solana), the derived ATA has zero balance and the user's tokens are silently skipped or locked.

**Vulnerable Pattern:**
```rust
pub fn migrate(ctx: Context<Migrate>) -> Result<()> {
    // BUG: Assumes user's tokens are always in their ATA
    let user_ata = get_associated_token_address(&ctx.accounts.user.key(), &old_mint);
    let balance = get_token_balance(&user_ata)?; // Returns 0 if tokens are in non-ATA account
    // User's actual tokens in a different account — migration silently skips them
    mint_new_tokens(ctx.accounts.user_new_ata, balance)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
#[derive(Accounts)]
pub struct Migrate<'info> {
    pub user: Signer<'info>,
    // User provides their actual token account (ATA or otherwise)
    #[account(
        mut,
        constraint = user_token_account.owner == user.key() @ ErrorCode::InvalidOwner,
        constraint = user_token_account.mint == old_mint @ ErrorCode::InvalidMint,
    )]
    pub user_token_account: Account<'info, TokenAccount>,
    // ...
}

pub fn migrate(ctx: Context<Migrate>) -> Result<()> {
    let source = &ctx.accounts.user_token_account;
    // Works regardless of whether source is ATA or non-ATA
    burn_old_tokens(source, source.amount)?;
    mint_new_tokens(ctx.accounts.user_new_ata, source.amount)?;
    Ok(())
}
```
**Detection:** Search for `get_associated_token_address` used to derive source accounts for migration, claim, or refund operations. Verify the protocol either (a) enforces ATA-only deposits at entry point, or (b) accepts user-specified source accounts with proper ownership/mint validation. Particularly risky in token migration, airdrop claim, and emergency withdrawal functions.

---

### EP-104: Cross-Chain Message Non-Recoverability
**Category:** Bridge / Cross-Chain  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Olympus DAO OFT (High, Mar 2023 — failed LayerZero messages locked tokens permanently)

**Description:** Cross-chain bridge burns or locks tokens on the source chain immediately upon send, but if the message fails on the destination chain (validator downtime, gas issues, payload errors), there is no retry or refund mechanism. Tokens are permanently locked/burned with no recovery path.

**Vulnerable Pattern:**
```rust
pub fn send_cross_chain(ctx: Context<Send>, amount: u64, dst_chain: u16) -> Result<()> {
    // BUG: Tokens burned immediately — no recovery if destination fails
    burn_tokens(&ctx.accounts.source_token_account, amount)?;
    send_lz_message(dst_chain, payload)?;
    // If message fails on destination: tokens are gone forever
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn send_cross_chain(ctx: Context<Send>, amount: u64, dst_chain: u16) -> Result<()> {
    let transfer = &mut ctx.accounts.pending_transfer;
    transfer.amount = amount;
    transfer.dst_chain = dst_chain;
    transfer.status = TransferStatus::Pending;
    transfer.created_at = Clock::get()?.unix_timestamp;
    transfer.sender = ctx.accounts.user.key();

    // Escrow tokens (don't burn yet) — can be reclaimed on failure
    escrow_tokens(&ctx.accounts.source_token_account, &ctx.accounts.escrow, amount)?;
    send_lz_message(dst_chain, payload)?;
    // On destination confirmation: mark complete, burn escrowed tokens
    // On failure/timeout: user calls reclaim_failed_transfer()
    Ok(())
}

pub fn reclaim_failed_transfer(ctx: Context<Reclaim>) -> Result<()> {
    let transfer = &ctx.accounts.pending_transfer;
    require!(transfer.status == TransferStatus::Failed, ErrorCode::NotFailed);
    require!(transfer.sender == ctx.accounts.user.key(), ErrorCode::NotSender);
    release_escrow(&ctx.accounts.escrow, &ctx.accounts.user_token_account, transfer.amount)?;
    Ok(())
}
```
**Detection:** In bridge/cross-chain programs, verify: (a) tokens are escrowed, not burned, until destination confirmation, (b) failed messages have a retry mechanism, (c) timeout/refund exists for permanently failed messages, (d) pending transfer state is tracked on-chain. Check LayerZero, Wormhole, and custom bridge integrations.

---

### EP-105: Fee Exclusion from Pool Accounting Invariants
**Category:** Economic / DeFi  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Blockstreet Launchpad (Critical, Aug-Sep 2025 — platform fees excluded from pool accounting)

**Description:** Protocol collects fees (platform fees, performance fees, withdrawal fees) but the fee amounts are not tracked in pool state variables. Over time, the pool's internal accounting drifts from actual token balances because fees are a "leak" not captured in the bookkeeping equation. This breaks the fundamental invariant: `total_deposited == total_withdrawn + total_fees + current_balance`.

**Vulnerable Pattern:**
```rust
pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let fee = amount * pool.fee_rate / 10000;
    let user_receives = amount - fee;

    // Transfer fee to protocol treasury
    transfer_tokens(&ctx.accounts.pool_vault, &ctx.accounts.fee_vault, fee)?;
    // Transfer remainder to user
    transfer_tokens(&ctx.accounts.pool_vault, &ctx.accounts.user, user_receives)?;

    // BUG: Pool accounting only tracks the withdrawal, not the fee
    pool.total_value -= amount; // Subtracts full amount including fee
    // But fee went to fee_vault, not user — pool.total_value no longer matches pool_vault balance
    // Over many withdrawals, drift accumulates
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    let fee = amount * pool.fee_rate / 10000;
    let user_receives = amount - fee;

    transfer_tokens(&ctx.accounts.pool_vault, &ctx.accounts.fee_vault, fee)?;
    transfer_tokens(&ctx.accounts.pool_vault, &ctx.accounts.user, user_receives)?;

    // CORRECT: Track fees separately in pool accounting
    pool.total_value -= amount;
    pool.total_fees_collected += fee;
    pool.total_withdrawn += user_receives;

    // Invariant check (can be an assertion or off-chain monitoring):
    // pool_vault.amount == pool.total_value - pool.total_withdrawn - pool.total_fees_collected
    Ok(())
}
```
**Detection:** For every fee collection point (deposit fees, withdrawal fees, performance fees, platform fees), verify the fee amount is tracked in pool state. Check that `pool.total_value_locked` or equivalent accounts for fee deductions. Look for pool invariant checks — if none exist, flag as medium risk. Verify: `actual_vault_balance == expected_balance_from_accounting`.

---

## Wave 5: Bug Bounty & Disclosure Patterns (EP-106 to EP-110)

### EP-106: Lamport Transfer Write-Demotion Trap
**Category:** Account Validation / Runtime  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** "King of the SOL" secp256r1_program eternal king (May 2025 — OtterSec disclosure)

**Description:** When transferring lamports to arbitrary accounts, the Solana runtime silently demotes certain accounts from writable to read-only during message sanitization. Accounts on the "reserved account list" (built-in programs, sysvars) and executable accounts cannot receive lamport transfers even if marked `mut`. Programs that reimburse or refund lamports to arbitrary user-provided accounts will silently fail or brick when the target account is reserved/executable.

Three sub-traps:
1. **Rent-Exemption Trap:** Transferring FROM an account can drop it below rent-exempt threshold, causing account garbage collection
2. **Executable Account Trap:** Executable accounts (programs) reject lamport writes — `set_lamports` fails silently
3. **Write-Demotion Trap:** Reserved accounts are silently downgraded from writable to read-only by runtime

**Vulnerable Pattern:**
```rust
// King-of-the-Hill: reimburse previous king
pub fn claim_throne(ctx: Context<ClaimThrone>) -> Result<()> {
    let old_king = &ctx.accounts.old_king; // User-provided account
    let bid = ctx.accounts.bid_amount;

    // BUG: If old_king is secp256r1_program or other reserved account,
    // this silently fails — old_king can never be dethroned
    **old_king.lamports.borrow_mut() += bid;
    **ctx.accounts.vault.lamports.borrow_mut() -= bid;
    Ok(())
}
```
**Secure Pattern:**
```rust
// Never transfer lamports to arbitrary accounts
// Use a PDA vault for refunds, let users claim
pub fn claim_throne(ctx: Context<ClaimThrone>) -> Result<()> {
    let refund_vault = &ctx.accounts.refund_vault; // PDA owned by program
    // Store refund in vault, user claims via separate instruction
    refund_vault.pending_refund += bid;
    refund_vault.recipient = old_king.key();
    Ok(())
}
```
**Detection:** Find lamport transfers to user-provided accounts (`**account.lamports.borrow_mut()`). Check if the recipient is validated as NOT executable and NOT on the reserved list. Flag any pattern where lamports are sent to an arbitrary `AccountInfo` without checks.

---

### EP-107: AccountInfo::realloc Out-of-Bounds Memory Corruption
**Category:** Account Validation / Memory Safety  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** OtterSec disclosure (Dec 2022 — SDK bug in AccountInfo::realloc)

**Description:** `AccountInfo::realloc()` uses `unsafe` code to write the new length to the serialized buffer (8 bytes before the data pointer) and update the local slice reference. There are NO bounds checks during execution — BPF loader only validates AFTER contract finishes. An attacker can call `realloc` with an excessively large size, writing past the allocated buffer into adjacent accounts' data and lamports in the serialized buffer. If the size is reverted to valid before program exit, the corruption persists while passing post-execution validation.

This is distinct from EP-012 (which covers not zeroing new space). EP-107 is about exploiting realloc as a memory corruption primitive.

**Vulnerable Pattern:**
```rust
// Program allows user-controlled realloc size
pub fn resize(ctx: Context<Resize>, new_size: u64) -> Result<()> {
    let account = &ctx.accounts.data_account;
    // BUG: No bounds check — can write past buffer into adjacent accounts
    account.realloc(new_size as usize, false)?;

    // Attacker writes to out-of-bounds area (adjacent account's lamports/data)
    // Then reverts size to pass BPF loader post-execution check
    account.realloc(original_size as usize, false)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn resize(ctx: Context<Resize>, new_size: u64) -> Result<()> {
    let account = &ctx.accounts.data_account;
    let original_len = account.data_len(); // Or use original_data_len()

    // Bound check: max 10KB growth per instruction (runtime limit)
    require!(new_size as usize <= original_len + 10240, ErrorCode::SizeTooLarge);
    // Additional bound: don't exceed max account size
    require!(new_size <= 10_000_000, ErrorCode::SizeTooLarge);

    account.realloc(new_size as usize, true)?; // zero_init = true
    Ok(())
}
```
**Detection:** Find `realloc()` calls. Check if new size is user-controlled or unbounded. Verify bounds checking against `original_data_len()`. Flag any realloc where size comes from instruction data without validation. Also flag realloc followed by a second realloc (potential corrupt-then-revert pattern).

---

### EP-108: Remaining Account Spoofing in Extension Patterns
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Raydium CLMM Tick Manipulation ($505K bounty, Jan 2024 — TickArrayBitmapExtension not validated)

**Description:** Programs that use `remaining_accounts` for auxiliary/extension accounts (tick arrays, bitmap extensions, oracle accounts, etc.) may fail to validate that the account is the correct one for the context. The `remaining_accounts` pattern bypasses Anchor's compile-time account validation, making it the programmer's responsibility to verify each account's identity, owner, and relationship to other accounts.

**Vulnerable Pattern:**
```rust
// Raydium CLMM: increase_liquidity uses remaining_accounts for tick bitmap extension
pub fn increase_liquidity(ctx: Context<IncreaseLiquidity>) -> Result<()> {
    let pool = &ctx.accounts.pool_state;

    // BUG: remaining_accounts[0] is used as TickArrayBitmapExtension
    // but NOT validated as the correct extension for THIS pool
    let tick_bitmap_ext = &ctx.remaining_accounts[0];

    // Attacker passes a malicious/wrong extension account
    // Tick status is read from wrong bitmap → incorrect liquidity calculations
    flip_tick_in_bitmap(tick_bitmap_ext, tick_index)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn increase_liquidity(ctx: Context<IncreaseLiquidity>) -> Result<()> {
    let pool = &ctx.accounts.pool_state;

    if !ctx.remaining_accounts.is_empty() {
        let tick_bitmap_ext = &ctx.remaining_accounts[0];
        // VALIDATE: extension must be the correct PDA for this pool
        let expected_key = TickArrayBitmapExtension::key(pool.key());
        require_keys_eq!(tick_bitmap_ext.key(), expected_key, ErrorCode::InvalidAccount);
        // Also verify owner
        require!(tick_bitmap_ext.owner == &crate::ID, ErrorCode::InvalidOwner);
    }
    Ok(())
}
```
**Detection:** Find `remaining_accounts` usage. For each access, verify the account is validated (PDA derivation check, owner check, key comparison). Flag any `remaining_accounts[N]` used without validation. Pay special attention to CLMM/AMM programs with tick arrays, bitmap extensions, or oracle accounts passed via remaining_accounts.

---

### EP-109: LP Deposit Rounding Drain
**Category:** Arithmetic / Economic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Raydium cp-swap Liquidity Drain ($505K bounty, Mar 2025 — ceiling rounding on zero amounts)

**Description:** In AMM deposit functions, the conversion between LP tokens and underlying tokens uses rounding (ceiling or floor). When the deposit amount is very small, integer arithmetic with ceiling rounding can produce `token_amount = 0` for one side while still minting LP tokens. An attacker deposits with only one token type, receives LP tokens, then withdraws both token types proportionally — draining the pool one tiny iteration at a time.

**Vulnerable Pattern:**
```rust
pub fn deposit(ctx: Context<Deposit>, lp_amount: u64) -> Result<()> {
    let pool = &ctx.accounts.pool;
    // Convert LP amount to required token amounts
    let (token_0_amount, token_1_amount) = lp_tokens_to_trading_tokens(
        lp_amount,
        pool.lp_supply,
        pool.token_0_vault_amount,
        pool.token_1_vault_amount,
        RoundDirection::Ceiling, // Ceiling rounds UP
    )?;
    // BUG: If lp_amount is tiny, token_1_amount can round to 0
    // Attacker deposits only token_0, gets LP tokens for free
    transfer_from_user(token_0_amount)?; // Small amount
    transfer_from_user(token_1_amount)?; // ZERO — no transfer needed
    mint_lp(lp_amount)?; // Still mints LP tokens
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn deposit(ctx: Context<Deposit>, lp_amount: u64) -> Result<()> {
    let (token_0_amount, token_1_amount) = lp_tokens_to_trading_tokens(
        lp_amount, pool.lp_supply, pool.token_0_vault_amount,
        pool.token_1_vault_amount, RoundDirection::Ceiling,
    )?;
    // CRITICAL: Reject zero amounts
    require!(token_0_amount > 0, ErrorCode::ZeroAmount);
    require!(token_1_amount > 0, ErrorCode::ZeroAmount);
    require!(lp_amount > 0, ErrorCode::ZeroAmount);

    transfer_from_user(token_0_amount)?;
    transfer_from_user(token_1_amount)?;
    mint_lp(lp_amount)?;
    Ok(())
}
```
**Detection:** In AMM deposit/withdrawal functions, check rounding direction and verify that ALL calculated amounts are checked for `> 0`. Look for `RoundDirection::Ceiling` or `RoundDirection::Floor` in token calculations. Flag any deposit that doesn't validate both token amounts are non-zero.

---

### EP-110: Inter-Transaction Account Hijack (Rent Thief)
**Category:** Initialization / Race Condition  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Solend Rent Thief (Aug 2022 — OtterSec disclosure, ~0.0082 SOL/attack but caused tx failures)

**Description:** When account creation requires multiple transactions (due to tx size limits), there's a window between creation (tx1) and initialization (tx2) where accounts have rent money but no program owner. An attacker bot can seize ownership, drain rent, and close accounts in this gap, causing the legitimate initialization to fail.

**Vulnerable Pattern:**
```rust
// Transaction 1: Create accounts (system program)
// Creates 6 accounts with enough SOL for rent-exemption
// Accounts are owned by System Program at this point

// ... 40+ second gap where attacker can act ...

// Transaction 2: Initialize accounts (program)
// BUG: Accounts may no longer exist or have different owner
pub fn init_reserve(ctx: Context<InitReserve>) -> Result<()> {
    // If attacker took ownership and closed accounts, this fails
    Ok(())
}
```
**Secure Pattern:**
```rust
// Atomic: Create AND initialize in same transaction or same CPI chain
pub fn init_reserve_atomic(ctx: Context<InitReserveAtomic>) -> Result<()> {
    // Use a program-owned instruction to create all accounts via CPI
    // and initialize them in the same transaction
    for account_info in accounts_to_create {
        system_program::create_account(/* ... */)?; // Create
        initialize_account(account_info)?;           // Init immediately
    }
    Ok(())
}
// Or use Anchor's init constraint which does both atomically
```
**Detection:** Look for multi-transaction initialization patterns. Check if account creation and initialization happen in separate transactions. Flag any pattern where accounts are created in one tx and initialized in another. Also flag programs that check account existence by lamport balance (`lamports > 0`) instead of proper state/discriminator checks.

---

### EP-111: TOCTOU Simulation Evasion (On-Chain)
**Category:** Client-Side / Timing  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Widespread wallet drainer technique (2024-2025, $500M+ total crypto drainer losses)

**Description:** Malicious program behaves differently during wallet simulation (preview) vs actual on-chain execution. Exploits the time gap between when a wallet simulates a transaction (Time-of-Check) and when it executes on-chain (Time-of-Use). Unlike EP-093 (off-chain TOCTOU), this targets the on-chain simulation/execution divergence.

**Attack Flow:**
1. Attacker deploys program that checks mutable external state (lookup table, PDA data, clock)
2. During simulation: program reads "safe" state → transfers small harmless amount
3. User signs based on simulation preview
4. Between sign and execution: attacker updates the external state
5. During execution: program reads "malicious" state → drains wallet

**Why Solana is vulnerable:** Signing grants ALL programs in the transaction write access to writable accounts. Wallet simulations are point-in-time snapshots.

**Vulnerable Pattern:**
```rust
pub fn process(ctx: Context<Process>) -> Result<()> {
    let config = &ctx.accounts.config;  // Mutable external state!
    if config.mode == Mode::Safe {
        // Simulation sees this: small transfer
        transfer(ctx.accounts.user, ctx.accounts.dest, 1)?;
    } else {
        // Execution hits this: drain everything
        transfer(ctx.accounts.user, ctx.accounts.attacker, user_balance)?;
    }
    Ok(())
}
// Attacker updates config.mode between simulation and execution
```
**Secure Pattern:**
```rust
// Programs should not branch on mutable external state for security-critical logic
// Wallets should use transaction guards or simulation-at-execution services
// Protocols: use immutable config or require user signature on config changes
```
**Detection:** Flag programs that branch on mutable external account data in ways that affect fund flows. Check for clock-gated behavior (`Clock::get()?.slot` used in conditionals). Audit programs that read from updatable lookup tables or config PDAs controlled by third parties. Note: This is primarily a wallet/client concern, but auditors should flag programs designed to exploit this pattern.

**Source:** Blockaid TOCTOU analysis (Sep 2024)

---

### EP-112: Validator MEV Sandwich Extraction
**Category:** Protocol / Infrastructure  **Severity:** INFO (for contract auditors)  **Solana-Specific:** Yes
**Historical Exploits:** DeezNode ($13M, Dec 2024), Arsc ($60M, single month), ecosystem-wide ($370M-$500M over 16 months through May 2025)

**Description:** Validators (and validators doubling as RPC providers) use their block production position to insert front-run and back-run transactions around user swaps, extracting value via sandwich attacks. Not a smart contract vulnerability, but a protocol-level concern that protocol designers should account for.

**Scale (sandwiched.me analysis, 16 months through May 2025):**
- $370M-$500M total extracted
- 8.5B trades analyzed, $1T+ DEX volume
- Top 2 attackers = 48.69% of all MEV drains
- Top 7 attackers = 92.61%
- Peak: Nov 2024 (Trump/Melania token launches)
- Jito mempool shutdown (Mar 2024) failed — attacks adapted within 1 month
- "Wide sandwiches" (non-consecutive txs) emerged to evade detection
- 25% of victims paid MEV protection but still lost funds

**Relevance to Smart Contract Audits:**
- Protocols should enforce `min_amount_out` on all swaps (EP-060)
- DEX aggregators should use transaction-level slippage protection
- Protocols using on-chain price should consider MEV manipulation window
- Private transaction submission (Jito bundles) doesn't fully protect users

**Detection:** Check all swap/trade instructions for `min_amount_out` enforcement. Flag protocols that rely on fair execution ordering. Note: validator-level extraction is outside smart contract audit scope but should be mentioned in protocol design review.

**Sources:** sandwiched.me May 2025 analysis, DeezNode/Arsc incident reports, Jito mempool history

---

### EP-113: Frontend/DNS Hijack Attack
**Category:** Infrastructure  **Severity:** CRITICAL  **Solana-Specific:** No (but Solana ecosystem incidents documented)
**Historical Exploits:** Parcl (Aug 2024 — DNS hijack, wallet draining), general crypto DNS hijacking ($M+ in 2024)

**Description:** Attacker compromises the DNS resolution or frontend hosting of a DeFi protocol, redirecting users to a malicious clone that prompts wallet connections and transaction signing. Distinguished from supply chain attacks (EP-095) in that the protocol's smart contracts are unaffected — only the frontend/DNS layer is compromised.

**Attack Flow:**
1. Attacker compromises DNS records (registrar, DNS provider, or CDN)
2. User navigates to legitimate URL → resolved to attacker-controlled server
3. Malicious frontend mimics real UI, prompts wallet connection
4. User signs what appears to be a normal transaction → funds drained
5. SSL certificate may still appear valid (attacker can obtain one for the domain)

**Vulnerable Pattern:**
```
// No smart contract vulnerability — attack is at infrastructure layer
// Parcl (Aug 2024): DNS hijacked, displayed false transaction results in Phantom
// Users' Solana wallets drained via malicious transaction prompts
```
**Secure Pattern (Protocol Operators):**
```
// 1. DNSSEC enabled on all domains
// 2. Multi-factor auth on domain registrar + DNS provider
// 3. Content Security Policy headers to prevent script injection
// 4. On-chain transaction verification (not just frontend display)
// 5. Domain monitoring for unauthorized changes
// 6. Wallet-level warnings for known compromised frontends (Blowfish, Pocket Universe)
```
**Detection:** Not detectable via smart contract audit. Flag in protocol infrastructure review: Does the protocol use DNSSEC? Is the frontend decentralized (IPFS) or centralized? Are there fallback mechanisms if the frontend is compromised?

**Sources:** Parcl DNS hijack (Aug 2024), Pocket Universe detection, general DNS hijacking research

---

## Wave 7: Cross-Chain Lessons (EP-114 to EP-118)

### EP-114: Flash Loan Governance Takeover
**Category:** Economic / Governance  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Beanstalk ($182M, Apr 2022 — flash loaned $1B to pass malicious governance proposal in <13 seconds)

**Description:** Attacker borrows governance tokens via flash loan, gains supermajority voting power, votes on and executes a malicious proposal that drains the treasury, then repays the loan — all in a single atomic transaction. On EVM, Beanstalk's `emergencyCommit()` allowed same-block vote + execute. On Solana, SPL Governance's early vote tipping with zero hold-up time enables the same pattern.

**Vulnerable Pattern:**
```rust
// SPL Governance: early tipping + zero hold-up + liquid governance tokens
GovernanceConfig {
    vote_tipping: VoteTipping::Early,      // Ends vote as soon as majority reached
    min_transaction_hold_up_time: 0,       // Execute immediately after approval
    deposit_exempt_proposal_count: 0,
    // No snapshot — voting power = current token balance
}
// Attack: flash loan tokens → deposit → create proposal → vote (tips immediately)
// → execute (zero hold-up) → drain treasury → repay flash loan
```
**Secure Pattern:**
```rust
GovernanceConfig {
    vote_tipping: VoteTipping::Strict,     // Wait for full voting period
    min_transaction_hold_up_time: 172800,  // 48h minimum hold-up
    // Plus: require tokens locked for N slots before voting
    // Plus: snapshot voting power at proposal creation time
}
```
**Detection:** Check SPL Governance configs: (a) vote tipping mode, (b) hold-up time, (c) whether governance tokens can be flash-loaned, (d) whether voting requires prior token lock-up, (e) whether voting power is snapshotted at proposal creation. Flag any DAO where `hold_up_time == 0` or where governance tokens are available on lending protocols.

---

### EP-115: Donation/Reserve Function Solvency Bypass
**Category:** Economic / DeFi  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Euler Finance ($197M, Mar 2023 — `donateToReserves` burned collateral without solvency check)

**Description:** Protocol has a function that modifies a user's collateral or debt position (donate, contribute, add-to-reserve, forfeit) without verifying that the position remains solvent afterward. Attacker intentionally drives their position into bad debt, then exploits the liquidation mechanism (favorable discount, self-liquidation) to extract value. The key insight: any function that can make a position unhealthy without checking is an exploit primitive.

**Vulnerable Pattern:**
```rust
pub fn donate_to_reserve(ctx: Context<Donate>, amount: u64) -> Result<()> {
    let user_position = &mut ctx.accounts.user_position;
    let reserve = &mut ctx.accounts.reserve;

    // Burns user's collateral tokens (eTokens equivalent)
    user_position.collateral -= amount;
    reserve.total_reserves += amount;

    // BUG: No health check — position may now be insolvent
    // Attacker leverages up → donates collateral → triggers self-liquidation at discount
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn donate_to_reserve(ctx: Context<Donate>, amount: u64) -> Result<()> {
    let user_position = &mut ctx.accounts.user_position;
    let reserve = &mut ctx.accounts.reserve;

    user_position.collateral -= amount;
    reserve.total_reserves += amount;

    // CRITICAL: Verify position is still healthy after any collateral change
    let health = calculate_health_factor(user_position, oracle_price)?;
    require!(health >= MIN_HEALTH_FACTOR, ErrorCode::PositionUnhealthy);
    Ok(())
}
```
**Detection:** Find ALL functions that decrease collateral, increase debt, or modify position health. For each, verify a solvency/health check occurs AFTER the modification. Includes: donate, forfeit, contribute, burn-collateral, transfer-position, split-position, and any admin function that modifies individual positions. Also check liquidation discount — if an attacker can self-liquidate at favorable rates, the donate→liquidate loop is profitable.

---

### EP-116: Vault Share Price Manipulation via Donation
**Category:** Economic / DeFi  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** C.R.E.A.M. Finance ($130M, Oct 2021 — donated to yUSD vault to inflate pricePerShare), Harvest Finance ($34M, Oct 2020 — manipulated Curve pool to skew vault pricing)

**Description:** Vaults that calculate share price as `total_assets / total_shares` are vulnerable when an attacker can increase `total_assets` without minting new shares (via direct token transfer/donation). This inflates the share price, allowing the attacker to borrow against inflated collateral or withdraw more than they deposited. The "sandwich the vault" variant: manipulate price down → deposit → restore price → withdraw at profit.

**Vulnerable Pattern:**
```rust
pub fn get_share_price(vault: &Vault) -> u64 {
    // BUG: Uses actual token balance — can be inflated by direct transfer
    let total_assets = token::balance(&vault.token_account)?;
    total_assets.checked_div(vault.total_shares).unwrap_or(1)
}

pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
    let shares = amount * ctx.accounts.vault.total_shares / get_total_assets()?;
    // If attacker donated tokens before this, shares_minted is too low
    // Attacker deposits small amount, gets fewer shares, then withdraws donated tokens
    mint_shares(shares)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn get_share_price(vault: &Vault) -> u64 {
    // Use internally tracked assets, NOT actual balance
    vault.tracked_total_assets.checked_div(vault.total_shares).unwrap_or(1)
}

pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
    // Virtual reserves: add "dead shares" at initialization to prevent first-depositor attack
    let virtual_assets = vault.tracked_total_assets + VIRTUAL_ASSETS;
    let virtual_shares = vault.total_shares + VIRTUAL_SHARES;
    let shares = amount * virtual_shares / virtual_assets;
    require!(shares > 0, ErrorCode::ZeroShares);
    vault.tracked_total_assets += amount;
    mint_shares(shares)?;
    Ok(())
}
```
**Detection:** For any vault/pool contract: (a) check if share price uses actual token balance vs internal accounting, (b) check if direct token transfers affect pricing, (c) look for "dead shares" or virtual reserve patterns (absence = vulnerable), (d) verify minimum deposit amounts exist. Applies to yield vaults, LP tokens, receipt tokens, and any share-based accounting.

---

### EP-117: Upgrade Initialization Gap
**Category:** Initialization / Upgrade  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Ronin Bridge V2 ($12M, Aug 2024 — forgot to call `initializeV3` after upgrade, left operator weight at zero)

**Description:** During a program upgrade that introduces new state fields, the initialization function for new fields is not called (or called incorrectly). New state defaults to zero/empty, which may disable security checks that depend on non-zero values. On EVM, this typically involves missing initializer calls in proxy upgrades. On Solana, upgradeable programs face similar risks when adding new state fields to existing accounts.

**Vulnerable Pattern:**
```rust
// V2 adds a new field: min_validator_weight
#[account]
pub struct BridgeConfig {
    pub guardians: Vec<Pubkey>,
    pub threshold: u8,
    pub min_validator_weight: u64, // NEW in V2 — defaults to 0 if not initialized!
}

pub fn verify_message(ctx: Context<Verify>) -> Result<()> {
    let config = &ctx.accounts.config;
    // BUG: If min_validator_weight is 0 (uninitialized), this check always passes
    require!(total_weight >= config.min_validator_weight, ErrorCode::InsufficientWeight);
    Ok(())
}
```
**Secure Pattern:**
```rust
// Migration instruction that MUST be called after upgrade
pub fn migrate_v2(ctx: Context<MigrateV2>) -> Result<()> {
    let config = &mut ctx.accounts.config;
    // Set new fields to safe defaults
    config.min_validator_weight = DEFAULT_MIN_WEIGHT; // Non-zero!
    config.version = 2;
    Ok(())
}

pub fn verify_message(ctx: Context<Verify>) -> Result<()> {
    let config = &ctx.accounts.config;
    // Defense-in-depth: reject zero weight even if migration was missed
    require!(config.min_validator_weight > 0, ErrorCode::UninitializedConfig);
    require!(total_weight >= config.min_validator_weight, ErrorCode::InsufficientWeight);
    Ok(())
}
```
**Detection:** During upgrade reviews: (a) list all new state fields added, (b) verify a migration instruction exists that sets them to non-zero/safe values, (c) verify the migration is called in the upgrade transaction or gated behind a version check, (d) check if any security-critical logic depends on the new fields being non-zero. Flag any `require!(value >= config.new_field)` where `new_field` defaults to 0.

---

### EP-118: Flash Loan Account State Migration Bypass
**Category:** Logic / State Machine  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** MarginFi ($160M at risk, Sep 2025 — `transfer_to_new_account` bypassed flash loan repayment check, patched before exploit)

**Description:** Program has both flash loan functionality AND account migration/transfer instructions. During an active flash loan, the user's account is in a temporary state (borrowed but not yet repaid). If the account can be migrated or transferred to a new account during this window, the flash loan repayment check operates on the old (zeroed/disabled) account instead of the new one, allowing the borrower to keep funds without repayment.

**Vulnerable Pattern:**
```rust
pub fn flash_loan_start(ctx: Context<FlashLoan>) -> Result<()> {
    let account = &mut ctx.accounts.user_account;
    account.flash_loan_active = true;
    transfer_tokens_to_user(amount)?;
    Ok(())
}

pub fn transfer_to_new_account(ctx: Context<Transfer>) -> Result<()> {
    let old_account = &mut ctx.accounts.old_account;
    let new_account = &mut ctx.accounts.new_account;
    // BUG: No check for active flash loan
    new_account.balances = old_account.balances.clone();
    old_account.balances = Balances::default(); // Zeroed out
    old_account.disabled = true;
    Ok(())
}

pub fn flash_loan_end(ctx: Context<FlashLoan>) -> Result<()> {
    let account = &ctx.accounts.user_account; // Points to OLD account
    // OLD account is zeroed/disabled — health check passes (no liability)
    // Borrowed funds are gone, never repaid
    account.flash_loan_active = false;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn transfer_to_new_account(ctx: Context<Transfer>) -> Result<()> {
    let old_account = &ctx.accounts.old_account;
    // CRITICAL: Block migration during active flash loan
    require!(!old_account.flash_loan_active, ErrorCode::FlashLoanActive);
    // ... proceed with migration
    Ok(())
}
```
**Detection:** For any program with flash loan support: (a) identify ALL instructions that can modify, move, or reset account state, (b) verify each checks for active flash loan state, (c) test: can a user start a flash loan, call another instruction that resets their state, then end the flash loan? Also applies to: account delegation, account close, authority transfer, and position splitting during flash loans.

---

<!-- END: exploit-patterns-incidents.md | EP-098 to EP-118 | Waves 3-7 -->
