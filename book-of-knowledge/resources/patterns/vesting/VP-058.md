# VP-058: Cliff Unlock Timing Precision

**Category:** Vesting
**Verification tool:** Kani

## What Can Go Wrong
Cliff vesting should release exactly zero tokens before the cliff timestamp and the correct cliff amount at or after it. Off-by-one errors in timestamp comparison (using `<` vs `<=`, or `>` vs `>=`) can release tokens one second early or delay release by one second. This breaks the vesting contract with investors and can enable front-running if an attacker knows the exact cliff boundary and the comparison is wrong.

## Why It Matters
An attacker calls the claim function one second before the cliff using a block timestamp at the exact boundary. If the comparison uses strict less-than instead of less-than-or-equal, the cliff amount releases early, giving the attacker tokens before other participants who are waiting for the announced cliff date. In token launches, even a one-second early unlock can be exploited to dump tokens ahead of scheduled vesting events.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Multiple token vesting audits have flagged off-by-one cliff timing bugs as high severity. The pattern is especially dangerous on Solana where slot times are short and timestamp granularity matters.

## Invariant

### Formal Property
```
forall timestamp, cliff_ts, cliff_amount:
  timestamp < cliff_ts  implies unlocked = 0
  timestamp >= cliff_ts implies unlocked >= cliff_amount
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_cliff_timing() {
    let now: u64 = kani::any();
    let cliff_ts: u64 = kani::any();
    let cliff_amount: u64 = kani::any();
    let total_grant: u64 = kani::any();

    kani::assume!(cliff_ts > 0 && cliff_ts < u64::MAX);
    kani::assume!(cliff_amount > 0 && cliff_amount <= total_grant);
    kani::assume!(total_grant > 0);
    kani::assume!(now > 0 && now < u64::MAX);

    let unlocked = if now < cliff_ts { 0 } else { cliff_amount };

    kani::assert!(now >= cliff_ts || unlocked == 0, "tokens released before cliff");
    kani::assert!(now < cliff_ts || unlocked >= cliff_amount, "cliff amount not released at cliff");
    kani::assert!(unlocked <= total_grant, "unlocked exceeds total grant");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn cliff_unlock_timing(
        cliff_ts in 1_000_000u64..2_000_000_000,
        cliff_amount in 1u64..1_000_000_000,
        offset in 0u64..1_000_000
    ) {
        // Test one second before cliff
        let before_cliff = cliff_ts.saturating_sub(1);
        let unlocked_before = cliff_unlock(before_cliff, cliff_ts, cliff_amount);
        prop_assert_eq!(unlocked_before, 0, "released {} before cliff", unlocked_before);

        // Test exactly at cliff
        let unlocked_at = cliff_unlock(cliff_ts, cliff_ts, cliff_amount);
        prop_assert_eq!(unlocked_at, cliff_amount, "at cliff: got {} expected {}", unlocked_at, cliff_amount);

        // Test after cliff
        let after_cliff = cliff_ts.saturating_add(offset).max(cliff_ts);
        let unlocked_after = cliff_unlock(after_cliff, cliff_ts, cliff_amount);
        prop_assert!(
            unlocked_after >= cliff_amount,
            "after cliff: got {} < cliff_amount {}", unlocked_after, cliff_amount
        );
    }
}
```

### LiteSVM Assertion
```rust
let cliff_ts = start_ts + cliff_duration;
let schedule = create_vesting_schedule(
    &mut ctx, admin, beneficiary, grant, start_ts, cliff_duration, total_duration
);

// One second before cliff: nothing unlocked
ctx.warp_to_timestamp(cliff_ts - 1);
let claimable_before = get_claimable_amount(&ctx, schedule);
assert_eq!(claimable_before, 0, "tokens claimable before cliff: {}", claimable_before);

// Exactly at cliff: cliff amount unlocked
ctx.warp_to_timestamp(cliff_ts);
let claimable_at = get_claimable_amount(&ctx, schedule);
assert_eq!(claimable_at, cliff_amount, "at cliff: {} != {}", claimable_at, cliff_amount);

// One second after cliff: at least cliff amount
ctx.warp_to_timestamp(cliff_ts + 1);
let claimable_after = get_claimable_amount(&ctx, schedule);
assert!(claimable_after >= cliff_amount, "after cliff: {} < {}", claimable_after, cliff_amount);
```

## Suggested Fix
```rust
pub fn cliff_unlock(now: u64, cliff_ts: u64, cliff_amount: u64) -> u64 {
    if now < cliff_ts {
        0
    } else {
        cliff_amount
    }
}

pub fn vesting_with_cliff(
    now: u64, start: u64, cliff_ts: u64, end: u64,
    cliff_amount: u64, total_grant: u64,
) -> Result<u64> {
    if now < cliff_ts {
        return Ok(0);
    }
    if now >= end {
        return Ok(total_grant);
    }
    let elapsed = now.checked_sub(cliff_ts).ok_or(VestingError::Underflow)?;
    let remaining_duration = end.checked_sub(cliff_ts).ok_or(VestingError::Underflow)?;
    let remaining_grant = total_grant.checked_sub(cliff_amount).ok_or(VestingError::Underflow)?;
    let linear_part = (remaining_grant as u128)
        .checked_mul(elapsed as u128)
        .ok_or(VestingError::Overflow)?
        / (remaining_duration as u128);
    Ok(cliff_amount + linear_part as u64)
}
```
