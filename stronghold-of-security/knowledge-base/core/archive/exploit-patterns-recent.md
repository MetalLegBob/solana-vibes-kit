# Solana Exploit Patterns — Recent (EP-119 to EP-128)
<!-- Part 4 of 4: Protocol-specific, infrastructure, and gap analysis patterns -->
<!-- See also: exploit-patterns-core.md, exploit-patterns-advanced.md, exploit-patterns-incidents.md -->
<!-- Full index: exploit-patterns-index.md -->
<!-- Last updated: 2026-02-06 -->

## Categories in This File
19. [Wave 8: Protocol-Specific Patterns](#wave-8-protocol-specific-patterns) (EP-119 to EP-122)
20. [Wave 9: Infrastructure & Verification Patterns](#wave-9-infrastructure--verification-patterns) (EP-123 to EP-125)
21. [Wave 10: Gap Analysis Patterns](#wave-10-gap-analysis-patterns) (EP-126 to EP-128)

---

## Wave 8: Protocol-Specific Patterns (EP-119 to EP-122)

### EP-119: Fee/Revenue Destination Account Hijacking
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Raydium CP-Swap creator fee hijacking (Dec 2025 — UncheckedAccount for fee recipient allowed stealing all creator fees from any pool)

**Description:** Fee collection instructions accept the fee destination account as an unchecked or loosely validated input. If the program doesn't verify that the fee recipient matches the pool creator or authorized fee collector, any caller can redirect fees to their own account.

**Vulnerable Pattern:**
```rust
#[account(mut)]
pub creator_fee_destination: UncheckedAccount<'info>, // Not validated!

pub fn collect_creator_fees(ctx: Context<CollectFees>) -> Result<()> {
    // Transfers accumulated creator fees to whatever account is passed
    transfer_tokens(
        &ctx.accounts.pool_fee_vault,
        &ctx.accounts.creator_fee_destination, // Attacker's account
        fee_amount,
    )?;
    Ok(())
}
```
**Secure Pattern:**
```rust
#[account(
    mut,
    constraint = creator_fee_destination.key() == pool.creator_fee_account @ ErrorCode::InvalidFeeAccount
)]
pub creator_fee_destination: AccountInfo<'info>,

// OR derive fee destination from pool creator PDA
#[account(
    mut,
    seeds = [b"creator_fee", pool.key().as_ref()],
    bump
)]
pub creator_fee_destination: Account<'info, TokenAccount>,
```
**Detection:** Search for `UncheckedAccount` in fee/revenue collection instructions. Verify fee destinations are constrained to pool creator or PDA-derived accounts. Check that fee rate parameters cannot be manipulated by non-creators.

---

### EP-120: Oracle Write-Lock Arbitrage Prevention (Solana-Specific)
**Category:** Oracle  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Solend USDH ($1.26M, Nov 2022 — attacker pumped USDH on Saber, write-locked Saber accounts to prevent arbitrage, Switchboard oracle captured inflated price)

**Description:** Solana's account model requires write-locks on accounts being modified. An attacker pumps a token's price on a thin-liquidity DEX, then spams transactions that write-lock the DEX pool accounts, preventing arbitrageurs from correcting the price in the same slot. The oracle samples the inflated price before arbitrage can occur.

**Attack Sequence:**
1. Pump target token price on thin DEX (e.g., spend 100K USDC)
2. Immediately spam transactions write-locking the DEX pool accounts (Saber's swap account)
3. Arbitrageurs cannot access locked accounts — price stays inflated
4. Oracle (Switchboard/Pyth) samples inflated price in next slot
5. Use inflated collateral to borrow on lending protocol

**Vulnerable Pattern:**
```rust
// Lending protocol using single DEX as oracle source
pub fn get_token_price(oracle_account: &AccountInfo) -> Result<u64> {
    let oracle_data = SwitchboardV2::load(oracle_account)?;
    // Switchboard pulls from single Saber pool
    // Attacker can manipulate Saber + prevent arbitrage
    Ok(oracle_data.latest_confirmed_round.result)
}
```
**Secure Pattern:**
```rust
pub fn get_token_price(
    primary_oracle: &AccountInfo,
    secondary_oracle: &AccountInfo,
) -> Result<u64> {
    let primary = load_oracle(primary_oracle)?;
    let secondary = load_oracle(secondary_oracle)?;

    // Dual-source validation
    require!(primary.is_fresh(MAX_STALENESS), ErrorCode::StaleOracle);
    require!(secondary.is_fresh(MAX_STALENESS), ErrorCode::StaleOracle);

    let deviation = price_deviation(primary.price, secondary.price);
    require!(deviation < MAX_DEVIATION_BPS, ErrorCode::OracleDeviation);

    // Cap stablecoins near peg
    let price = std::cmp::min(primary.price, MAX_STABLE_PRICE); // e.g., 1.01
    Ok(price)
}
```
**Detection:** Check if protocol uses single oracle source for any collateral. Check if oracle source is a thin-liquidity DEX pool. Verify dual-oracle or TWAP patterns. For stablecoins, check for price caps near peg. Look for `SwitchboardV2` or `Pyth` with single feed per asset.

---

### EP-121: Legacy Keyset / Guardian Set Expiration Bypass
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Wormhole Wormchain ($50K bounty, Jan 2024 — guardian sets with ExpirationTime=0 never expired, bypassing 13/19 quorum with single genesis key)

**Description:** Multi-signature or guardian systems that rotate keysets may leave legacy sets unexpired. If the verification logic only checks expiration when `expiration_time > 0`, sets with `expiration_time == 0` (default/genesis) are treated as valid forever, even after rotation.

**Vulnerable Pattern:**
```rust
pub fn verify_signatures(
    guardian_set: &GuardianSet,
    signatures: &[Signature],
) -> Result<()> {
    // Only check expiration if set has one
    if guardian_set.expiration_time > 0 {
        require!(
            Clock::get()?.unix_timestamp < guardian_set.expiration_time,
            ErrorCode::ExpiredGuardianSet
        );
    }
    // BUG: Genesis set (expiration_time = 0) NEVER expires
    // Genesis set may have weaker keys or single key
    verify_quorum(guardian_set, signatures)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn verify_signatures(
    guardian_set: &GuardianSet,
    current_set_index: u32,
    signatures: &[Signature],
) -> Result<()> {
    // SECURE: Only accept latest set, or recently-rotated sets within grace period
    if guardian_set.index < current_set_index {
        // Old set — must have valid expiration and not be expired
        require!(guardian_set.expiration_time > 0, ErrorCode::LegacySetNotAllowed);
        require!(
            Clock::get()?.unix_timestamp < guardian_set.expiration_time,
            ErrorCode::ExpiredGuardianSet
        );
    }
    verify_quorum(guardian_set, signatures)?;
    Ok(())
}
```
**Detection:** For multi-sig/guardian systems: check if legacy/genesis keysets can still be used. Verify expiration logic handles `expiration_time == 0` correctly (does it mean "never expires" or "no expiration set"?). Check that rotated-out sets are explicitly invalidated. Look for `if expiration > 0` conditional guards.

---

### EP-122: Programmable Asset Rule Bypass via Alternative Execution Path
**Category:** Logic / State Machine  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Metaplex pNFT Mad Shield audit (Dec 2023 — 3 Critical findings: delegate transfer path skipped metadata validation, AllowList bypass via mismatched owner/destination, burn instruction disabled all pNFT operations)

**Description:** Programmable NFTs (pNFTs) or other rule-enforced assets have multiple execution paths for operations like transfer or burn. If one path (e.g., delegate-initiated transfer) skips the validation that other paths enforce (e.g., metadata verification, Rule Set checking), all creator-defined rules can be bypassed.

**Sub-patterns:**
1. **Delegate path skip:** Transfer via token delegate bypasses metadata account validation, skipping Rule Set enforcement entirely
2. **AllowList destination mismatch:** AllowList validates the owner pubkey but doesn't verify the destination token account is actually owned by that pubkey — NFT transferred to non-approved program
3. **Token record destruction:** Burn instruction doesn't validate `token_record` when authority is token owner — burning token record permanently disables all pNFT operations for that asset

**Vulnerable Pattern:**
```rust
pub fn transfer_pnft(ctx: Context<TransferPNFT>) -> Result<()> {
    if ctx.accounts.authority.key() == ctx.accounts.token_owner.key() {
        // Owner path: validate metadata, check Rule Set
        validate_metadata(&ctx.accounts.metadata)?;
        check_rule_set(&ctx.accounts.rule_set, Operation::Transfer)?;
    } else {
        // Delegate path: MISSING metadata/rule validation
        // BUG: Delegate can transfer without any rule checks
    }
    execute_transfer(ctx)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn transfer_pnft(ctx: Context<TransferPNFT>) -> Result<()> {
    // ALWAYS validate metadata and rules regardless of authority type
    validate_metadata(&ctx.accounts.metadata)?;
    check_rule_set(&ctx.accounts.rule_set, Operation::Transfer)?;

    // Then check authority-specific permissions
    match get_authority_type(&ctx) {
        AuthorityType::Owner => { /* owner-specific logic */ },
        AuthorityType::Delegate => { /* delegate-specific logic */ },
    }
    execute_transfer(ctx)?;
    Ok(())
}
```
**Detection:** For any programmable/rule-enforced asset: (a) enumerate ALL execution paths for each operation (transfer, burn, delegate, etc.), (b) verify Rule Set/validation logic runs on ALL paths, not just the primary one, (c) check that destination account ownership matches the validated identity, (d) verify destructive operations (burn) cannot destroy control structures (token_record, metadata) independently.

---

## Wave 9: Infrastructure & Verification Patterns (EP-123 to EP-125)

### EP-123: Ed25519 Instruction Sysvar Offset Manipulation
**Category:** Cryptography / Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Relay Protocol ($5B+ volume cross-chain bridge, Sep 2025 — contracts trusted Ed25519 verification without validating offsets, allowing forged allocator signatures and potential double-spends. Disclosed by Asymmetric Research, patched, no funds lost.)

**Description:** On Solana, programs verify Ed25519 signatures by reading the Ed25519 precompile instruction data from the instructions sysvar (`sysvar::instructions`). The program checks that a valid Ed25519 signature verification instruction exists in the same transaction. However, if the program does not validate the **offset** into the instruction data, an attacker can include a valid Ed25519 signature for a *different* message and manipulate the offset to make the program read the wrong data. This lets the attacker forge signatures for arbitrary messages.

**Vulnerable Pattern:**
```rust
// Program reads Ed25519 instruction from sysvar
let ed25519_ix = load_instruction_at_checked(
    ed25519_ix_index as usize,
    &ctx.accounts.instructions_sysvar,
)?;

// Verifies the instruction is Ed25519 program
require!(ed25519_ix.program_id == ed25519_program::ID);

// BUG: Reads signature data at attacker-controlled offset
// without verifying the offset points to the expected message
let sig_data = &ed25519_ix.data[offset..];
let pubkey = &sig_data[0..32];
let message = &sig_data[32..64]; // Attacker controls which bytes are read
```
**Secure Pattern:**
```rust
// Fully parse the Ed25519 instruction data structure
let ed25519_ix = load_instruction_at_checked(
    ed25519_ix_index as usize,
    &ctx.accounts.instructions_sysvar,
)?;
require!(ed25519_ix.program_id == ed25519_program::ID);

// Parse the Ed25519SignatureOffsets struct at known position
let offsets = Ed25519SignatureOffsets::unpack(&ed25519_ix.data[2..])?;

// Verify ALL offsets point to expected data within the instruction
require!(offsets.signature_offset == EXPECTED_SIG_OFFSET);
require!(offsets.public_key_offset == EXPECTED_KEY_OFFSET);
require!(offsets.message_data_offset == EXPECTED_MSG_OFFSET);

// Verify the actual message content matches what we expect
let message = &ed25519_ix.data[offsets.message_data_offset as usize..];
require!(message == &expected_message);

// Verify the public key matches the expected signer
let pubkey = &ed25519_ix.data[offsets.public_key_offset as usize..];
require!(pubkey == expected_authority.as_ref());
```
**Detection:** Search for `load_instruction_at`, `ed25519_program`, `Ed25519SignatureOffsets` usage. Verify the program validates ALL offset fields, not just the program ID. Check that the message content and public key are verified against expected values. Flag any pattern where offsets from the Ed25519 instruction are used without full validation. This pattern also applies to Secp256k1 signature verification via the secp256k1 precompile.

---

### EP-124: Validator Client Crash Chain (Network-Level DoS)
**Category:** Resource / DoS  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Agave rBPF vulnerability (Aug 2024 — crafted input could crash validator leaders sequentially, halting the entire network. Patched by Anza, 67%+ network upgraded in 3 days), Agave v3.0.14 (Jan 2026 — two critical bugs patched, detailed by Anza post-mortem Jan 16 2026: (1) **Gossip defrag buffer cleanup** — bounds check error in defragmentation buffer cleanup logic caused validator panic/crash under specific conditions; (2) **Vote censoring attack** — `VoteStorage` did not verify the correct vote authority signature, allowing attacker to submit malicious incorrectly-signed vote transactions targeting future slots, blocking genuine valid votes for affected validators and potentially stalling consensus at scale. Only 18% upgraded promptly, Solana Foundation linked stake delegation to compliance.)

**Description:** Vulnerabilities in the validator client software (Agave, Firedancer, Jito) can be exploited to crash leader nodes or disrupt consensus. Because Solana rotates leaders on a schedule, crashing leaders sequentially can halt block production across the entire network. These bugs typically reside in program loading (rBPF/SBF), transaction processing, or consensus voting logic — not in user-deployed smart contracts.

**Why It Matters for Auditors:**
1. **Protocol dependency risk:** dApps relying on Solana's liveness (oracle freshness, time-sensitive liquidations) must account for potential network halts
2. **Validator software updates** may change program behavior — CPI depth limits, compute limits, account handling
3. **Agave 3.0 changes** directly affect smart contract security surface: CPI nesting depth increased from 4→8, single-account compute limit raised to 40% of block CUs
4. **Multi-client world:** Agave and Firedancer may handle edge cases differently (see EP-125)

**Audit Considerations:**
```
// Check protocol assumptions about network liveness:
// - Does the protocol have time-dependent logic that breaks during halts?
// - Are there liquidation windows that assume continuous block production?
// - Do oracles have staleness checks that account for network downtime?
// - Does the protocol handle slot gaps gracefully?

// Check for CPI depth assumptions:
// Agave 3.0 raised CPI nesting from 4 to 8
// Programs assuming max depth of 4 may have new attack surface
require!(cpi_depth <= MAX_EXPECTED_DEPTH); // May need updating
```
**Detection:** Review protocol's dependency on network liveness. Check for hardcoded slot/time assumptions. Verify oracle staleness bounds are sufficient for potential multi-hour halts. For CPI-heavy programs, reassess depth assumptions after Agave 3.0 upgrade.

---

### EP-125: Multi-Client Consensus Divergence
**Category:** Logic / State Machine  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** No public exploit yet, but Asymmetric Research has documented finding consensus-level bugs via differential fuzzing between Agave and Firedancer validator clients (May 2025). Minor behavioral differences between implementations can lead to network forks. The Agave v3.0.14 vote censoring bug (Jan 2026) demonstrated how implementation-level issues can cascade into consensus-level impact — `VoteStorage` accepted votes without verifying the vote authority signature, meaning a single implementation flaw could stall the entire network.

**Description:** With multiple validator client implementations (Agave by Anza, Firedancer by Jump Crypto), behavioral differences in edge-case handling can cause consensus divergence. If validators running different clients produce different results for the same transaction, the network risks splitting. These differences are particularly dangerous in: integer arithmetic edge cases, account state handling, BPF/SBF instruction execution, and transaction scheduling.

**Why It Matters for Auditors:**
1. **Smart contracts may behave differently** on Agave vs Firedancer for edge cases
2. **A vulnerability in one client but not the other** creates asymmetric attack vectors
3. **Differential fuzzing** (comparing Agave vs Firedancer behavior) is the key detection technique
4. **Programs that rely on precise runtime behavior** (exact compute units consumed, specific error codes, account data layout edge cases) are most at risk

**Detection Approach:**
```
// Patterns most likely to trigger divergence:
// 1. Integer arithmetic near boundaries (u64::MAX, u128 overflow)
// 2. Floating-point operations (if any)
// 3. Account realloc edge cases
// 4. CPI call depth boundaries (especially with 4→8 change)
// 5. Compute budget edge cases (exactly at limit)
// 6. Transaction size limits
// 7. Instruction data parsing (malformed inputs)

// Audit question: Does this program rely on behavior that
// might differ between validator implementations?
// Key areas: error handling, compute metering, account locking
```
**Detection:** Flag programs that depend on precise runtime behavior or error codes. Check for operations near arithmetic boundaries. Note programs using newer features (increased CPI depth, larger compute budgets) where implementation differences are more likely. The Asymmetric Research differential fuzzing methodology (LibAFL-based, comparing Agave vs Firedancer) is the gold standard for finding these issues.

---

## Wave 10: Gap Analysis Patterns (EP-126 to EP-128)

### EP-126: Multisig / ACL Role Escalation
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** CrediX ($4.5M, Aug 2025 — attacker added as Admin+Bridge to multisig via ACLManager 6 days before exploit, used Bridge role to mint collateral tokens and drain liquidity pool)

**Description:** Attacker gains elevated roles within a protocol's access control system (multisig, ACL manager, role-based permissions) through social engineering, compromised signer, or governance manipulation. Once added with a powerful role (Bridge, Pool Admin, Emergency Admin), the attacker uses those roles to mint fake collateral, drain pools, pause competitors, or bypass controls. Distinguished from EP-031 (duplicate signer bypass) in that the attacker is *legitimately added* as a new role holder, not exploiting a signature verification flaw.

**Attack Flow (CrediX):**
1. Attacker's account added as Admin + Bridge to CrediX Multisig via ACLManager (day 0)
2. Six days pass — no alarm raised (insufficient monitoring)
3. Attacker uses Bridge role to mint collateral tokens (fake credit)
4. Fake collateral used to borrow real assets from liquidity pool
5. $4.5M drained

**Vulnerable Pattern:**
```rust
pub fn add_role(ctx: Context<AddRole>, new_member: Pubkey, role: Role) -> Result<()> {
    // Only checks: is caller an admin?
    require!(ctx.accounts.admin.key() == config.admin, ErrorCode::Unauthorized);
    // BUG: No timelock, no multi-party approval, no role-specific restrictions
    // An admin (or compromised admin key) can instantly grant any role
    acl_manager.grant_role(new_member, role)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn propose_role(ctx: Context<ProposeRole>, new_member: Pubkey, role: Role) -> Result<()> {
    // Step 1: Propose (requires admin)
    let proposal = &mut ctx.accounts.role_proposal;
    proposal.new_member = new_member;
    proposal.role = role;
    proposal.proposed_at = Clock::get()?.unix_timestamp;
    proposal.approvals = 1; // Proposer counts as first approval
    Ok(())
}

pub fn execute_role(ctx: Context<ExecuteRole>) -> Result<()> {
    let proposal = &ctx.accounts.role_proposal;
    // Require timelock (e.g., 48 hours)
    let elapsed = Clock::get()?.unix_timestamp - proposal.proposed_at;
    require!(elapsed >= ROLE_TIMELOCK_SECONDS, ErrorCode::TimelockNotExpired);
    // Require multiple approvals
    require!(proposal.approvals >= MIN_ROLE_APPROVALS, ErrorCode::InsufficientApprovals);
    // Restrict high-privilege roles (Bridge, Emergency) to stricter thresholds
    if proposal.role == Role::Bridge || proposal.role == Role::EmergencyAdmin {
        require!(proposal.approvals >= ELEVATED_ROLE_APPROVALS, ErrorCode::InsufficientApprovals);
    }
    acl_manager.grant_role(proposal.new_member, proposal.role)?;
    Ok(())
}
```
**Detection:** Audit all role assignment / ACL management instructions. Check if adding new signers/roles requires: (a) timelock delay, (b) multi-party approval, (c) on-chain event emission for monitoring. Flag any instruction that can instantly grant Bridge, Emergency Admin, Pool Admin, or Mint Authority roles. Check if role grants are monitored by off-chain alerting. Verify that powerful roles (especially Bridge/minting roles) have operational limits even after being granted.

**Source:** Halborn CrediX analysis (Aug 2025), CryptoBriefing, CoinLaw

---

### EP-127: Perpetual DEX Attack Patterns
**Category:** Economic / DeFi  **Severity:** HIGH-CRITICAL  **Solana-Specific:** No (but Jupiter Perps, Drift Protocol are major Solana perp DEXes)
**Historical Exploits:** No major Solana perp exploit yet, but EVM perp exploits include Mango-style oracle manipulation applied to perp mark prices, and multiple position size / leverage gaming incidents on dYdX, GMX, Gains Network.

**Description:** Perpetual DEX protocols (Jupiter Perps, Drift, Zeta Markets, Flash Trade on Solana) introduce unique attack surfaces beyond standard AMM/swap protocols: mark price manipulation, funding rate gaming, liquidation cascade triggering, and position limit circumvention.

**Sub-Pattern PP-1: Mark Price Oracle Deviation Attack**
```rust
// Perp DEX uses mark price from oracle + internal TWAP
// If mark price deviates from index price, attacker profits
pub fn open_position(ctx: Context<OpenPosition>, size: u64, leverage: u8) -> Result<()> {
    let mark_price = ctx.accounts.pool.get_mark_price()?; // Internal TWAP
    let index_price = ctx.accounts.oracle.get_price()?;   // External oracle
    // BUG: No deviation check — attacker manipulates pool to skew mark price
    // Then takes leveraged position on the deviation
    let entry_price = mark_price;
    // ...
}
```

**Sub-Pattern PP-2: Funding Rate Manipulation**
```rust
// Funding rate = (mark_price - index_price) * funding_period
// Attacker skews open interest to one side → forces large funding payments
// On low-liquidity perps, a single large position can dominate OI
// Attack: Open huge long → collect funding from all shorts → close position
```

**Sub-Pattern PP-3: Liquidation Cascade Triggering**
```rust
// Attacker identifies cluster of positions near liquidation threshold
// Pushes price just past threshold (via oracle manipulation or large trade)
// Liquidations cascade: each liquidation pushes price further → more liquidations
// Attacker profits from: liquidation penalties, discounted position acquisition,
//   or short position during the cascade
```

**Sub-Pattern PP-4: Position Limit Circumvention**
```rust
// Protocol limits max position size per account
// Attacker uses multiple accounts (Sybil) to exceed aggregate limits
// Or splits across long/short to appear delta-neutral while gaming funding
pub fn check_position_limit(account: &Pubkey, size: u64) -> Result<()> {
    require!(size <= MAX_POSITION_SIZE, ErrorCode::PositionTooLarge);
    // BUG: Only checks per-account, not aggregate across related accounts
}
```

**Secure Patterns:**
- Enforce mark price deviation bands (halt trading if mark/index diverge beyond threshold)
- Cap funding rate per period to limit manipulation incentive
- Implement aggregate position limits with identity/collateral linking
- Use gradual liquidation (partial liquidation) to prevent cascades
- Monitor OI concentration — flag when single entity controls >X% of one side
- Implement price bands / circuit breakers for extreme moves
- Cross-reference oracle prices with multiple independent sources

**Detection:** For perp DEX audits: (a) verify mark price calculation cannot be manipulated by pool activity alone, (b) check funding rate caps exist, (c) verify liquidation logic uses gradual/partial liquidation, (d) check position limits are enforced globally not just per-account, (e) verify price impact calculations for large orders, (f) check that liquidation penalties don't create perverse incentives.

---

### EP-128: Third-Party Service Authority Hijack (Staking/Custody API)
**Category:** Key Management / Supply Chain  **Severity:** CRITICAL  **Solana-Specific:** Yes (Solana staking authority model)
**Historical Exploits:** SwissBorg/Kiln ($41.5M, Sep 2025 — compromised GitHub token of Kiln infra engineer → malicious payload injected into Kiln Connect API → 8 hidden `SetAuthority` instructions embedded in routine unstake transaction → 192,600 SOL stake authority transferred to attacker)

**Description:** Protocols that delegate custody or staking operations to third-party service providers (staking-as-a-service, custody APIs, yield aggregators) are vulnerable when the provider's infrastructure is compromised. The attacker injects malicious authority-transfer instructions into routine operations (stake, unstake, compound), silently redirecting control of assets. On Solana, the staking authority model (stake authority + withdraw authority) makes this particularly dangerous — a single `SetAuthority` instruction can irrevocably transfer control.

**Attack Flow (SwissBorg/Kiln):**
1. Attacker compromises Kiln infra engineer's GitHub access token (phishing/credential theft)
2. Injects malicious payload into Kiln Connect API codebase
3. Payload activates when client with >150,000 SOL sends routine unstake request
4. API response includes 8 hidden `SetAuthority` instructions alongside legitimate unstake
5. Client signs the composite transaction (trusts the API)
6. Stake account authorities transferred from client to attacker on-chain
7. Attacker unstakes and drains 192,600 SOL ($41.5M)

**Vulnerable Pattern:**
```rust
// Client blindly signs transaction constructed by third-party API
let tx = staking_api.build_unstake_transaction(stake_accounts)?;
// BUG: No verification of transaction contents before signing
// API could inject SetAuthority, transfer, or any other instruction
wallet.sign_and_send(tx)?;
```
**Secure Pattern:**
```rust
// Verify all instructions in API-constructed transactions before signing
let tx = staking_api.build_unstake_transaction(stake_accounts)?;

// Parse and validate every instruction
for ix in &tx.message.instructions {
    let program_id = tx.message.account_keys[ix.program_id_index as usize];
    match program_id {
        STAKE_PROGRAM_ID => {
            // Only allow Deactivate — reject SetAuthority, Authorize, etc.
            let stake_ix = StakeInstruction::deserialize(&ix.data)?;
            require!(matches!(stake_ix, StakeInstruction::Deactivate), "Unexpected stake instruction");
        }
        _ => return Err("Unexpected program in transaction"),
    }
}
wallet.sign_and_send(tx)?;
```
**Detection:** For protocols using third-party staking/custody APIs: (a) verify transaction contents are validated before signing, (b) check for allowlisted instruction types per operation, (c) verify authority changes require separate multi-party approval flow (not embedded in routine operations), (d) check for on-chain monitoring of `SetAuthority` events on managed accounts, (e) audit the third-party's security practices (code signing, access controls, deployment pipeline). Flag any pattern where externally-constructed transactions are signed without instruction-level verification.

**Source:** SwissBorg security update (Nov 2025), Halborn SwissBorg analysis (Sep 2025), CoinDesk, CoinTelegraph

---

<!-- END: exploit-patterns-recent.md | EP-119 to EP-128 | Waves 8-10 -->
