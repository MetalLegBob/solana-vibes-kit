# VP-052: Liquidation Threshold Accuracy

**Category:** Liquidation
**Verification tool:** Kani

## What Can Go Wrong
Health factor calculations involve dividing collateral value by debt value, both scaled by price oracles and decimal adjustments. Precision loss during intermediate steps can produce a health factor slightly above 1.0 when the position is actually undercollateralized, or slightly below 1.0 when it is still safe.

## Why It Matters
An attacker can keep an undercollateralized position alive by exploiting rounding that makes health factor appear safe. The protocol accumulates bad debt that depositors eventually absorb.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Multiple lending protocol audits have flagged precision-related health factor miscalculations as critical findings.

## Invariant

### Formal Property
```
forall collateral_value, debt_value, threshold_bps:
  health_factor = (collateral_value * threshold_bps) / (debt_value * 10000)
  |health_factor_computed - health_factor_exact| <= 1
```

### Kani Precondition/Postcondition
```rust
kani::assume!(collateral_value > 0 && collateral_value <= u64::MAX / 10000);
kani::assume!(debt_value > 0 && debt_value <= u64::MAX / 10000);
kani::assume!(threshold_bps > 0 && threshold_bps <= 10000);
let numerator: u128 = (collateral_value as u128) * (threshold_bps as u128);
let denominator: u128 = (debt_value as u128) * 10000u128;
let health_factor = numerator / denominator;
kani::assert!(numerator % denominator < denominator);
kani::assert!(health_factor == 0 || numerator >= denominator);
```

### Proptest Property
```rust
proptest! {{
    #[test]
    fn health_factor_precision(
        collateral_value in 1u64..=u64::MAX / 10000,
        debt_value in 1u64..=u64::MAX / 10000,
        threshold_bps in 1u16..=10000u16
    ) {{
        let hf_int = (collateral_value as u128 * threshold_bps as u128)
            / (debt_value as u128 * 10000u128);
        let hf_float = (collateral_value as f64 * threshold_bps as f64)
            / (debt_value as f64 * 10000.0);
        prop_assert!((hf_int as f64 - hf_float).abs() <= 1.0);
    }}
}}
```

### LiteSVM Assertion
```rust
let health_factor = compute_health_factor(&account_state);
let expected = (collateral_value as u128 * threshold_bps as u128)
    / (debt_value as u128 * 10000u128);
assert!(health_factor == expected || health_factor == expected + 1);
```

## Suggested Fix
```rust
pub fn compute_health_factor(collateral_value: u64, debt_value: u64, threshold_bps: u16) -> u64 {{
    if debt_value == 0 {{ return u64::MAX; }}
    let num = (collateral_value as u128).checked_mul(threshold_bps as u128).unwrap();
    let den = (debt_value as u128).checked_mul(10_000u128).unwrap();
    (num / den) as u64
}}
```
