# VP-051: Curve Parameter Update Safety

**Category:** Bonding Curves
**Verification tool:** LiteSVM

## What Can Go Wrong
If governance can update curve parameters (slope, base price, exponent) while the curve is active, the parameter change can create instant arbitrage. Tokens bought at old parameters may be worth more or less at new parameters, and the reserve may no longer match the new curve's integral.

## Why It Matters
A slope increase makes existing tokens worth more (the curve values them higher), potentially allowing holders to redeem for more than the reserve holds. A slope decrease makes tokens worth less, creating unfair losses for existing holders.

## Real-World Incident
No specific public incident documented, but parameter update safety is a critical concern flagged in bonding curve audits. Immutable parameters are the safest design â€” if updates are needed, migration to a new curve is preferred.

## Invariant

### Formal Property
```
If parameter update allowed:
  reserve_after_update >= integral(new_params, 0, current_supply)
  OR: parameter updates are disabled after initialization
  OR: parameter updates trigger automatic reserve rebalancing
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_parameter_update_safe() {
    let supply: u64 = kani::any();
    let old_slope: u64 = kani::any();
    let new_slope: u64 = kani::any();
    let reserve: u64 = kani::any();

    kani::assume!(supply > 0 && supply < 1_000_000);
    kani::assume!(old_slope > 0 && new_slope > 0);

    let old_integral = curve_integral_with_slope(0, supply, old_slope);
    let new_integral = curve_integral_with_slope(0, supply, new_slope);

    // If new curve requires more reserve than available, update must be rejected
    if new_integral > reserve as u128 {
        // Must reject
        kani::assert!(new_integral > reserve as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn parameter_update_validated(
        supply in 1_000u64..1_000_000,
        old_slope in 1u64..1_000,
        new_slope in 1u64..1_000,
        reserve in 1_000_000u64..1_000_000_000
    ) {
        let new_integral = curve_integral_with_slope(0, supply, new_slope);
        if new_integral > reserve as u128 {
            let result = update_curve_params(supply, reserve, new_slope);
            prop_assert!(result.is_err(), "accepted underfunded parameter update");
        }
    }
}
```

### LiteSVM Assertion
```rust
// Buy tokens at current params
buy_tokens(&mut ctx, &user, 100_000).await.unwrap();
let reserve_before = get_reserve(&ctx).await;
// Try to update slope that would make curve underfunded
let result = update_slope(&mut ctx, &admin, high_slope).await;
match result {
    Ok(_) => {
        let new_integral = compute_integral_at_supply(&ctx).await;
        assert!(get_reserve(&ctx).await as u128 >= new_integral, "underfunded after update");
    }
    Err(_) => {} // correctly rejected
}
```

## Suggested Fix
```rust
pub fn update_curve_params(ctx: Context<UpdateCurve>, new_slope: u64) -> Result<()> {
    let curve = &ctx.accounts.curve;
    let new_integral = curve_integral_with_slope(0, curve.supply, new_slope);
    require!(
        ctx.accounts.reserve.amount as u128 >= new_integral,
        CurveError::InsufficientReserveForUpdate
    );
    // Safe to update
    ctx.accounts.curve.slope = new_slope;
    Ok(())
}
```
