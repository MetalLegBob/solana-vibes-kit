# VP-016: Tiered Fee Boundary Discontinuity

**Category:** Fee Calculations
**Verification tool:** Proptest

## What Can Go Wrong
Protocols with tiered fees (e.g., 30bps for <$10K, 20bps for $10K-$100K) can have discontinuities at tier boundaries. A swap of $9,999 might pay a higher total fee than a swap of $10,001 if the transition isn't smooth. Worse, the fee function may not be monotonic — larger amounts could pay less.

## Why It Matters
Fee discontinuities create arbitrage: split one large swap into smaller ones to stay in a cheaper tier, or combine small swaps to jump to a cheaper tier. Either way, the protocol collects less fee revenue than intended.

## Real-World Incident
No specific public incident documented, but tiered fee discontinuity is a well-known issue in traditional finance order matching engines. Several DeFi protocols (notably Uniswap V3's fee tier system) addressed this by using discrete fee tiers per pool rather than dynamic tiering within a pool.

## Invariant

### Formal Property
```
∀ a, b where a < b:
  total_fee(a) <= total_fee(b) (fee is monotonically non-decreasing with amount)
  fee(boundary - 1) ≈ fee(boundary) (no jumps at tier boundaries)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_monotonic() {
    let amount_a: u64 = kani::any();
    let amount_b: u64 = kani::any();

    kani::assume!(amount_a > 0 && amount_a < u64::MAX / 2);
    kani::assume!(amount_b > amount_a && amount_b < u64::MAX / 2);

    let fee_a = tiered_fee(amount_a);
    let fee_b = tiered_fee(amount_b);

    kani::assert!(fee_b >= fee_a, "fee decreased with larger amount");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_monotonic_at_boundaries(
        base in 1_000_000u64..100_000_000
    ) {
        // Test around tier boundaries
        let boundaries = [10_000_000, 100_000_000, 1_000_000_000];
        for &b in &boundaries {
            if base < b && base > b.saturating_sub(1000) {
                let fee_below = tiered_fee(b - 1);
                let fee_at = tiered_fee(b);
                let fee_above = tiered_fee(b + 1);
                prop_assert!(fee_at >= fee_below, "fee jump down at boundary {}", b);
                prop_assert!(fee_above >= fee_at, "fee jump down above boundary {}", b);
            }
        }
    }
}
```

### LiteSVM Assertion
```rust
// Sweep amounts around tier boundary
for delta in [-10i64, -1, 0, 1, 10] {
    let amount = (TIER_BOUNDARY as i64 + delta) as u64;
    let fee = calculate_tiered_fee(&ctx, amount).await;
    // Fees should be smooth (no more than 1% jump at boundary)
}
```

## Suggested Fix
```rust
/// Use marginal tiering: each tier applies only to the portion within that range
pub fn tiered_fee(amount: u64) -> u64 {
    let mut remaining = amount as u128;
    let mut total_fee = 0u128;
    let tiers = [(10_000_000u128, 30u128), (100_000_000, 20), (u128::MAX, 10)];
    let mut prev_boundary = 0u128;
    for (boundary, bps) in tiers {
        let tier_amount = remaining.min(boundary - prev_boundary);
        total_fee += tier_amount * bps / 10_000;
        remaining -= tier_amount;
        prev_boundary = boundary;
        if remaining == 0 { break; }
    }
    total_fee as u64
}
```
