# LiteSVM Test Template

Use this template to generate LiteSVM runtime tests for economic invariants that require the actual Solana VM.

## When to Use LiteSVM

LiteSVM tests are for properties that depend on runtime context:
- Account balance conservation across instructions
- Multi-account economic invariants (LP share fairness, collateral ratios)
- CPI interactions between programs
- Properties that depend on actual account serialization/deserialization

For pure arithmetic properties, use Kani instead (faster, stronger guarantees).

## Template Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `{FUNCTION_NAME}` | Function being tested | `process_swap` |
| `{PROGRAM_ID}` | Program's public key | `Pubkey::new_unique()` |
| `{ACCOUNTS}` | Account setup code | See patterns below |
| `{INSTRUCTION_DATA}` | Serialized instruction data | `SwapInstruction { amount: 1000 }.try_to_vec().unwrap()` |
| `{INVARIANT_ASSERTION}` | The economic property to check | See patterns below |

## Base Template

```rust
// BOK LiteSVM Test — {FUNCTION_NAME}
// Property: {PROPERTY_NAME}
// Generated by Book of Knowledge

use litesvm::LiteSVM;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    transaction::Transaction,
};

#[test]
fn test_{PROPERTY_NAME}() {
    // --- Setup ---
    let mut svm = LiteSVM::new();
    let program_id = {PROGRAM_ID};

    // Deploy program
    let program_bytes = std::fs::read("target/deploy/{program_name}.so")
        .expect("Program binary not found — run `anchor build` first");
    svm.add_program(program_id, &program_bytes);

    // Create accounts
    {ACCOUNT_SETUP}

    // --- Capture pre-state ---
    {PRE_STATE_CAPTURE}

    // --- Execute ---
    let ix = Instruction::new_with_bytes(
        program_id,
        &{INSTRUCTION_DATA},
        vec![{ACCOUNT_METAS}],
    );

    let payer = Keypair::new();
    svm.airdrop(&payer.pubkey(), 10_000_000_000).unwrap();
    let tx = Transaction::new_signed_with_payer(
        &[ix],
        Some(&payer.pubkey()),
        &[&payer],
        svm.latest_blockhash(),
    );

    let result = svm.send_transaction(tx);

    // --- Assert invariant ---
    {INVARIANT_ASSERTION}
}
```

## Common Patterns

### Conservation of Value

```rust
// Capture balances before
let pool_balance_before = svm.get_balance(&pool_account).unwrap();
let user_balance_before = svm.get_balance(&user_account).unwrap();
let total_before = pool_balance_before + user_balance_before;

// ... execute instruction ...

// Verify total value is conserved
let pool_balance_after = svm.get_balance(&pool_account).unwrap();
let user_balance_after = svm.get_balance(&user_account).unwrap();
let total_after = pool_balance_after + user_balance_after;

assert_eq!(total_before, total_after,
    "Conservation violated: before={} after={} diff={}",
    total_before, total_after,
    (total_before as i128) - (total_after as i128));
```

### LP Share Fairness

```rust
// Equal deposits should give equal shares
let deposit_amount = 1_000_000;

// User A deposits
// ... execute deposit for user A ...
let shares_a = get_user_shares(&svm, &user_a_account);

// User B deposits same amount
// ... execute deposit for user B ...
let shares_b = get_user_shares(&svm, &user_b_account);

// Shares should be equal (within rounding tolerance of 1)
let diff = if shares_a > shares_b { shares_a - shares_b } else { shares_b - shares_a };
assert!(diff <= 1,
    "Share fairness violated: A={} B={} for equal deposits of {}",
    shares_a, shares_b, deposit_amount);
```

### Fee Bounds

```rust
// Fee should be within expected bounds
let amount = 1_000_000;
let expected_fee_bps = 30; // 0.3%

// ... execute swap ...

let fee_charged = amount_in - amount_out;
let expected_fee = amount * expected_fee_bps / 10_000;

// Fee should be within 1 unit of expected (rounding tolerance)
let diff = if fee_charged > expected_fee {
    fee_charged - expected_fee
} else {
    expected_fee - fee_charged
};
assert!(diff <= 1,
    "Fee out of bounds: charged={} expected={}", fee_charged, expected_fee);
```

## LiteSVM Tips

- LiteSVM runs a real SVM — tests are realistic but slower than Proptest
- Program must be compiled first (`anchor build`)
- Use `svm.airdrop()` to fund test accounts
- Account data is real serialized Anchor/SPL data
- For Token program interactions, deploy `spl_token` and create real token accounts
- Test both success AND failure cases (e.g., verify that an invalid swap is rejected)
