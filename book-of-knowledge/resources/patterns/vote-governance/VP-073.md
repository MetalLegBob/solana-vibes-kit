# VP-073: Vote Weight Overflow Prevention

**Category:** Vote/Governance
**Verification tool:** Kani

## What Can Go Wrong
When tallying votes across many voters, the running sum of all vote weights can overflow u64. With large token supplies (10^18+) and many participants, the aggregate may exceed u64::MAX (~1.8 * 10^19). Unchecked overflow wraps the tally to a small number, potentially flipping the vote outcome. Weighted voting schemes that multiply balances by boost factors make this worse.

## Why It Matters
An attacker orchestrates votes designed to push the tally just past u64::MAX, wrapping the total to a small value. A malicious proposal that would have been rejected with 60% opposition now appears to have near-zero opposition. The attacker's proposal passes, enabling treasury drain or protocol takeover.

## Real-World Incident
No single named exploit, but vote tallying overflow has been flagged in governance audits. The BEC Token overflow (2018) remains the most famous example of unchecked arithmetic destroying token accounting, and the same class applies to vote tallies.

## Invariant

### Formal Property
```
For votes[] array of individual voter weights:
  if sum_u128(votes) > u64::MAX: return error
  else: tally == sum_u128(votes) as u64
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_tally_overflow_detection() {
    let a: u64 = kani::any();
    let b: u64 = kani::any();
    let c: u64 = kani::any();
    kani::assume!(a > 0 && b > 0 && c > 0);

    let sum_128 = (a as u128) + (b as u128) + (c as u128);
    if sum_128 <= u64::MAX as u128 {
        let tally = sum_128 as u64;
        kani::assert!(tally as u128 == sum_128);
    } else {
        let partial = a.checked_add(b);
        if let Some(ab) = partial {
            kani::assert!(ab.checked_add(c).is_none());
        }
        kani::assert!(sum_128 > u64::MAX as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn tally_detects_overflow(
        votes in proptest::collection::vec(1u64..10_000_000_000_000_000_000, 1..50)
    ) {
        let sum_128: u128 = votes.iter().map(|v| *v as u128).sum();
        let mut tally: u64 = 0;
        let mut overflowed = false;
        for &v in &votes {
            match tally.checked_add(v) {
                Some(t) => tally = t,
                None => { overflowed = true; break; }
            }
        }
        if sum_128 > u64::MAX as u128 {
            prop_assert!(overflowed, "overflow not detected");
        } else {
            prop_assert_eq!(tally as u128, sum_128);
        }
    }
}
```

### LiteSVM Assertion
```rust
let large_weight = u64::MAX / 2 + 1;
process_transaction(&mut banks_client, cast_vote_ix(voter_a, large_weight), &payer).await.unwrap();
let result = process_transaction(&mut banks_client, cast_vote_ix(voter_b, large_weight), &payer).await;
assert!(result.is_err(), "tally overflow was not caught");
let proposal = get_proposal_state(&banks_client, proposal_key).await;
assert_eq!(proposal.votes_for, large_weight, "tally was corrupted");
```

## Suggested Fix
```rust
pub fn tally_votes(proposal: &mut Proposal, new_weight: u64) -> Result<()> {
    proposal.votes_for = proposal.votes_for
        .checked_add(new_weight).ok_or(GovernanceError::TallyOverflow)?;
    Ok(())
}
```
