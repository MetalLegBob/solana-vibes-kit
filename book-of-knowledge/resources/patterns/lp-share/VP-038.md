# VP-038: Share Burn Proportionality on Withdrawal

**Category:** LP Share
**Verification tool:** Kani

## What Can Go Wrong
When withdrawing, the user burns shares to receive a proportional amount of pool tokens. If the calculation uses stale total_value or doesn't account for pending fees/rewards, the user receives more or less than their fair share.

## Why It Matters
A user who can withdraw more than their share is effectively stealing from remaining LPs. Over time, the last LP holding shares finds the pool has less value than expected.

## Real-World Incident
Withdrawal proportionality bugs have been found in multiple Solana AMM audits. Orca's Whirlpool implementation specifically updates fee accumulators before withdrawal calculations.

## Invariant

### Formal Property
```
withdraw_amount = shares_burned * pool_total_value / total_shares
withdraw_amount / pool_total_value â‰ˆ shares_burned / total_shares
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_withdrawal_proportional() {
    let total_value: u64 = kani::any();
    let total_shares: u64 = kani::any();
    let burn_shares: u64 = kani::any();

    kani::assume!(total_value > 1_000_000);
    kani::assume!(total_shares > 1_000);
    kani::assume!(burn_shares > 0 && burn_shares <= total_shares);

    let withdraw = (burn_shares as u128) * (total_value as u128) / (total_shares as u128);

    // Must not exceed proportional share (floor division ensures this)
    kani::assert!(withdraw <= total_value as u128);
    kani::assert!(withdraw * (total_shares as u128) <= (burn_shares as u128) * (total_value as u128) + (total_shares as u128));
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn withdrawal_proportional(
        total_value in 1_000_000u64..1_000_000_000,
        total_shares in 1_000u64..1_000_000_000,
        burn_pct in 1u64..100 // percent of shares to burn
    ) {
        let burn = total_shares * burn_pct / 100;
        prop_assume!(burn > 0);
        let withdraw = (burn as u128) * (total_value as u128) / (total_shares as u128);
        let share_ratio = burn as f64 / total_shares as f64;
        let value_ratio = withdraw as f64 / total_value as f64;
        prop_assert!((share_ratio - value_ratio).abs() < 0.001);
    }
}
```

### LiteSVM Assertion
```rust
let total = get_pool_value(&ctx).await;
let shares = get_total_shares(&ctx).await;
let user_shares = get_user_shares(&ctx, &user).await;
withdraw(&mut ctx, &user, user_shares).await.unwrap();
let received = get_user_token_balance(&ctx, &user).await;
let expected = user_shares as u128 * total as u128 / shares as u128;
assert!((received as i128 - expected as i128).unsigned_abs() <= 1);
```

## Suggested Fix
```rust
pub fn withdraw(ctx: Context<Withdraw>, shares_to_burn: u64) -> Result<u64> {
    let pool = &ctx.accounts.pool;
    // Use floor division (protocol keeps dust)
    let amount = (shares_to_burn as u128)
        .checked_mul(pool.total_value() as u128)?
        / (pool.total_shares as u128);
    require!(amount > 0, PoolError::WithdrawTooSmall);
    Ok(amount as u64)
}
```
