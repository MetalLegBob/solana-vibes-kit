# VP-035: Proportional Share Calculation on Deposit

**Category:** LP Share
**Verification tool:** Kani

## What Can Go Wrong
When a user deposits into a liquidity pool, they receive LP shares proportional to their deposit relative to the pool's total value. If the share calculation uses incorrect total value (e.g., only one token's reserve instead of both), the shares are mispriced.

## Why It Matters
Mispriced shares mean either the depositor gets too many shares (diluting existing LPs) or too few (unfair to the depositor). Either way, one party can arbitrage the mispricing.

## Real-World Incident
Multiple AMM exploits have involved share calculation errors. The "inflation attack" on ERC-4626 vaults exploits the first depositor's ability to manipulate the share price.

## Invariant

### Formal Property
```
shares_minted = deposit_amount * total_shares / total_pool_value
After deposit: user_share_percentage â‰ˆ deposit_amount / (total_pool_value + deposit_amount)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_proportional_shares() {
    let total_value: u64 = kani::any();
    let total_shares: u64 = kani::any();
    let deposit: u64 = kani::any();

    kani::assume!(total_value > 1_000_000 && total_value < u64::MAX / 2);
    kani::assume!(total_shares > 0 && total_shares < u64::MAX / 2);
    kani::assume!(deposit > 0 && deposit < total_value);

    let new_shares = (deposit as u128) * (total_shares as u128) / (total_value as u128);

    // New shares must be proportional
    kani::assert!(new_shares > 0, "zero shares for nonzero deposit");
    kani::assert!(new_shares < total_shares as u128, "new shares exceed existing");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn shares_proportional_to_deposit(
        total_value in 1_000_000u64..1_000_000_000,
        total_shares in 1_000u64..1_000_000_000,
        deposit in 1_000u64..100_000_000
    ) {
        prop_assume!(deposit < total_value);
        let new_shares = (deposit as u128) * (total_shares as u128) / (total_value as u128);
        let share_pct = new_shares as f64 / (total_shares as f64 + new_shares as f64);
        let value_pct = deposit as f64 / (total_value as f64 + deposit as f64);
        prop_assert!((share_pct - value_pct).abs() < 0.001);
    }
}
```

### LiteSVM Assertion
```rust
let total_before = get_pool_value(&ctx).await;
let shares_before = get_total_shares(&ctx).await;
deposit(&mut ctx, &user, amount).await.unwrap();
let user_shares = get_user_shares(&ctx, &user).await;
let expected = amount as u128 * shares_before as u128 / total_before as u128;
assert!((user_shares as i128 - expected as i128).unsigned_abs() <= 1);
```

## Suggested Fix
```rust
pub fn mint_shares(pool: &Pool, deposit_value: u64) -> Result<u64> {
    if pool.total_shares == 0 {
        return Ok(deposit_value); // First deposit: 1:1
    }
    let shares = (deposit_value as u128)
        .checked_mul(pool.total_shares as u128)?
        / (pool.total_value() as u128);
    require!(shares > 0, PoolError::DepositTooSmall);
    Ok(shares as u64)
}
```
