# Solana Exploit Patterns — Core (EP-001 to EP-067)
<!-- Part 1 of 4: Foundational patterns that apply to every Solana program -->
<!-- See also: exploit-patterns-advanced.md, exploit-patterns-incidents.md, exploit-patterns-recent.md -->
<!-- Full index: exploit-patterns-index.md -->
<!-- Last updated: 2026-02-06 -->

## Categories in This File
1. [Account Validation](#account-validation) (EP-001 to EP-014)
2. [Arithmetic](#arithmetic) (EP-015 to EP-020)
3. [Oracle](#oracle) (EP-021 to EP-025)
4. [Access Control](#access-control) (EP-026 to EP-032)
5. [Logic / State Machine](#logic--state-machine) (EP-033 to EP-041)
6. [CPI](#cpi) (EP-042 to EP-050)
7. [Token / SPL](#token--spl) (EP-051 to EP-057)
8. [Economic / DeFi](#economic--defi) (EP-058 to EP-067)

---

## Account Validation

### EP-001: Missing Signer Check
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Wormhole ($320M, Feb 2022)

**Description:** Authority account not verified as transaction signer, allowing unauthorized callers.

**Vulnerable Pattern:**
```rust
pub authority: AccountInfo<'info>, // No Signer constraint!
```
**Secure Pattern:**
```rust
pub authority: Signer<'info>, // Anchor enforces is_signer
```
**Detection:** Grep for `AccountInfo` on authority/admin accounts. Verify `Signer<'info>` usage.

---

### EP-002: Missing Owner Check
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Multiple DeFi exploits via fake account injection

**Description:** Account data read without verifying program ownership, allowing attacker-controlled data.

**Vulnerable Pattern:**
```rust
pub user_data: AccountInfo<'info>, // Owner not checked
```
**Secure Pattern:**
```rust
pub user_data: Account<'info, UserData>, // Anchor checks owner == program_id
```
**Detection:** Search for raw `AccountInfo` deserialized without `owner` checks.

---

### EP-003: Account Type Cosplay / Discriminator Bypass
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Saber (Aug 2022) via duplicate account type confusion

**Description:** Wrong account type passed with correct owner. Fields reinterpreted without discriminator validation.

**Vulnerable Pattern:**
```rust
let data: Config = Config::try_from_slice(&account_data[8..])?; // No discriminator check
```
**Secure Pattern:**
```rust
pub config: Account<'info, Config>, // Anchor validates 8-byte discriminator
```
**Detection:** Find manual `try_from_slice`. Verify `Account<'info, T>` over `AccountInfo`.

---

### EP-004: PDA Seed Collision
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Protocol treasury impersonation via username manipulation

**Description:** Insufficient PDA seeds allow different inputs to produce same address.

**Vulnerable Pattern:**
```rust
seeds = [b"vault"], bump // No user-specific seed
```
**Secure Pattern:**
```rust
seeds = [b"vault", user.key().as_ref()], bump // User-specific
```
**Detection:** Review all PDA seeds for uniqueness. Include user pubkey, mint, or counter.

---

### EP-005: Bump Seed Canonicalization
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Non-canonical bumps causing duplicate vault instances

**Description:** Non-canonical bump seed accepted, allowing multiple PDAs for same logical seeds.

**Vulnerable Pattern:**
```rust
Pubkey::create_program_address(&[b"vault", &[user_bump]])?; // User-provided bump
```
**Secure Pattern:**
```rust
#[account(seeds = [b"vault", user.key().as_ref()], bump)] // Canonical bump enforced
```
**Detection:** Find `create_program_address`. Should use `find_program_address` or Anchor `bump`.

---

### EP-006: Unchecked Sysvar Account
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Cashio ($52M, Mar 2022) - fake sysvar injection

**Description:** Sysvar account (Clock, Rent) accepted without address validation. Attacker passes fake with manipulated data.

**Vulnerable Pattern:**
```rust
pub clock: AccountInfo<'info>, // Could be fake!
```
**Secure Pattern:**
```rust
pub clock: Sysvar<'info, Clock>, // Address validated
// Or: let clock = Clock::get()?; // No account needed
```
**Detection:** Find `AccountInfo` for sysvars. Use `Sysvar<'info, T>` or `Clock::get()`.

---

### EP-007: Account Relationship Not Verified
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Tulip Protocol vault drain (disclosed)

**Description:** Account accepted without verifying it belongs to the expected parent (e.g., vault_token not linked to vault).

**Vulnerable Pattern:**
```rust
pub vault_token: Account<'info, TokenAccount>, // Not linked to vault!
```
**Secure Pattern:**
```rust
#[account(constraint = vault_token.owner == vault.key())]
pub vault_token: Account<'info, TokenAccount>,
```
**Detection:** Map account relationships. Verify constraints enforce cross-account links.

---

### EP-008: Cross-Account Data Mismatch
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Staking protocols with mismatched mint/pool configs

**Description:** Individual accounts pass validation but are not related to each other.

**Vulnerable Pattern:**
```rust
#[account(constraint = stake_token.mint == ACCEPTED_MINT)] // Hardcoded, not pool-relative
```
**Secure Pattern:**
```rust
#[account(constraint = stake_token.mint == stake_pool.stake_mint)] // Cross-validated
```
**Detection:** Verify cross-account constraints. Test with valid-but-mismatched accounts.

---

### EP-009: Duplicate Mutable Accounts
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Saber stableswap (Aug 2022) - infinite minting

**Description:** Same account passed as two parameters. Transfer operations become no-ops or double-spend.

**Vulnerable Pattern:**
```rust
pub source: Account<'info, UserAccount>,
pub dest: Account<'info, UserAccount>, // Could be same as source!
```
**Secure Pattern:**
```rust
#[account(mut, constraint = source.key() != dest.key())]
pub source: Account<'info, UserAccount>,
```
**Detection:** Find multiple mutable accounts of same type. Verify inequality constraints.

---

### EP-010: Unchecked Token Mint
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Fake token deposits across multiple protocols

**Description:** Token account accepted without mint verification. Worthless token credited as valuable.

**Vulnerable Pattern:**
```rust
pub user_token: Account<'info, TokenAccount>, // Which mint?
```
**Secure Pattern:**
```rust
#[account(constraint = user_token.mint == vault.accepted_mint)]
pub user_token: Account<'info, TokenAccount>,
```
**Detection:** Check all token accounts for mint constraints.

---

### EP-011: Rent Siphoning
**Category:** Account Validation  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Accounts purged from insufficient rent in early Solana programs

**Description:** Lamport withdrawal below rent-exempt threshold causes garbage collection and data loss.

**Vulnerable Pattern:**
```rust
**vault.lamports.borrow_mut() -= amount; // No rent check!
```
**Secure Pattern:**
```rust
let required = Rent::get()?.minimum_balance(vault.data_len());
require!(vault.lamports() - amount >= required);
```
**Detection:** Find lamport withdrawals. Verify rent-exemption maintained.

---

### EP-012: Account Realloc Without Safeguards
**Category:** Account Validation  **Severity:** MEDIUM-HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Token program exposing private keys in extended data; OtterSec SDK disclosure (Dec 2022 — OOB write via realloc)

**Description:** Reallocation without zeroing new space (data leak) or checking rent sufficiency. In the worst case, `realloc()` with an excessively large size can write out-of-bounds past the account's allocated buffer into adjacent accounts' data/lamports in the serialized buffer (see EP-107 for the full memory corruption variant).

**Sub-patterns:**
1. **Data leak:** `zero_init=false` leaks previous data in expanded space
2. **Rent shortfall:** Realloc increases size but no lamport top-up for rent-exemption
3. **OOB write (EP-107):** Unbounded size allows writing past buffer boundary into adjacent accounts

**Vulnerable Pattern:**
```rust
vault.to_account_info().realloc(new_size, false)?; // zero=false, no bounds!
```
**Secure Pattern:**
```rust
require!(new_size <= MAX_SIZE);
require!(new_size <= original_data_len + 10_240); // Max 10KB per ix
vault.to_account_info().realloc(new_size, true)?; // zero=true
// Top up rent after realloc
let rent = Rent::get()?;
let min_balance = rent.minimum_balance(new_size);
// ... transfer additional lamports if needed
```
**Detection:** Find `realloc()`. Verify zero flag true, size bounded, rent sufficient. Check if new size is user-controlled. See EP-107 for the memory corruption variant.

---

### EP-013: Mint Authority Not Verified
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** MonkeyBall ($250K, Feb 2022) - compromised mint authority

**Description:** Mint accepted without checking if mint authority is revoked/trusted. Attacker mints unlimited supply.

**Vulnerable Pattern:**
```rust
pub token_mint: Account<'info, Mint>, // Any mint accepted!
```
**Secure Pattern:**
```rust
#[account(constraint = token_mint.mint_authority == COption::None)]
pub token_mint: Account<'info, Mint>,
```
**Detection:** Find mint usage. Verify `mint_authority` constraints.

---

### EP-014: ALT Account Substitution
**Category:** Account Validation  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Batch processing with ALT-sourced malicious accounts

**Description:** Address Lookup Table accounts in `remaining_accounts` not validated with same rigor as direct accounts.

**Vulnerable Pattern:**
```rust
for account in ctx.remaining_accounts { // Unvalidated!
    let vault: Account<Vault> = Account::try_from(account)?;
}
```
**Secure Pattern:**
```rust
for (account, expected) in remaining_accounts.iter().zip(expected_keys.iter()) {
    require_keys_eq!(account.key(), *expected);
    require!(account.owner == &crate::ID);
}
```
**Detection:** Find `remaining_accounts`. Verify key, owner, type validation.

---

## Arithmetic

### EP-015: Integer Overflow/Underflow
**Category:** Arithmetic  **Severity:** CRITICAL  **Solana-Specific:** Yes (release wraps silently)
**Historical Exploits:** Cetus DEX ($223M, May 2025 on SUI — checked_shlw overflow; pattern applicable to Solana), multiple token programs

**Description:** Rust release builds wrap on overflow. Unchecked arithmetic produces wrong results.

**Vulnerable Pattern:**
```rust
vault.balance = vault.balance + amount; // Wraps to 0!
vault.balance = vault.balance - amount; // Wraps to u64::MAX!
```
**Secure Pattern:**
```rust
vault.balance = vault.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;
vault.balance = vault.balance.checked_sub(amount).ok_or(ErrorCode::Underflow)?;
```
**Detection:** Search for `+`, `-`, `*`, `/` on financial values. Verify `checked_*` methods.

---

### EP-016: Precision Loss in Division
**Category:** Arithmetic  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Port Finance ($200K, Nov 2021), Aldrin ($90K, Oct 2021)

**Description:** Integer division truncates. Small amounts round to zero, extractable through repeated operations.

**Vulnerable Pattern:**
```rust
let fee = (amount * fee_bps) / 10000; // 0 if product < 10000
```
**Secure Pattern:**
```rust
let fee = (amount as u128).checked_mul(fee_bps as u128)? / 10000;
require!(fee > 0 || amount == 0, ErrorCode::FeeTooSmall);
```
**Detection:** Review all division. Verify multiply-before-divide. Check minimums.

---

### EP-017: Decimal Normalization Errors
**Category:** Arithmetic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Saber ($4.6M, Jul 2022) - stableswap decimal mismatch

**Description:** Tokens with different decimals miscalculated when normalization uses lossy integer division.

**Vulnerable Pattern:**
```rust
let normalized = amount / 10u64.pow(decimals as u32); // Loses precision!
```
**Secure Pattern:**
```rust
let normalized = (amount as u128) * 10u128.pow((18 - decimals) as u32); // Scale UP
```
**Detection:** Check decimal handling in multi-token math. Test with 6, 9, 18 decimals.

---

### EP-018: Float Arithmetic in Financial Logic
**Category:** Arithmetic  **Severity:** HIGH  **Solana-Specific:** Yes (non-deterministic)
**Historical Exploits:** DeFi rounding errors via repeated small operations

**Description:** f32/f64 causes precision loss and non-deterministic results across validators.

**Vulnerable Pattern:**
```rust
let interest = principal as f64 * 0.05; // Float!
```
**Secure Pattern:**
```rust
let interest = principal.checked_mul(500)?.checked_div(10_000)?; // Basis points
```
**Detection:** Search for `f32`, `f64` in financial logic.

---

### EP-019: Rounding Direction Favoring User
**Category:** Arithmetic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Mercurial Finance virtual price manipulation (disclosed)

**Description:** Protocol rounds in user's favor (up on withdraw, down on deposit). Repeated operations extract value.

**Vulnerable Pattern:**
```rust
let lp = (d_new - d_old) * supply / d_old; // Rounds in user favor
```
**Secure Pattern:**
```rust
let lp = (d_new - d_old) * supply / d_old; // Round DOWN for deposits
require!(lp > 0, ErrorCode::TooSmall); // Prevent dust extraction
```
**Detection:** Review rounding in deposit/withdraw/swap. Verify protocol-favorable direction.

---

### EP-020: Unsafe Type Casting
**Category:** Arithmetic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Apricot Finance ($1.2M, Jul 2021) - wrong decimal casting

**Description:** Casting between int types (u128->u64, i64->u64) silently truncates or reinterprets.

**Vulnerable Pattern:**
```rust
let price = oracle_value as u64; // Negative i64 becomes huge u64!
```
**Secure Pattern:**
```rust
let price = u64::try_from(oracle_value).map_err(|_| ErrorCode::InvalidCast)?;
```
**Detection:** Search for `as u64`, `as u32` casts. Verify `try_from` usage.

---

## Oracle

### EP-021: Missing Oracle Confidence Check
**Category:** Oracle  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Mango Markets ($114M, Oct 2022), FTX collapse exploits (Nov 2022)

**Description:** Oracle price used without confidence interval check. Wide confidence = unreliable price.

**Vulnerable Pattern:**
```rust
let price = pyth_feed.get_current_price()?.price; // No confidence check!
```
**Secure Pattern:**
```rust
let conf_pct = (price.conf as u128 * 10000) / price.price as u128;
require!(conf_pct < 100, ErrorCode::ConfidenceTooWide); // < 1%
```
**Detection:** Grep for oracle price usage. Verify confidence interval validation.

---

### EP-022: Stale Oracle Price
**Category:** Oracle  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Jet Protocol (~$100K, Dec 2021), Synthetify ($120K, Jul 2021)

**Description:** Oracle not refreshed within acceptable window. Stale/zero prices used for operations.

**Vulnerable Pattern:**
```rust
let price = oracle.get_price()?; // No staleness check!
```
**Secure Pattern:**
```rust
require!(clock.unix_timestamp - oracle.timestamp < MAX_AGE);
require!(oracle.price > 0, ErrorCode::InvalidPrice);
```
**Detection:** Find oracle usage. Verify timestamp checks and zero-price guards.

---

### EP-023: Single Oracle Dependency
**Category:** Oracle  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Mango Markets - manipulated Pyth TWAP via thin orderbooks

**Description:** Single oracle source with no fallback. If manipulated or down, protocol is vulnerable.

**Vulnerable Pattern:**
```rust
let price = pyth_oracle.get_price()?; // Single source!
```
**Secure Pattern:**
```rust
let p1 = pyth_oracle.get_twap()?;
let p2 = amm_oracle.get_twap(SLOTS_PER_HOUR)?;
require!(abs_diff(p1, p2) * 100 / p2 < 5, ErrorCode::OracleDivergence);
let price = std::cmp::min(p1, p2); // Conservative
```
**Detection:** Count oracle sources per price. Verify fallback/cross-validation.

---

### EP-024: AMM Spot Price as Oracle
**Category:** Oracle  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Nirvana ($3.5M, Jul 2022), multiple flash loan attacks

**Description:** AMM reserve ratio used as price oracle. Trivially manipulable via flash loans.

**Vulnerable Pattern:**
```rust
let price = pool.reserve_b * PRECISION / pool.reserve_a; // Manipulable!
```
**Secure Pattern:**
```rust
let price = oracle.get_twap(TWAP_WINDOW)?; // External oracle TWAP
```
**Detection:** Find price from pool reserves. Flag `reserve_a / reserve_b` patterns.

---

### EP-025: No Liquidity Adjustment on Collateral
**Category:** Oracle  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Mango Markets - over-valued MNGO on thin liquidity

**Description:** Large collateral position valued at oracle price without market depth haircut.

**Vulnerable Pattern:**
```rust
let value = user.balance * oracle_price; // No haircut for illiquidity!
```
**Secure Pattern:**
```rust
let ratio = user.balance * 10000 / market.liquidity;
let haircut = if ratio > 5000 { 5000 } else if ratio > 2000 { 7500 } else { 10000 };
let value = user.balance * oracle_price * haircut / 10000;
```
**Detection:** Check if large positions are haircut. Verify per-asset borrow caps.

---

## Access Control

### EP-026: Missing Authority Constraint
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Common in nearly every Solana audit

**Description:** Admin function does not verify caller is the stored authority.

**Vulnerable Pattern:**
```rust
pub fn update_fee(ctx: ..., fee: u64) { config.fee = fee; } // No auth!
```
**Secure Pattern:**
```rust
#[account(mut, has_one = authority @ ErrorCode::Unauthorized)]
pub config: Account<'info, Config>,
pub authority: Signer<'info>,
```
**Detection:** List privileged ops. Verify `has_one` or key equality constraint.

---

### EP-027: Confused Deputy / Authority Mismatch
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Vaults drained via mismatched vault-authority pairs

**Description:** Signer verified but not matched to the specific resource being accessed.

**Vulnerable Pattern:**
```rust
require!(authority.is_signer); // But for WHICH vault?
```
**Secure Pattern:**
```rust
#[account(mut, has_one = authority)]
pub vault: Account<'info, Vault>,
pub authority: Signer<'info>,
```
**Detection:** Verify authority matched to specific resource via `has_one`.

---

### EP-028: Delegate Authority Misuse
**Category:** Access Control  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Token delegate bypass of owner checks

**Description:** Token account owner checked but delegate ignored. Delegate can still authorize transfers.

**Vulnerable Pattern:**
```rust
require!(token_account.owner == user.key()); // Delegate can still transfer!
```
**Secure Pattern:**
```rust
if let COption::Some(delegate) = token_account.delegate {
    require!(delegate == user.key(), ErrorCode::UnauthorizedDelegate);
}
```
**Detection:** Check if delegate field is validated alongside owner.

---

### EP-029: Missing Freeze Check
**Category:** Access Control  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Frozen accounts used in protocol operations

**Description:** Frozen token account used without checking frozen state.

**Vulnerable Pattern:**
```rust
token::transfer(/* from potentially frozen account */)?;
```
**Secure Pattern:**
```rust
require!(!user_tokens.is_frozen(), ErrorCode::AccountFrozen);
```
**Detection:** Check for `is_frozen()` before token operations.

---

### EP-030: Token Authority Confusion
**Category:** Access Control  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** SPL owner vs transfer authority confusion

**Description:** Token account "owner" field confused with transfer "authority" parameter.

**Vulnerable Pattern:**
```rust
require!(source_token.owner == config.authority); // Wrong field for transfers!
```
**Secure Pattern:**
```rust
require!(admin.key() == config.authority);
require!(source_token.owner == admin.key()
    || source_token.delegate == COption::Some(admin.key()));
```
**Detection:** Review token transfer auth. Distinguish owner from transfer authority.

---

### EP-031: Multi-Sig Duplicate Signer Bypass
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Treasury multi-sigs bypassed with duplicate signers

**Description:** Custom multi-sig doesn't deduplicate signers. One signer counts multiple times.

**Vulnerable Pattern:**
```rust
for signer in signers { if valid(signer) { count += 1; } } // No dedup!
```
**Secure Pattern:**
```rust
let mut seen = HashSet::new();
for signer in signers {
    if !seen.insert(signer.key()) { return Err(ErrorCode::Duplicate); }
}
```
**Detection:** Find custom multi-sig. Verify deduplication of signers.

---

### EP-032: PDA Authority Without Derivation Check
**Category:** Access Control  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Vaults drained via fake PDA accounts

**Description:** PDA key matched but derivation not re-verified. Substituted accounts accepted.

**Vulnerable Pattern:**
```rust
require_keys_eq!(vault.authority, vault_authority.key()); // Key only!
```
**Secure Pattern:**
```rust
#[account(seeds = [b"auth", vault.key().as_ref()], bump)]
pub vault_authority: SystemAccount<'info>, // Re-derives PDA
```
**Detection:** Find PDA authorities. Verify `seeds` constraint re-derives PDA.

---

## Logic / State Machine

### EP-033: CEI Violation
**Category:** Logic Errors  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Crema Finance ($8.8M, Jul 2022), DeFi Land ($70K, Nov 2021)

**Description:** State updates after external calls (CPI). Enables reentrancy or stale-state exploitation.

**Vulnerable Pattern:**
```rust
token::transfer(/* out */)?;    // Interaction FIRST
position.liquidity -= amount;   // Effect LAST - stale if reentered
```
**Secure Pattern:**
```rust
pool.reentrancy_lock = true;
position.liquidity -= amount;   // Effect FIRST
token::transfer(/* out */)?;    // Interaction LAST
pool.reentrancy_lock = false;
```
**Detection:** State updates must precede CPI. Look for reentrancy guards.

---

### EP-034: Missing State Transition Check
**Category:** Logic Errors  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Friktion ($1M, Mar 2022), Orca Whirlpool edge case (disclosed)

**Description:** State machine transitions not validated. Users skip steps or jump to final state.

**Vulnerable Pattern:**
```rust
order.status = OrderStatus::Settled; // No check current == Active!
```
**Secure Pattern:**
```rust
require!(order.status == OrderStatus::Active, ErrorCode::InvalidTransition);
order.status = OrderStatus::Settled;
```
**Detection:** Map state transitions. Verify each checks current state.

---

### EP-035: Closed Account Data Reuse
**Category:** Logic Errors  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** DeFi accounts with stale debt positions

**Description:** Closed account (0 lamports) still readable until GC. Stale data used in operations.

**Vulnerable Pattern:**
```rust
pub data_account: Account<'info, DataAccount>, // No lamport check
```
**Secure Pattern:**
```rust
#[account(constraint = data_account.to_account_info().lamports() > 0)]
pub data_account: Account<'info, DataAccount>,
```
**Detection:** Verify lamport checks on accounts that could be closed.

---

### EP-036: Account Revival / Resurrection
**Category:** Logic Errors  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Accounts revived with stale authority/balance data; Metaplex Auction House persistent sale agreement

**Description:** Closed account data not zeroed. Re-funding revives it with old state. Account garbage collection only happens AFTER a transaction completes, so an attacker can close an account and refund it within the same transaction.

**Same-Transaction Revival Technique (FuzzingLabs):**
1. Instruction 1: Close account (transfer all lamports out)
2. Instruction 2: Transfer lamports BACK into the closed account (same tx)
3. Account remains rent-exempt → not garbage collected
4. Attacker reuses the "closed" account (e.g., claim staking rewards again, replay old listing)

**Vulnerable Pattern:**
```rust
**vault.lamports.borrow_mut() = 0; // Data NOT zeroed, ownership not changed!
// Attacker sends lamports back in next instruction → account persists with old state
```
**Secure Pattern (Three Defenses Required):**
```rust
// Anchor's close constraint does all three:
#[account(mut, close = user)] // 1. Zeros data, 2. Sets discriminator, 3. Transfers ownership
pub vault: Account<'info, Vault>,

// Manual equivalent (all three steps needed):
// 1. Zero all account data
vault.data.borrow_mut().fill(0);
// 2. Set closed account discriminator
vault.data.borrow_mut()[..8].copy_from_slice(&CLOSED_ACCOUNT_DISCRIMINATOR);
// 3. Transfer ownership to system program (prevents revival with old program ownership)
vault.assign(&system_program::ID);
**vault.lamports.borrow_mut() = 0;
```
**Detection:** Review closure ops. Verify ALL THREE defenses: data zeroed, discriminator set, ownership transferred to system program. Flag programs using pre-0.25 Anchor close patterns (discriminator-only, no ownership transfer). Check if any instruction in the program can send lamports to arbitrary accounts (could be used for revival).

**Sources:** FuzzingLabs (Dec 2024), Ackee-Blockchain common attack vectors, RareSkills Solana close account guide

---

### EP-037: Reinitialization Attack
**Category:** Logic Errors  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Parrot Protocol ($80M potential, Oct 2021)

**Description:** Account closed then reinitialized with different params, bypassing original constraints.

**Vulnerable Pattern:**
```rust
config.authority = authority.key(); // No init guard! Can re-init.
```
**Secure Pattern:**
```rust
#[account(init, payer = payer, space = 8 + Config::LEN)] // Fails if exists
pub config: Account<'info, Config>,
```
**Detection:** Check init functions for `init` constraint or `is_initialized` flag.

---

### EP-038: Cross-Instruction State Attack
**Category:** Logic Errors  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Lending protocol multi-instruction withdraw+borrow exploit

**Description:** Multi-instruction tx modifies shared state in ix1, violating invariants in ix2.

**Vulnerable Pattern:**
```rust
// Ix1: withdraw collateral. Ix2: borrow against (withdrawn) collateral.
let collateral = get_collateral(user)?; // Stale from ix1!
```
**Secure Pattern:**
```rust
validate_invariants(user)?; // Check at start
// ... operation ...
validate_invariants(user)?; // Check at end
```
**Detection:** Identify shared state across instructions. Verify pre/post invariant checks.

---

### EP-039: Instruction Introspection Abuse
**Category:** Logic Errors  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Flash loan repayment bypass via fake instructions

**Description:** Auth decisions based on other instructions in tx. Attacker crafts fake instructions.

**Vulnerable Pattern:**
```rust
if check_for_admin_instruction(&ix_sysvar)? { execute_privileged()?; }
```
**Secure Pattern:**
```rust
require!(authority.key() == ADMIN_KEY); // Direct auth, not introspection
```
**Detection:** Find `Sysvar::<Instructions>`. Auth must not depend on other instructions.

---

### EP-040: Closing Account With Obligations
**Category:** Logic Errors  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Lending bad debt from closed accounts

**Description:** Account closed without checking outstanding debts or claims.

**Vulnerable Pattern:**
```rust
#[account(mut, close = authority)] // No debt check!
```
**Secure Pattern:**
```rust
#[account(mut, close = authority,
    constraint = user.debt_owed == 0,
    constraint = user.borrowed == 0)]
```
**Detection:** Review closures. Verify obligation checks.

---

### EP-041: Order Book Stale Cache
**Category:** Logic Errors  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Dexlab ($180K, Sep 2021)

**Description:** Order cancellation doesn't update best bid/ask cache. Market orders hit stale prices.

**Vulnerable Pattern:**
```rust
order.status = Cancelled; // pool.best_bid still points to cancelled order!
```
**Secure Pattern:**
```rust
order.status = Cancelled;
if pool.best_bid == order.price { pool.best_bid = recalculate(pool)?; }
```
**Detection:** Review order cancel logic. Verify cached aggregates updated.

---

## CPI

### EP-042: Arbitrary CPI / Program Substitution
**Category:** CPI  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Fake token programs stealing funds

**Description:** CPI target program ID not validated. Malicious program substituted.

**Vulnerable Pattern:**
```rust
pub target_program: AccountInfo<'info>, // Any program!
```
**Secure Pattern:**
```rust
pub token_program: Program<'info, Token>, // Anchor validates ID
```
**Detection:** Search for `invoke()`. Verify target program IDs validated.

---

### EP-043: CPI Signer Privilege Escalation
**Category:** CPI  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Malicious programs using escalated PDA privileges

**Description:** PDA signer passed to untrusted CPI target. Called program uses signer for unauthorized actions.

**Vulnerable Pattern:**
```rust
invoke_signed(&ix, &remaining_accounts, &[&vault_seeds])?; // Vault signs for anything!
```
**Secure Pattern:**
```rust
require_keys_eq!(target.key(), TRUSTED_PROGRAM_ID);
invoke_signed(&specific_ix, &[vault, dest], signer_seeds)?; // Limited scope
```
**Detection:** Review `invoke_signed`. Verify target validated and accounts explicit.

---

### EP-044: CPI Privilege Propagation
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Strategy contracts stealing via deep CPI chains

**Description:** In A->B->C chains, signer privileges propagate to C. C inherits A's PDA authority.

**Vulnerable Pattern:**
```rust
// A signs for vault, calls B. B calls C. C has vault's signer authority!
```
**Secure Pattern:**
```rust
// Each program validates caller and uses its own PDA, not propagated signers
require!(AUTHORIZED_CALLERS.contains(&caller.key()));
```
**Detection:** Map CPI chains. Verify signer scope per program.

---

### EP-045: CPI Return Data Spoofing
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Oracle manipulation via fake return data

**Description:** `get_return_data()` used without verifying source program ID. Fake data accepted.

**Vulnerable Pattern:**
```rust
let (_, data) = get_return_data()?; // Source not checked!
```
**Secure Pattern:**
```rust
let (program_id, data) = get_return_data()?;
require_keys_eq!(program_id, TRUSTED_ORACLE_ID);
```
**Detection:** Find `get_return_data()`. Verify source program validated.

---

### EP-046: Missing CPI Error Propagation
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Withdrawals recorded despite failed transfers

**Description:** CPI error suppressed (`let _ =`). State updated as if operation succeeded.

**Vulnerable Pattern:**
```rust
let _ = token::transfer(ctx, amount); // Error swallowed!
vault.total += amount; // Wrong!
```
**Secure Pattern:**
```rust
token::transfer(ctx, amount)?; // Propagate with ?
vault.total += amount;
```
**Detection:** Search for `let _ =` on CPI calls. Verify `?` operator.

---

### EP-047: State Update Before CPI
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Double-spend via pre-CPI state mutation

**Description:** Internal state modified before CPI. If CPI interacts with stale state, logic errors result.

**Vulnerable Pattern:**
```rust
vault.balance -= amount; // Updated BEFORE transfer
token::transfer(ctx, amount)?;
```
**Secure Pattern:**
```rust
let pre = vault_token.amount;
token::transfer(ctx, amount)?;
vault_token.reload()?;
vault.balance += vault_token.amount - pre; // Verified actual change
```
**Detection:** Check state updates before CPI. Verify post-CPI balance verification.

---

### EP-048: Missing CPI Guard
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Authority changes via CPI from malicious programs

**Description:** Sensitive instruction callable via CPI, enabling attack chains.

**Vulnerable Pattern:**
```rust
pub fn change_authority(ctx: ...) { vault.authority = new.key(); } // CPI-callable!
```
**Secure Pattern:**
```rust
let ix = get_instruction_relative(0, &ctx.accounts.ix_sysvar)?;
require!(ix.program_id == crate::ID, ErrorCode::CpiNotAllowed);
```
**Detection:** Identify sensitive instructions. Verify CPI protection.

---

### EP-049: Unverified Token Program
**Category:** CPI  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Crema Finance - malicious token program in CPI

**Description:** Token program accepted as `AccountInfo` without ID verification. Malicious program mimics interface.

**Vulnerable Pattern:**
```rust
pub token_program: AccountInfo<'info>, // Could be malicious!
```
**Secure Pattern:**
```rust
pub token_program: Program<'info, Token>, // Anchor validates ID
```
**Detection:** Verify token programs use `Program<'info, Token>`.

---

### EP-050: CPI Account Injection
**Category:** CPI  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Injected remaining_accounts altering CPI behavior

**Description:** `remaining_accounts` forwarded raw to CPI. Attacker injects accounts changing behavior.

**Vulnerable Pattern:**
```rust
invoke(&ix, &ctx.remaining_accounts.to_vec())?; // Unvalidated!
```
**Secure Pattern:**
```rust
invoke(&ix, &[vault.to_account_info(), dest.to_account_info()])?; // Explicit
```
**Detection:** Find CPI with remaining_accounts. Verify explicit account construction.

---

## Token / SPL

### EP-051: Token Account Owner Mismatch
**Category:** Token/SPL  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Deposits credited to wrong users

**Description:** Token account's owner field not verified to match expected user.

**Vulnerable Pattern:**
```rust
pub user_token: Account<'info, TokenAccount>, // owner not verified!
```
**Secure Pattern:**
```rust
#[account(constraint = user_token.owner == user.key())]
pub user_token: Account<'info, TokenAccount>,
```
**Detection:** Verify `.owner` matches expected user on all token accounts.

---

### EP-052: Native SOL Wrapping Confusion
**Category:** Token/SPL  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** WSOL close_account sending SOL to wrong destination

**Description:** Native SOL token accounts have special semantics. close_account ignores destination for WSOL.

**Vulnerable Pattern:**
```rust
token::close_account(/* destination: vault */)? // Ignored for WSOL!
```
**Secure Pattern:**
```rust
if user_token.is_native() { /* handle WSOL separately */ }
else { token::close_account(/* ... */)?; }
```
**Detection:** Check for `is_native()` before close operations.

---

### EP-053: Orphaned Token Account Rent Lock
**Category:** Token/SPL  **Severity:** LOW  **Solana-Specific:** Yes
**Historical Exploits:** Rent accumulation from undrained accounts

**Description:** Token account drained but not closed. Rent SOL locked permanently.

**Vulnerable Pattern:**
```rust
token::transfer(/* all tokens */)?; // Account not closed!
```
**Secure Pattern:**
```rust
token::transfer(/* all tokens */)?;
token::close_account(/* return rent */)?;
```
**Detection:** Find transfers draining accounts. Verify close_account follows.

---

### EP-054: Token-2022 Transfer Fee Not Accounted
**Category:** Token/SPL  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Emerging with Token-2022 adoption

**Description:** Token-2022 transfer fees deducted from recipient. Protocol receives less than expected.

**Vulnerable Pattern:**
```rust
token::transfer(ctx, amount)?;
vault.balance += amount; // Wrong! Fee deducted!
```
**Secure Pattern:**
```rust
let pre = vault_token.amount;
token::transfer_checked(ctx, amount, decimals)?;
vault_token.reload()?;
vault.balance += vault_token.amount - pre; // Actual received
```
**Detection:** Check Token-2022 support. Verify post-transfer balance checks.

---

### EP-055: Token-2022 Transfer Hook Reentrancy
**Category:** Token/SPL  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Emerging with Token-2022 adoption

**Description:** Transfer hooks execute arbitrary code during transfers. Programs can be reentered.

**Vulnerable Pattern:**
```rust
token::transfer(ctx, amount)?; // Hook could reenter this program!
```
**Secure Pattern:**
```rust
pool.reentrancy_lock = true;
pool.balance -= amount; // State BEFORE transfer
token::transfer(ctx, amount)?;
pool.reentrancy_lock = false;
```
**Detection:** Check Token-2022 mint support. Verify reentrancy guards.

---

### EP-056: Token-2022 Confidential Transfer Bypass
**Category:** Token/SPL  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Emerging with Token-2022 adoption

**Description:** Confidential transfers hide amounts. Programs reading `.amount` get 0.

**Vulnerable Pattern:**
```rust
let balance = token_account.amount; // 0 if confidential transfer!
```
**Secure Pattern:**
```rust
if mint_has_extension(ExtensionType::ConfidentialTransfer) {
    return Err(ErrorCode::ConfidentialNotSupported.into());
}
```
**Detection:** Check handling of confidential transfer mints.

---

### EP-057: Token-2022 Non-Transferable Bypass
**Category:** Token/SPL  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Soulbound token transfer via burn+mint

**Description:** Non-transferable extension bypassed through burn-then-mint-to-new-owner pattern.

**Vulnerable Pattern:**
```rust
token::burn(ctx, amount)?;
token::mint_to(new_owner_ctx, amount)?; // Effectively transferred!
```
**Secure Pattern:**
```rust
if mint_has_extension(ExtensionType::NonTransferable) {
    require!(burn_owner == mint_dest, ErrorCode::CannotTransfer);
}
```
**Detection:** Check burn+mint patterns on non-transferable tokens.

---

## Economic / DeFi

### EP-058: Flash Loan Price Manipulation
**Category:** Economic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Nirvana ($3.5M, Jul 2022), Mango Markets ($114M, Oct 2022)

**Description:** Spot price from AMM manipulated via flash loans within single transaction.

**Vulnerable Pattern:**
```rust
let price = pool.reserve_b / pool.reserve_a; // Flash-loan manipulable!
```
**Secure Pattern:**
```rust
let price = oracle.get_twap(TWAP_WINDOW)?;
require!(oracle.confidence < MAX_CONF);
require!(clock.unix_timestamp - oracle.timestamp < MAX_AGE);
```
**Detection:** Find price from pool reserves. Flag spot price usage.

---

### EP-059: Vault Donation / Inflation Attack
**Category:** Economic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** ERC-4626 style attacks on Solana vaults

**Description:** Direct token donation inflates share price. Next depositor's shares round to zero.

**Vulnerable Pattern:**
```rust
let shares = deposit * total_shares / vault_tokens.amount; // Includes donations!
```
**Secure Pattern:**
```rust
let shares = deposit * total_shares / vault.tracked_assets; // Internal accounting
require!(shares > 0, ErrorCode::InsufficientDeposit);
vault.tracked_assets += deposit;
```
**Detection:** Check vault share calculation source. Verify internal accounting vs token balance.

---

### EP-060: Missing Slippage Protection
**Category:** Economic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Sandwich attacks on Jupiter, Raydium, Orca

**Description:** Swap accepts no minimum output. MEV bots sandwich users.

**Vulnerable Pattern:**
```rust
pub fn swap(ctx: ..., amount_in: u64) { /* no min_out! */ }
```
**Secure Pattern:**
```rust
pub fn swap(ctx: ..., amount_in: u64, min_out: u64, deadline: i64) {
    require!(clock.unix_timestamp <= deadline);
    require!(amount_out >= min_out, ErrorCode::Slippage);
}
```
**Detection:** Review swap functions. Verify `min_amount_out` and deadline params.

---

### EP-061: Bonding Curve Instant Arbitrage
**Category:** Economic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Nirvana ($3.5M, Jul 2022)

**Description:** Bonding curve mint-then-burn profitable in same tx with flash loans.

**Vulnerable Pattern:**
```rust
pub fn mint(amount: u64) { supply += amount; /* price goes up */ }
pub fn burn(amount: u64) { /* redeem at 90% of new higher price */ }
```
**Secure Pattern:**
```rust
// Add vesting: minted tokens locked for minimum duration
position.unlock_slot = clock.slot + VESTING_SLOTS; // e.g., 24h
// Plus: per-tx caps, TWAP pricing, redemption fees
```
**Detection:** Find bonding curves. Check if mint-burn is profitable in single tx.

---

### EP-062: Reward Calculation Gaming
**Category:** Economic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Multiple staking protocols gamed via deposit-before-reward

**Description:** Rewards based on current share, not time-weighted. Deposit before distribution, claim, withdraw.

**Vulnerable Pattern:**
```rust
let rewards = total_rewards * user.shares / pool.total_shares; // No time weight!
```
**Secure Pattern:**
```rust
// Accumulator pattern: acc_reward_per_share += reward_rate * elapsed / total
let pending = user.shares * pool.acc_reward_per_share - user.reward_debt;
```
**Detection:** Review reward mechanisms. Verify time-weighted or accumulator pattern.

---

### EP-063: Interest Rate Manipulation
**Category:** Economic  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Euler Finance ($200M, Mar 2023, Ethereum)

**Description:** Instant rate updates based on utilization. Flash loans spike utilization.

**Vulnerable Pattern:**
```rust
let rate = calculate_rate(borrowed * 10000 / deposited); // Instant!
```
**Secure Pattern:**
```rust
let twap_util = pool.calculate_twap_utilization(SLOTS_PER_HOUR)?;
let max_change = pool.rate / 10;
pool.rate = clamp(target, pool.rate - max_change, pool.rate + max_change);
```
**Detection:** Check rate updates: instant vs TWAP utilization. Verify rate change limits.

---

### EP-064: JIT Liquidity Extraction
**Category:** Economic  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Orca Whirlpools, Uniswap V3

**Description:** LP adds liquidity before swap, earns fees, removes immediately. No risk exposure.

**Vulnerable Pattern:**
```rust
pub fn remove_liquidity(ctx: ...) { position.liquidity -= amount; } // Same slot OK!
```
**Secure Pattern:**
```rust
position.locked_until = clock.slot + MIN_SLOTS; // ~18 min lock
require!(clock.slot >= position.locked_until);
```
**Detection:** Check minimum liquidity duration.

---

### EP-065: Liquidation MEV
**Category:** Economic  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Solend, MarginFi via Jito bundles, Hubble ($180K, Jul 2022)

**Description:** Fixed liquidation bonus creates MEV. Bots front-run liquidators.

**Vulnerable Pattern:**
```rust
let bonus = collateral * 110 / 100; // Fixed 10% = MEV target
```
**Secure Pattern:**
```rust
let bonus = if health < 0.5 { 1000 } else if health < 0.8 { 500 } else { 200 }; // Dynamic
```
**Detection:** Check liquidation incentive structure. Verify dynamic bonuses.

---

### EP-066: Governance Flash Loan Attack
**Category:** Economic  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Beanstalk ($181M, Apr 2022), Solend governance (Jun 2022)

**Description:** Flash-borrowed tokens give instant voting power. Vote on malicious proposal in same tx.

**Vulnerable Pattern:**
```rust
voter.voting_power = voter.token_amount; // Immediate!
```
**Secure Pattern:**
```rust
voter.pending_deposit_slot = clock.slot;
// Activate after delay. Use snapshot voting at proposal creation.
```
**Detection:** Check instant voting power. Verify delay/snapshot mechanisms.

---

### EP-067: Multi-Hop Price Impact Amplification
**Category:** Economic  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Jupiter routing manipulation

**Description:** Multi-hop routes compound price impact. First pool manipulated to amplify slippage.

**Vulnerable Pattern:**
```rust
for swap in route { amount = swap_pool(pool, amount)?; } // No aggregate check!
```
**Secure Pattern:**
```rust
require!(total_impact_bps <= max_impact);
require!(amount >= min_amount_out);
```
**Detection:** Review multi-hop routing. Verify aggregate impact limits.

---

<!-- END: exploit-patterns-core.md | EP-001 to EP-067 | Categories 1-8 -->
