# VP-011: Fee Rounding Direction

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
When computing fees via integer division, the result is truncated (rounded toward zero). If fees round down, the protocol loses fractions of a token on every transaction. Over millions of transactions, this creates a systematic value leak. Fees should always round up (in the protocol's favor).

## Why It Matters
A fee that rounds down by 1 lamport per transaction costs the protocol 1M lamports per million transactions. On high-volume DEXs processing millions of swaps daily, this is a significant revenue loss and a potential exploit vector where attackers intentionally use amounts designed to zero out fees.

## Real-World Incident
Token-2022 transfer fee rounding issues are a recurring audit finding on Solana. The SPL Token-2022 reference implementation explicitly uses ceiling division for fees to prevent fee-bypass through transfer splitting. QuillAudits' OWASP Solana Top 10 lists integer overflow/underflow (which includes fee rounding errors) as a top vulnerability class.

## Invariant

### Formal Property
```
∀ amount > 0, fee_rate > 0:
  fee_protocol = ceil(amount * fee_rate / DENOMINATOR)
  fee_protocol >= 1 (no zero fees on non-zero amounts with non-zero rate)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_rounds_up() {
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(amount > 0 && amount < u64::MAX / 10_000);
    kani::assume!(fee_bps > 0 && fee_bps <= 10_000);

    // Ceiling division: (a * b + denom - 1) / denom
    let numerator = amount as u128 * fee_bps as u128;
    let fee_ceil = (numerator + 9_999) / 10_000;
    let fee_floor = numerator / 10_000;

    // Protocol fee must use ceiling
    kani::assert!(fee_ceil >= fee_floor);
    kani::assert!(fee_ceil >= 1); // Never zero for non-zero inputs
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_always_rounds_up(
        amount in 1u64..1_000_000_000,
        fee_bps in 1u16..300
    ) {
        let fee = calculate_fee_ceil(amount, fee_bps);
        let fee_floor = (amount as u128) * (fee_bps as u128) / 10_000;
        prop_assert!(fee as u128 >= fee_floor, "fee rounded down");
        prop_assert!(fee >= 1, "zero fee on non-zero amount");
    }
}
```

### LiteSVM Assertion
```rust
// Swap 1 lamport with 1 bps fee — fee must still be 1 (ceil), not 0
let fee = calculate_fee_ceil(1, 1);
assert_eq!(fee, 1, "fee on 1 lamport should ceil to 1");
```

## Suggested Fix
```rust
/// Ceiling division for fees: always rounds in protocol's favor
pub fn fee_ceil(amount: u64, bps: u16) -> u64 {
    let num = (amount as u128) * (bps as u128);
    ((num + 9_999) / 10_000) as u64
}
```
