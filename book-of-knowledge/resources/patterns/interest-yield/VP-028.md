# VP-028: Interest Rate Precision Over Long Periods

**Category:** Interest/Yield
**Verification tool:** Proptest

## What Can Go Wrong
Interest calculations that work correctly over short periods can drift significantly over months. Each per-slot calculation introduces a tiny rounding error. Over millions of slots, these errors compound. The accumulated drift can mean actual interest earned diverges noticeably from the intended rate.

## Why It Matters
A lending protocol that drifts 0.1% per month accumulates ~1.2% annual error. At $100M TVL, that's $1.2M of misallocated interest â€” either the protocol underpays depositors or overcharges borrowers.

## Real-World Incident
Multiple Solana lending protocols (Port Finance, Solend) had to carefully tune their interest accumulation precision after discovering long-term drift in testnet simulations.

## Invariant

### Formal Property
```
After N slots at rate R:
  |actual_accumulated - R * N / SLOTS_PER_YEAR| / (R * N / SLOTS_PER_YEAR) <= tolerance
  tolerance typically 0.01% (1 basis point)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_interest_drift() {
    let rate_annual_bps: u16 = kani::any();
    let slots: u32 = kani::any();

    kani::assume!(rate_annual_bps > 0 && rate_annual_bps <= 5000);
    kani::assume!(slots > 0 && slots <= 1000);

    let per_slot = (rate_annual_bps as u128) * PRECISION / SLOTS_PER_YEAR / 10_000;
    let accumulated = per_slot * (slots as u128);

    // Must be positive and bounded
    kani::assert!(accumulated > 0);
    kani::assert!(accumulated < u128::MAX / 2);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn interest_precision_over_6_months(
        rate_bps in 100u16..5000,
        principal in 1_000_000u64..1_000_000_000
    ) {
        let slots_6_months = SLOTS_PER_YEAR / 2;
        let mut balance = principal as u128 * PRECISION;
        let rate_per_slot = (rate_bps as u128) * PRECISION / SLOTS_PER_YEAR as u128 / 10_000;

        // Simulate slot-by-slot accrual (sample every 1000 slots)
        for _ in 0..(slots_6_months / 1000) {
            balance += balance * rate_per_slot * 1000 / PRECISION;
        }
        let actual = balance / PRECISION;
        let expected = (principal as f64) * (1.0 + rate_bps as f64 / 20_000.0); // ~half year
        let drift = ((actual as f64 - expected) / expected).abs();
        prop_assert!(drift < 0.001, "drift {} after 6 months", drift);
    }
}
```

### LiteSVM Assertion
```rust
let initial = get_deposit(&ctx, &user).await;
// Advance 6 months
advance_slots(&mut ctx, SLOTS_PER_YEAR / 2).await;
accrue(&mut ctx).await.unwrap();
let final_bal = get_deposit(&ctx, &user).await;
let actual_yield = (final_bal as f64 / initial as f64) - 1.0;
let expected_yield = annual_rate as f64 / 10_000.0 / 2.0;
assert!((actual_yield - expected_yield).abs() / expected_yield < 0.01);
```

## Suggested Fix
```rust
/// Use high-precision accumulator with carry-forward remainder
pub fn accrue_interest_precise(market: &mut Market, slots: u64) -> Result<()> {
    let rate = market.rate_per_slot_x64; // Q64.64 fixed point
    let interest_x64 = rate.checked_mul(slots as u128)?;
    market.cumulative_rate_x64 = market.cumulative_rate_x64
        .checked_add(market.cumulative_rate_x64.checked_mul(interest_x64)? >> 64)?;
    Ok(())
}
```
