# VP-101: Pack/Unpack Round-Trip Consistency

**Category:** Bit Packing
**Verification tool:** Kani

## What Can Go Wrong
After packing multiple fields into a single integer and unpacking them, all field values must match the originals. If any field's mask overlaps with another, packing field B corrupts field A. If widths don't sum correctly, some bits are shared or orphaned.

## Why It Matters
Corrupted account data from pack/unpack bugs can cause any downstream behavior — wrong balances, wrong permissions, wrong states. Because the corruption is silent (no panic), it may not be detected until real funds are lost.

## Real-World Incident
No specific public incident documented, but pack/unpack consistency is a standard verification target in any protocol using bit-packed account state. Solana's rent-minimization incentives push many programs toward packed data.

## Invariant

### Formal Property
```
∀ fields [f1, f2, ..., fn]:
  unpack(pack(f1, f2, ..., fn)) = (f1, f2, ..., fn)
Field masks must not overlap: mask_i & mask_j = 0 for i ≠ j
Total bits used <= storage type width
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_pack_unpack_roundtrip() {
    let field_a: u8 = kani::any();  // 8 bits at position 0
    let field_b: u16 = kani::any(); // 16 bits at position 8
    let field_c: u8 = kani::any();  // 8 bits at position 24

    let packed = (field_a as u64)
        | ((field_b as u64) << 8)
        | ((field_c as u64) << 24);

    let unpacked_a = (packed & 0xFF) as u8;
    let unpacked_b = ((packed >> 8) & 0xFFFF) as u16;
    let unpacked_c = ((packed >> 24) & 0xFF) as u8;

    kani::assert!(unpacked_a == field_a, "field A corrupted");
    kani::assert!(unpacked_b == field_b, "field B corrupted");
    kani::assert!(unpacked_c == field_c, "field C corrupted");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn roundtrip_all_fields(
        a in 0u8..,
        b in 0u16..,
        c in 0u8..,
        d in 0u32..
    ) {
        let packed = pack(a, b, c, d);
        let (ua, ub, uc, ud) = unpack(packed);
        prop_assert_eq!(ua, a, "field a corrupted");
        prop_assert_eq!(ub, b, "field b corrupted");
        prop_assert_eq!(uc, c, "field c corrupted");
        prop_assert_eq!(ud, d, "field d corrupted");
    }
}
```

### LiteSVM Assertion
```rust
// Create account with packed data, read back, verify all fields
let original = MyState { status: 3, amount: 12345, flags: 0xAB };
let packed = original.pack();
let unpacked = MyState::unpack(&packed);
assert_eq!(unpacked.status, 3);
assert_eq!(unpacked.amount, 12345);
assert_eq!(unpacked.flags, 0xAB);
```

## Suggested Fix
```rust
/// Derive pack/unpack from struct definition to prevent manual errors
#[derive(BorshSerialize, BorshDeserialize)]
pub struct PackedState {
    pub status: u8,      // 8 bits
    pub amount: u64,     // 64 bits
    pub flags: u8,       // 8 bits
}
// Borsh serialization guarantees round-trip consistency
// For manual packing, use compile-time assertions:
const_assert!(FIELD_A_BITS + FIELD_B_BITS + FIELD_C_BITS <= 64);
```
