# VP-047: Bonding Curve Monotonicity

**Category:** Bonding Curves
**Verification tool:** Kani

## What Can Go Wrong
A bonding curve must be monotonically increasing — price rises with supply. If the curve has non-monotonic regions (due to integer math, wrong exponents, or overflow), the price can decrease as supply increases, allowing attackers to buy cheap and sell high within the same curve.

## Why It Matters
Non-monotonic pricing means arbitrage: buy at a low-price region, then sell at a higher-price region of the same curve, profiting without external market conditions changing. This drains the bonding curve's reserve.

## Real-World Incident
Pump.fun on Solana uses bonding curves for token launches. Numerous copycat implementations have had monotonicity bugs due to incorrect integer math approximations of the curve formula.

## Invariant

### Formal Property
```
∀ supply_a < supply_b:
  price(supply_a) <= price(supply_b)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_price_monotonically_increasing() {
    let supply_a: u64 = kani::any();
    let supply_b: u64 = kani::any();

    kani::assume!(supply_a < supply_b);
    kani::assume!(supply_a < u64::MAX / 2);
    kani::assume!(supply_b < u64::MAX / 2);

    let price_a = bonding_price(supply_a);
    let price_b = bonding_price(supply_b);

    kani::assert!(price_b >= price_a, "price decreased with increasing supply");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn price_increases_with_supply(
        supply in 0u64..1_000_000_000,
        delta in 1u64..1_000_000
    ) {
        let price_before = bonding_price(supply);
        let price_after = bonding_price(supply + delta);
        prop_assert!(price_after >= price_before,
            "price decreased: {} -> {} at supply {}", price_before, price_after, supply);
    }
}
```

### LiteSVM Assertion
```rust
let mut prev_price = 0u64;
for supply in (0..1_000_000_000).step_by(10_000_000) {
    let price = get_bonding_price(&ctx, supply).await;
    assert!(price >= prev_price, "non-monotonic at supply {}", supply);
    prev_price = price;
}
```

## Suggested Fix
```rust
/// Linear bonding curve: price = base_price + slope * supply
pub fn bonding_price(supply: u64, base_price: u64, slope: u64) -> u64 {
    base_price.checked_add(
        (supply as u128).checked_mul(slope as u128).unwrap() as u64 / PRECISION as u64
    ).unwrap()
}
```
