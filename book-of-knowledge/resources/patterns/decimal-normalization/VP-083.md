# VP-083: Cross-Token Decimal Normalization Overflow

**Category:** Decimal Normalization
**Verification tool:** Kani

## What Can Go Wrong
When normalizing between tokens with large decimal differences (e.g., 0 to 18), the multiplication `amount * 10^18` overflows u64 for any amount > 18. Even u128 can overflow for extreme cases. If overflow isn't checked, the result wraps to a tiny number.

## Why It Matters
An overflow in decimal normalization produces a garbage value — typically near-zero. This means a large deposit gets valued as nearly worthless, or a tiny amount gets valued as enormous, depending on direction.

## Real-World Incident
No specific public incident documented on Solana (most SPL tokens use 6-9 decimals), but Ethereum DeFi has seen issues with tokens using extreme decimal values (0-18 range).

## Invariant

### Formal Property
```
amount * 10^(to - from) must not overflow the storage type
If overflow would occur, the operation must return an error
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_normalization_no_overflow() {
    let amount: u64 = kani::any();
    let from_dec: u8 = kani::any();
    let to_dec: u8 = kani::any();

    kani::assume!(from_dec <= 18 && to_dec <= 18);
    kani::assume!(amount > 0);

    if to_dec > from_dec {
        let diff = (to_dec - from_dec) as u32;
        if diff <= 19 { // 10^19 < u64::MAX
            let scale = 10u128.pow(diff);
            let result = (amount as u128).checked_mul(scale);
            if let Some(r) = result {
                kani::assert!(r >= amount as u128);
            }
        }
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn normalization_overflow_caught(
        amount in 1u64..u64::MAX,
        from_dec in 0u8..=9,
        to_dec in 0u8..=9
    ) {
        let result = safe_normalize(amount, from_dec, to_dec);
        match result {
            Ok(v) => {
                if to_dec > from_dec { prop_assert!(v >= amount); }
                else { prop_assert!(v <= amount); }
            }
            Err(_) => {} // overflow correctly caught
        }
    }
}
```

### LiteSVM Assertion
```rust
// u64::MAX with 0→9 decimal shift should fail
let result = normalize_decimals(u64::MAX, 0, 9);
assert!(result.is_err(), "should overflow for MAX * 10^9");
```

## Suggested Fix
```rust
pub fn safe_normalize(amount: u64, from: u8, to: u8) -> Result<u64> {
    if to > from {
        let scale = 10u64.checked_pow((to - from) as u32).ok_or(MathError::Overflow)?;
        amount.checked_mul(scale).ok_or(MathError::Overflow)
    } else {
        Ok(amount / 10u64.pow((from - to) as u32))
    }
}
```
