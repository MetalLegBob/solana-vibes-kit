# VP-063: English Auction Bid Increment

**Category:** Auction
**Verification tool:** Kani

## What Can Go Wrong
In an English auction, each new bid must be at least the previous highest bid plus a minimum increment. Without enforcement, an attacker places bids just 1 lamport above the current highest, griefing legitimate bidders by making each outbid cost gas while barely increasing the price. The auction settles far below fair market value.

## Why It Matters
Rapid minimum-increment bids discourage legitimate bidders who must pay transaction fees to outbid by trivial amounts. The attacker wins at a price far below market value because other bidders abandon the griefing game. Enforcing a meaningful minimum increment ensures the price advances substantively with each bid.

## Real-World Incident
Auction griefing via minimal bid increments has been documented in multiple NFT marketplace audits, including audits of Metaplex auction contracts where insufficient increment validation was flagged as a medium-severity finding.

## Invariant

### Formal Property
```
forall new_bid, current_highest, min_increment:
  accepted(new_bid) => new_bid >= current_highest + min_increment
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_bid_increment() {
    let prev_bid: u64 = kani::any();
    let min_inc: u64 = kani::any();
    let new_bid: u64 = kani::any();

    kani::assume!(prev_bid > 0 && prev_bid < u64::MAX / 2);
    kani::assume!(min_inc > 0 && min_inc <= 1_000_000_000);
    kani::assume!(new_bid > 0 && new_bid < u64::MAX);

    let threshold = prev_bid as u128 + min_inc as u128;
    let accepted = new_bid as u128 >= threshold;
    kani::assert!(!accepted || new_bid as u128 >= prev_bid as u128 + min_inc as u128);
    kani::assert!(!accepted || new_bid > prev_bid);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn bid_increment_enforced(
        prev_bid in 1u64..1_000_000_000,
        min_inc in 1u64..100_000_000,
        new_bid in 1u64..2_000_000_000,
    ) {
        let threshold = prev_bid as u128 + min_inc as u128;
        let accepted = new_bid as u128 >= threshold;
        if accepted {
            prop_assert!(new_bid > prev_bid);
            prop_assert!(new_bid as u128 >= threshold);
        }
    }
}
```

### LiteSVM Assertion
```rust
let auction = create_english_auction(&mut ctx, seller, reserve, min_increment).await;
place_bid(&mut ctx, auction, bidder_a, 1_000_000).await.unwrap();

let low_bid = 1_000_000 + min_increment - 1;
let result = place_bid(&mut ctx, auction, bidder_b, low_bid).await;
assert!(result.is_err(), "bid below increment must be rejected");

let valid_bid = 1_000_000 + min_increment;
place_bid(&mut ctx, auction, bidder_b, valid_bid).await.unwrap();
let state = get_auction_state(&ctx, auction).await;
assert_eq!(state.highest_bid, valid_bid);
```

## Suggested Fix
```rust
pub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {
    let auction = &mut ctx.accounts.auction;
    let threshold = auction.highest_bid
        .checked_add(auction.min_increment)
        .ok_or(AuctionError::Overflow)?;
    require!(amount >= threshold, AuctionError::BidTooLow);
    transfer_lamports(auction, &ctx.accounts.prev_bidder, auction.highest_bid)?;
    auction.highest_bid = amount;
    auction.highest_bidder = ctx.accounts.bidder.key();
    Ok(())
}
```
