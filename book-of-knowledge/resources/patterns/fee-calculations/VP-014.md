# VP-014: Fee Precision Loss at Small Amounts

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
When amount * fee_bps < 10_000 (the denominator), floor division produces 0. This means small transactions pay no fee at all. An attacker can split a large swap into many small swaps, each below the fee threshold, to avoid paying fees entirely.

## Why It Matters
If the minimum feeable amount is 10,000 lamports at 1 bps, an attacker can execute 10,000 swaps of 9,999 lamports each (total: ~99.99M lamports) paying zero fees. This drains pool value through the fee-free swaps while the pool bears the full price impact.

## Real-World Incident
Fee avoidance through transaction splitting has been documented in multiple AMM protocols. This was a known issue in early Raydium and Orca implementations on Solana before they added minimum trade sizes.

## Invariant

### Formal Property
```
∀ amount > 0, fee_bps > 0:
  fee_ceil(amount, fee_bps) >= 1
  (Using ceiling division ensures no zero-fee on positive inputs)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_zero_fee_on_positive_inputs() {
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(amount > 0);
    kani::assume!(fee_bps > 0 && fee_bps <= 10_000);

    // With ceiling division
    let num = (amount as u128) * (fee_bps as u128);
    let fee = (num + 9_999) / 10_000;

    kani::assert!(fee >= 1, "zero fee on positive amount with positive rate");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn small_amounts_still_pay_fee(
        amount in 1u64..10_000,
        fee_bps in 1u16..300
    ) {
        let fee = fee_ceil(amount, fee_bps);
        prop_assert!(fee >= 1, "zero fee on {} at {} bps", amount, fee_bps);
    }
}
```

### LiteSVM Assertion
```rust
// Swap 1 lamport — should still incur a fee
let pool_before = get_pool_state(&ctx, pool_key).await;
execute_swap(&mut ctx, 1).await.unwrap();
let pool_after = get_pool_state(&ctx, pool_key).await;
let fees_collected = pool_after.total_fees - pool_before.total_fees;
assert!(fees_collected >= 1, "1-lamport swap collected 0 fees");
```

## Suggested Fix
```rust
/// Always use ceiling division for protocol fees
pub fn fee_ceil(amount: u64, bps: u16) -> u64 {
    if amount == 0 || bps == 0 { return 0; }
    let num = (amount as u128) * (bps as u128);
    ((num + 9_999) / 10_000) as u64 // ceil: always >= 1 for positive inputs
}
```
