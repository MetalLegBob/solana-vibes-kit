# VP-041: TWAP Correctness Over Observation Window

**Category:** Price Oracle
**Verification tool:** Proptest

## What Can Go Wrong
Time-Weighted Average Price (TWAP) must correctly weight each price observation by its duration. If timestamps are imprecise, durations negative, or the averaging formula wrong, the TWAP diverges from the true average price, making the oracle exploitable.

## Why It Matters
An incorrect TWAP means liquidations, collateral valuations, and swap pricing use wrong prices. Attackers can manipulate on-chain prices momentarily, and if the TWAP doesn't properly smooth these spikes, the manipulation succeeds.

## Real-World Incident
Pyth Network, Solana's primary oracle, malfunctioned in September 2021, reporting Bitcoin at $5,402 when the actual price was above $40,000. DOGE was reported above $0.88 for 11 hours. These bad price feeds triggered unwarranted liquidations on Mango Markets. This incident demonstrated the catastrophic impact of oracle data quality issues.

## Invariant

### Formal Property
```
TWAP = Σ(price_i * duration_i) / Σ(duration_i)
min(all prices) <= TWAP <= max(all prices)
TWAP changes smoothly (bounded rate of change per slot)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_twap_bounded_by_observations() {
    let price_a: u64 = kani::any();
    let price_b: u64 = kani::any();
    let duration_a: u64 = kani::any();
    let duration_b: u64 = kani::any();

    kani::assume!(price_a > 0 && price_b > 0);
    kani::assume!(duration_a > 0 && duration_b > 0);
    kani::assume!(price_a < u64::MAX / 2 && price_b < u64::MAX / 2);

    let twap = ((price_a as u128) * (duration_a as u128) + (price_b as u128) * (duration_b as u128))
        / ((duration_a + duration_b) as u128);

    let min_price = price_a.min(price_b) as u128;
    let max_price = price_a.max(price_b) as u128;
    kani::assert!(twap >= min_price && twap <= max_price);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn twap_within_observation_range(
        observations in prop::collection::vec((1u64..1_000_000, 1u64..3600), 2..=20)
    ) {
        let total_weighted: u128 = observations.iter()
            .map(|&(p, d)| p as u128 * d as u128).sum();
        let total_duration: u128 = observations.iter()
            .map(|&(_, d)| d as u128).sum();
        let twap = total_weighted / total_duration;
        let min_p = observations.iter().map(|&(p, _)| p as u128).min().unwrap();
        let max_p = observations.iter().map(|&(p, _)| p as u128).max().unwrap();
        prop_assert!(twap >= min_p && twap <= max_p);
    }
}
```

### LiteSVM Assertion
```rust
let observations = get_oracle_observations(&ctx, 10).await;
let twap = compute_twap(&observations);
let prices: Vec<u64> = observations.iter().map(|o| o.price).collect();
assert!(twap >= *prices.iter().min().unwrap() as u128);
assert!(twap <= *prices.iter().max().unwrap() as u128);
```

## Suggested Fix
```rust
pub fn compute_twap(observations: &[(u64, u64)]) -> u128 { // (price, duration)
    let (weighted_sum, total_duration) = observations.iter().fold(
        (0u128, 0u128),
        |(ws, td), &(price, duration)| {
            (ws + price as u128 * duration as u128, td + duration as u128)
        },
    );
    require!(total_duration > 0, OracleError::NoObservations);
    weighted_sum / total_duration
}
```
