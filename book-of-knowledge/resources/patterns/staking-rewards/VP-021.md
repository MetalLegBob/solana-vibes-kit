# VP-021: Reward Accumulator Overflow

**Category:** Staking Rewards
**Verification tool:** Kani

## What Can Go Wrong
The reward_per_token_stored accumulator grows with every time period. If stored as u64 or even u128, it can overflow after sufficient time at high reward rates with low total stake. Once overflowed, all reward calculations produce incorrect results.

## Why It Matters
An overflow in the accumulator means all stakers receive incorrect rewards. If the accumulator wraps to near-zero, pending rewards for all users drop to near-zero. If it wraps to a large value, the protocol may try to distribute more rewards than it has.

## Real-World Incident
No specific public incident documented, but accumulator overflow is a standard concern. Solana programs typically use u128 accumulators with a 10^12 precision multiplier, which provides ~584 billion years of headroom at typical rates.

## Invariant

### Formal Property
```
reward_per_token_stored = Î£(reward_rate * elapsed / total_staked) * PRECISION
This must fit in u128 for the expected protocol lifetime.
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_accumulator_no_overflow() {
    let rate: u64 = kani::any();
    let elapsed: u64 = kani::any();
    let total_staked: u64 = kani::any();
    let current_rpt: u128 = kani::any();

    kani::assume!(rate > 0 && rate <= 1_000_000_000);
    kani::assume!(elapsed > 0 && elapsed <= 86400); // max 1 day per update
    kani::assume!(total_staked >= 1_000); // minimum stake
    kani::assume!(current_rpt < u128::MAX / 2);

    let increment = (elapsed as u128)
        .checked_mul(rate as u128)
        .and_then(|v| v.checked_mul(1_000_000_000_000)) // PRECISION
        .map(|v| v / (total_staked as u128));

    if let Some(inc) = increment {
        let new_rpt = current_rpt.checked_add(inc);
        kani::assert!(new_rpt.is_some(), "accumulator overflow");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn accumulator_fits_u128_for_10_years(
        rate in 1u64..1_000_000_000,
        total_staked in 1_000u64..1_000_000_000_000
    ) {
        let seconds_10_years = 86400u128 * 365 * 10;
        let max_rpt = seconds_10_years * (rate as u128) * PRECISION / (total_staked as u128);
        prop_assert!(max_rpt < u128::MAX / 2, "accumulator overflow in 10 years");
    }
}
```

### LiteSVM Assertion
```rust
// Fast-forward 1 year with high reward rate
for _ in 0..365 {
    advance_clock(&mut ctx, 86400).await; // 1 day
    update_rewards(&mut ctx).await.unwrap();
}
let pool = get_pool_state(&ctx).await;
// Should not have wrapped
assert!(pool.reward_per_token_stored > 0, "accumulator wrapped to 0");
```

## Suggested Fix
```rust
const PRECISION: u128 = 1_000_000_000_000; // 10^12

pub fn update_accumulator(pool: &mut Pool, elapsed: u64) -> Result<()> {
    if pool.total_staked == 0 { return Ok(()); }
    let increment = (elapsed as u128)
        .checked_mul(pool.reward_rate as u128)
        .ok_or(StakeError::MathOverflow)?
        .checked_mul(PRECISION)
        .ok_or(StakeError::MathOverflow)?
        / (pool.total_staked as u128);
    pool.reward_per_token_stored = pool.reward_per_token_stored
        .checked_add(increment)
        .ok_or(StakeError::AccumulatorOverflow)?;
    Ok(())
}
```
