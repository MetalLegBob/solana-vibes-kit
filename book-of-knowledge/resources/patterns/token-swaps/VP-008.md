# VP-008: Flash Loan Sandwich Invariant

**Category:** Token Swaps
**Verification tool:** LiteSVM

## What Can Go Wrong
Flash loans allow borrowing tokens without collateral within a single transaction. If a pool doesn't verify that reserves are at least as high post-flash-loan as pre-flash-loan (plus fees), an attacker can borrow tokens, manipulate price, profit from the manipulation, and return fewer tokens than required.

## Why It Matters
Flash loan attacks are among the most devastating DeFi exploits. The attacker needs zero capital â€” they borrow millions, manipulate the target protocol, extract profit, repay the loan, and keep the difference, all atomically.

## Real-World Incident
The Yearn yETH pool suffered a $9M exploit (November 2025) where an attacker manipulated the weighted StableSwap AMM's mathematical invariant through careful exchange rate updates, collapsing the balance indicator to zero and draining the pool.

## Invariant

### Formal Property
```
For flash_loan(amount, callback):
  reserves_after >= reserves_before + flash_fee(amount)
  This must be checked AFTER the callback executes
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_flash_loan_repayment() {
    let reserve_before: u64 = kani::any();
    let borrow_amount: u64 = kani::any();
    let repay_amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(reserve_before > 1_000_000);
    kani::assume!(borrow_amount > 0 && borrow_amount <= reserve_before);
    kani::assume!(fee_bps > 0 && fee_bps <= 1000);

    let required_fee = (borrow_amount as u128) * (fee_bps as u128) / 10_000;
    let required_repay = borrow_amount as u128 + required_fee;

    // If repayment is sufficient, reserves grow
    if repay_amount as u128 >= required_repay {
        let reserve_after = reserve_before as u128 - borrow_amount as u128 + repay_amount as u128;
        kani::assert!(reserve_after >= reserve_before as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn flash_loan_preserves_reserves(
        reserve in 1_000_000u64..1_000_000_000,
        borrow in 1u64..500_000_000,
        fee_bps in 1u16..100
    ) {
        prop_assume!(borrow <= reserve);
        let fee = (borrow as u128) * (fee_bps as u128) / 10_000;
        let repay = borrow as u128 + fee;
        let reserve_after = reserve as u128 - borrow as u128 + repay;
        prop_assert!(reserve_after >= reserve as u128);
    }
}
```

### LiteSVM Assertion
```rust
let reserve_before = get_token_balance(&ctx, pool_vault).await;
// Execute flash loan that tries to underpay
let result = process_transaction(&mut ctx, underpay_flash_ix, &payer).await;
assert!(result.is_err(), "flash loan with insufficient repayment must fail");
let reserve_after = get_token_balance(&ctx, pool_vault).await;
assert!(reserve_after >= reserve_before, "reserves decreased after flash loan");
```

## Suggested Fix
```rust
pub fn flash_loan(ctx: Context<FlashLoan>, amount: u64) -> Result<()> {
    let vault_before = ctx.accounts.vault.amount;
    // Transfer to borrower
    transfer_out(ctx, amount)?;
    // Execute callback (CPI to borrower's program)
    invoke_callback(ctx)?;
    // Reload and verify
    ctx.accounts.vault.reload()?;
    let vault_after = ctx.accounts.vault.amount;
    let min_fee = calculate_flash_fee(amount)?;
    require!(vault_after >= vault_before + min_fee, FlashError::InsufficientRepayment);
    Ok(())
}
```
