# VP-069: Cross-Collateral Ratio Aggregation

**Category:** Collateral Ratios
**Verification tool:** Proptest

## What Can Go Wrong
When a position uses multiple collateral assets, the total collateral value is a weighted sum of individual asset values. Each asset has a different collateral factor. Errors in the weighted sum, especially when mixing assets with different decimal precisions, can produce an inflated or deflated aggregate. Summing many floor-rounded terms compounds error up to N for N assets.

## Why It Matters
An attacker deposits a mix of assets with different decimal precisions, exploiting rounding in the weighted sum to inflate aggregate collateral value. They borrow more than the collateral truly supports. On liquidation, actual collateral is insufficient to cover debt, leaving bad debt socialized across other users.

## Real-World Incident
The Apricot Finance audit on Solana flagged rounding accumulation in multi-asset collateral calculations that could allow overborrowing by small amounts across many positions. Similar findings appear in multi-asset lending protocol audits on both Solana and EVM chains.

## Invariant

### Formal Property
```
For assets[0..n] with values[] and weights[]:
  aggregate = sum_i(floor(values[i] * weights[i] / 10000))
  aggregate <= exact_sum     (never overcount)
  exact_sum - aggregate <= n (bounded error)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_cross_collateral_bounded() {
    let v1: u64 = kani::any();
    let v2: u64 = kani::any();
    let w1: u64 = kani::any();
    let w2: u64 = kani::any();

    kani::assume!(v1 > 0 && v1 < 1_000_000_000);
    kani::assume!(v2 > 0 && v2 < 1_000_000_000);
    kani::assume!(w1 > 0 && w1 <= 10_000);
    kani::assume!(w2 > 0 && w2 <= 10_000);

    let c1 = (v1 as u128) * (w1 as u128) / 10_000;
    let c2 = (v2 as u128) * (w2 as u128) / 10_000;
    let aggregate = c1 + c2;
    let exact = ((v1 as u128) * (w1 as u128) + (v2 as u128) * (w2 as u128)) / 10_000;
    kani::assert!(aggregate <= exact + 1);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn cross_collateral_error_bounded(
        values in prop::collection::vec(1u64..1_000_000_000, 1..=8),
        weights in prop::collection::vec(1u64..10_000, 1..=8),
    ) {
        let n = values.len().min(weights.len());
        prop_assume!(n > 0);
        let aggregate: u128 = (0..n)
            .map(|i| (values[i] as u128) * (weights[i] as u128) / 10_000)
            .sum();
        let exact_num: u128 = (0..n)
            .map(|i| (values[i] as u128) * (weights[i] as u128))
            .sum();
        let exact_div = exact_num / 10_000;
        prop_assert!(aggregate <= exact_div + n as u128, "must not overcount");
        prop_assert!(exact_div.saturating_sub(aggregate) <= n as u128, "bounded error");
    }
}
```

### LiteSVM Assertion
```rust
let position = create_multi_collateral_position(&mut ctx, borrower).await;
deposit_collateral(&mut ctx, position, mint_a, 1_000_000).await.unwrap();
deposit_collateral(&mut ctx, position, mint_b, 2_000_000).await.unwrap();

let state = get_position_state(&ctx, position).await;
let expected = (1_000_000u128 * price_a as u128 * weight_a as u128 / 10_000
              + 2_000_000u128 * price_b as u128 * weight_b as u128 / 10_000) as u64;
assert!(state.aggregate_collateral <= expected + 2, "must not overcount collateral");
```

## Suggested Fix
```rust
pub fn aggregate_collateral(assets: &[CollateralAsset]) -> Result<u64> {
    let mut total: u128 = 0;
    for asset in assets {
        let weighted = (asset.value as u128)
            .checked_mul(asset.weight_bps as u128)
            .ok_or(LendingError::Overflow)?
            / 10_000;  // floor: never overvalue
        total = total.checked_add(weighted).ok_or(LendingError::Overflow)?;
    }
    require!(total <= u64::MAX as u128, LendingError::Overflow);
    Ok(total as u64)
}
```
