# VP-023: Unstake Penalty Calculation

**Category:** Staking Rewards
**Verification tool:** Kani

## What Can Go Wrong
Early unstaking penalties (e.g., 10% for withdrawing before lockup expires) can be miscalculated. Common bugs: penalty applied to rewards instead of principal, penalty percentage computed on wrong base amount, or penalty that exceeds remaining stake causing underflow.

## Why It Matters
If the penalty is too low, there's no incentive to stay staked, undermining protocol security (for PoS) or liquidity (for DeFi). If the penalty is too high or wraps due to underflow, users lose their entire stake.

## Real-World Incident
No specific public incident documented, but incorrect unstaking penalty calculations are common audit findings. Several Solana liquid staking protocols had penalty math bugs in their early versions.

## Invariant

### Formal Property
```
For early unstake with penalty_bps:
  penalty = stake_amount * penalty_bps / 10_000
  penalty <= stake_amount
  user_receives = stake_amount - penalty
  user_receives > 0 (assuming penalty_bps < 10_000)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_unstake_penalty_bounds() {
    let staked: u64 = kani::any();
    let penalty_bps: u16 = kani::any();

    kani::assume!(staked > 0);
    kani::assume!(penalty_bps > 0 && penalty_bps < 10_000); // < 100%

    let penalty = (staked as u128) * (penalty_bps as u128) / 10_000;

    kani::assert!(penalty < staked as u128, "penalty >= stake");
    kani::assert!(penalty > 0, "zero penalty with nonzero rate");

    let user_receives = (staked as u128) - penalty;
    kani::assert!(user_receives > 0);
    kani::assert!(user_receives < staked as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn penalty_within_bounds(
        staked in 1u64..u64::MAX,
        penalty_bps in 1u16..9_999
    ) {
        let penalty = calculate_penalty(staked, penalty_bps);
        prop_assert!(penalty < staked, "penalty {} >= stake {}", penalty, staked);
        prop_assert!(penalty > 0, "zero penalty");
        let receives = staked - penalty;
        prop_assert!(receives > 0, "user receives nothing");
    }
}
```

### LiteSVM Assertion
```rust
let staked = get_user_stake(&ctx, &user).await;
early_unstake(&mut ctx, &user, staked).await.unwrap();
let received = get_token_balance(&ctx, user_token).await;
let penalty_expected = staked as u128 * penalty_bps as u128 / 10_000;
assert!(received as u128 >= (staked as u128 - penalty_expected - 1));
```

## Suggested Fix
```rust
pub fn calculate_penalty(amount: u64, penalty_bps: u16) -> Result<u64> {
    require!(penalty_bps < 10_000, StakeError::PenaltyTooHigh);
    let penalty = (amount as u128) * (penalty_bps as u128) / 10_000;
    Ok(penalty as u64)
}
```
