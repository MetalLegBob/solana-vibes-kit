# VP-030: APY to Per-Slot Rate Conversion

**Category:** Interest/Yield
**Verification tool:** Kani

## What Can Go Wrong
Converting an annual rate to a per-slot rate requires dividing by slots_per_year (~150M on Solana). If the annual rate is small, the per-slot rate truncates to 0, meaning no interest accrues. If the conversion doesn't account for compounding, the actual APY diverges from the target.

## Why It Matters
A 1% APR with 150M slots/year gives ~0.0000000067% per slot. Stored as integer basis points, this truncates to 0. The protocol charges 0% interest — free borrowing.

## Real-World Incident
No specific public incident documented, but per-slot rate truncation is a well-known issue. All major Solana lending protocols use high-precision fixed-point math specifically to handle this conversion.

## Invariant

### Formal Property
```
rate_per_slot = annual_rate * PRECISION / SLOTS_PER_YEAR / BPS_DENOMINATOR
rate_per_slot > 0 for any annual_rate > 0
Reconstructed: (rate_per_slot * SLOTS_PER_YEAR * BPS_DENOMINATOR / PRECISION) ≈ annual_rate
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rate_conversion_roundtrip() {
    let annual_bps: u16 = kani::any();
    kani::assume!(annual_bps > 0 && annual_bps <= 10_000);

    let per_slot = (annual_bps as u128) * PRECISION / SLOTS_PER_YEAR as u128 / 10_000;

    // Per-slot rate must be non-zero
    kani::assert!(per_slot > 0, "per-slot rate truncated to 0");

    // Round-trip: reconstruct annual rate
    let reconstructed = per_slot * SLOTS_PER_YEAR as u128 * 10_000 / PRECISION;
    let diff = if reconstructed > annual_bps as u128 {
        reconstructed - annual_bps as u128
    } else {
        annual_bps as u128 - reconstructed
    };
    kani::assert!(diff <= 1, "round-trip error too large");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn rate_conversion_preserves_value(annual_bps in 1u16..10_000) {
        let per_slot = annual_to_per_slot(annual_bps);
        prop_assert!(per_slot > 0, "zero per-slot rate for {} bps annual", annual_bps);
        let reconstructed = per_slot_to_annual(per_slot);
        let diff = (reconstructed as i64 - annual_bps as i64).unsigned_abs();
        prop_assert!(diff <= 1, "roundtrip error: {} vs {}", annual_bps, reconstructed);
    }
}
```

### LiteSVM Assertion
```rust
// Set 1 bps annual rate (minimum meaningful rate)
set_rate(&mut ctx, 1).await.unwrap();
let per_slot = get_per_slot_rate(&ctx).await;
assert!(per_slot > 0, "1 bps annual truncated to 0 per-slot");
```

## Suggested Fix
```rust
const PRECISION: u128 = 1_000_000_000_000; // 10^12 for sub-lamport precision

pub fn annual_to_per_slot(annual_bps: u16) -> u128 {
    (annual_bps as u128) * PRECISION / SLOTS_PER_YEAR as u128 / 10_000
}
```
