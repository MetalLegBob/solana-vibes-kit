# VP-084: Intermediate Calculation Precision Loss

**Category:** Decimal Normalization
**Verification tool:** Kani

## What Can Go Wrong
When computing `value = amount * price / divisor`, the order of operations matters. `(amount * price) / divisor` can overflow in the multiplication. `amount * (price / divisor)` loses precision in the division. Using u128 intermediates solves the overflow but u128 itself can overflow for large values.

## Why It Matters
A value calculation that produces 0 due to premature division (price / divisor = 0 for small prices) means the protocol thinks the position is worthless. A calculation that overflows means the protocol thinks the position is worth near-zero (wrapped value).

## Real-World Incident
Intermediate precision loss has been documented in multiple Solana program audits. The SPL Token library uses u128 intermediates extensively to mitigate this.

## Invariant

### Formal Property
```
For value = amount * price / scale:
  Use u128: value = (amount as u128 * price as u128) / scale as u128
  value > 0 when amount > 0 and price > 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_intermediate_precision() {
    let amount: u64 = kani::any();
    let price: u64 = kani::any();
    let scale: u64 = kani::any();

    kani::assume!(amount > 0 && price > 0 && scale > 0);
    kani::assume!(scale <= 1_000_000_000_000);

    // Correct: multiply first in u128, then divide
    let correct = (amount as u128) * (price as u128) / (scale as u128);

    // Wrong: divide first, losing precision
    let wrong = (amount as u128) * ((price as u128) / (scale as u128));

    // Correct is always >= wrong
    kani::assert!(correct >= wrong);

    // Correct gives non-zero when inputs product > scale
    if (amount as u128) * (price as u128) >= (scale as u128) {
        kani::assert!(correct > 0, "precision loss zeroed the result");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn multiply_before_divide(
        amount in 1u64..1_000_000_000,
        price in 1u64..1_000_000_000,
        scale in 1u64..1_000_000_000
    ) {
        let correct = (amount as u128) * (price as u128) / (scale as u128);
        let wrong = amount as u128 * (price / scale) as u128;
        prop_assert!(correct >= wrong, "multiply-first gave less than divide-first");
    }
}
```

### LiteSVM Assertion
```rust
// Small amount * small price should still produce non-zero value
let value = compute_value(1000, 500, 1_000_000_000);
assert!(value > 0, "precision loss: 1000 * 500 / 10^9 should be non-zero in u128");
```

## Suggested Fix
```rust
/// Always multiply before dividing, using u128 intermediates
pub fn compute_value(amount: u64, price: u64, scale: u64) -> u64 {
    let result = (amount as u128)
        .checked_mul(price as u128)
        .expect("u128 overflow in value calc")
        / (scale as u128);
    result as u64
}
```
