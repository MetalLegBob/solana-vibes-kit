# VP-064: Auction Settlement Calculation

**Category:** Auction
**Verification tool:** LiteSVM

## What Can Go Wrong
When an auction settles, the winner must pay exactly the winning bid amount, all losing bidders must receive full refunds, and protocol fees must be deducted correctly. If the settlement allows a winner to also claim a refund, they get the item for free. If losing bids are not tracked individually, partial failures can lock funds permanently.

## Why It Matters
An attacker exploits settlement logic to claim a refund for a winning bid, or calls settle multiple times to double-claim. If refunds are processed in a loop without marking each as completed, a failing refund blocks all subsequent ones. The attacker can also manipulate bid ordering so settlement picks the wrong highest bid.

## Real-World Incident
The Metaplex auction V1 contract required a patch for settlement edge cases where the winner could reclaim their bid as if they were a losing bidder, effectively receiving both the item and a refund. Multiple Solana NFT audit reports have flagged missing double-claim guards in settlement instructions.

## Invariant

### Formal Property
```
For bids[] sorted descending, protocol fee_bps:
  seller_receives == bids[0] - fee
  forall i > 0: refund[i] == bids[i]
  sum(refunds) + winner_payment == sum(all_bids)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_settlement_accounting() {
    let winning_bid: u64 = kani::any();
    let losing_bid: u64 = kani::any();
    let fee_bps: u64 = kani::any();

    kani::assume!(winning_bid > 0 && winning_bid < 1_000_000_000);
    kani::assume!(losing_bid > 0 && losing_bid < winning_bid);
    kani::assume!(fee_bps <= 1_000);

    let total_in = winning_bid as u128 + losing_bid as u128;
    let fee = winning_bid as u128 * fee_bps as u128 / 10_000;
    let seller_gets = winning_bid as u128 - fee;

    kani::assert!(seller_gets + fee + losing_bid as u128 == total_in);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn settlement_funds_balanced(
        bids in prop::collection::vec(1u64..1_000_000_000, 2..=10),
        fee_bps in 0u64..1_000,
    ) {
        let mut sorted = bids.clone();
        sorted.sort_unstable_by(|a, b| b.cmp(a));
        let winning = sorted[0] as u128;
        let fee = winning * fee_bps as u128 / 10_000;
        let total_refunds: u128 = sorted[1..].iter().map(|b| *b as u128).sum();
        let total_in: u128 = bids.iter().map(|b| *b as u128).sum();
        prop_assert_eq!(winning - fee + fee + total_refunds, total_in);
    }
}
```

### LiteSVM Assertion
```rust
let auction = create_auction(&mut ctx, seller, reserve, fee_bps).await;
place_bid(&mut ctx, auction, bidder_a, 500_000).await.unwrap();
place_bid(&mut ctx, auction, bidder_b, 800_000).await.unwrap();
place_bid(&mut ctx, auction, bidder_c, 1_200_000).await.unwrap();

let pre = snapshot_balances(&ctx, &[seller, bidder_a, bidder_b]).await;
settle_auction(&mut ctx, auction).await.unwrap();
let post = snapshot_balances(&ctx, &[seller, bidder_a, bidder_b]).await;

let fee = 1_200_000u64 * fee_bps / 10_000;
assert_eq!(post[0] - pre[0], 1_200_000 - fee);  // seller receives
assert_eq!(post[1] - pre[1], 500_000);            // bidder_a refund
assert_eq!(post[2] - pre[2], 800_000);            // bidder_b refund
```

## Suggested Fix
```rust
pub fn settle_auction(ctx: Context<SettleAuction>) -> Result<()> {
    let auction = &mut ctx.accounts.auction;
    require!(auction.ended && !auction.settled, AuctionError::InvalidState);

    let fee = (auction.highest_bid as u128)
        .checked_mul(auction.fee_bps as u128).unwrap() / 10_000;
    let seller_amount = auction.highest_bid.checked_sub(fee as u64)
        .ok_or(AuctionError::Overflow)?;
    transfer_lamports(auction, &ctx.accounts.seller, seller_amount)?;
    transfer_lamports(auction, &ctx.accounts.fee_vault, fee as u64)?;
    for bid in auction.losing_bids.iter_mut() {
        require!(!bid.refunded, AuctionError::AlreadyRefunded);
        transfer_lamports(auction, &bid.bidder, bid.amount)?;
        bid.refunded = true;
    }
    auction.settled = true;
    Ok(())
}
```
