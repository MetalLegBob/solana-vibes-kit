# VP-081: Revenue Split Rounding Accumulation

**Category:** Royalty/Revenue Splits
**Verification tool:** Proptest

## What Can Go Wrong
Over many distributions, the rounding error from integer division in revenue splits accumulates. Each distribution can lose up to (num_recipients - 1) lamports to truncation. After N distributions the cumulative error reaches up to N * (num_recipients - 1) lamports. Without tracking, the contract becomes insolvent: the sum of all claimable balances exceeds the actual balance. The error consistently favors one direction (truncation rounds down), so it never cancels out.

## Why It Matters
A 5-recipient split processing 1,000 distributions per day loses up to 4 lamports per round. Over one year that is ~1.46M lamports. An attacker can amplify this by forcing many small distributions. If error is untracked, the last recipient to claim finds insufficient funds, creating a race condition among claimants.

## Real-World Incident
Rounding error accumulation has been identified as a medium-severity finding in multiple payment-splitter audits. The Saber protocol's StableSwap on Solana had a related rounding accumulation issue where repeated small swaps caused the invariant to drift, requiring a protocol upgrade.

## Invariant

### Formal Property
```
forall N distributions, n recipients:
  cumulative_error = sum(total_i - sum(payout_i_j) for i in 1..N)
  0 <= cumulative_error <= N * (n - 1)
  contract_balance == sum(claimable) + cumulative_tracked_error
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_single_distribution_error_bound() {
    let total: u64 = kani::any();
    let n: usize = kani::any();
    kani::assume!(total > 0 && total < 1_000_000_000);
    kani::assume!(n >= 2 && n <= 10);
    let share_bps: u16 = (10_000 / n as u32) as u16;
    let last_share: u16 = (10_000 - share_bps as u32 * (n as u32 - 1)) as u16;
    let mut paid: u64 = 0;
    for i in 0..n {
        let s = if i < n - 1 { share_bps } else { last_share };
        paid += (total as u128 * s as u128 / 10_000) as u64;
    }
    let error = total - paid;
    kani::assert!(error < n as u64);
    kani::assert!(paid + error == total);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn cumulative_error_bounded_over_1000_rounds(
        base_amount in 100u64..100_000,
        n in 2usize..=6,
        seed in prop::collection::vec(1u16..5000, 6)
    ) {
        let raw_sum: u32 = seed[..n].iter().map(|s| *s as u32).sum();
        let mut shares: Vec<u16> = seed[..n]
            .iter()
            .map(|s| ((*s as u32) * 10_000 / raw_sum) as u16)
            .collect();
        let partial: u32 = shares.iter().map(|s| *s as u32).sum();
        shares[n - 1] += (10_000u32 - partial) as u16;

        let mut cumulative_error: u64 = 0;
        for round in 0u64..1_000 {
            let total = base_amount + round;
            let paid: u64 = shares.iter()
                .map(|s| (total as u128 * *s as u128 / 10_000) as u64)
                .sum();
            cumulative_error += total - paid;
        }
        let max_error = 1_000u64 * (n as u64 - 1);
        prop_assert!(cumulative_error <= max_error,
            "error {} exceeds bound {}", cumulative_error, max_error);
    }
}
```

### LiteSVM Assertion
```rust
let shares = vec![3333u16, 3333, 3334];
let num_distributions = 100u64;
let mut total_deposited: u64 = 0;

for i in 0..num_distributions {
    let amount = 10_001 + i;
    total_deposited += amount;
    let ix = distribute(&program_id, &split_account, amount);
    process_transaction(&mut banks_client, ix, &payer).await.unwrap();
}
let bal_a = get_balance(&banks_client, &recipient_a).await;
let bal_b = get_balance(&banks_client, &recipient_b).await;
let bal_c = get_balance(&banks_client, &recipient_c).await;
let total_withdrawn = bal_a + bal_b + bal_c;
let state = get_split_state(&banks_client, &split_account).await;
assert_eq!(total_deposited, total_withdrawn + state.cumulative_rounding_error);
assert!(state.cumulative_rounding_error <= num_distributions * 2);
```

## Suggested Fix
```rust
pub struct SplitState {
    pub shares: Vec<u16>,
    pub cumulative_rounding_error: u64,
}

pub fn distribute_and_track(state: &mut SplitState, total: u64) -> Vec<u64> {
    let mut payouts: Vec<u64> = state.shares
        .iter()
        .map(|s| (total as u128).checked_mul(*s as u128).unwrap() / 10_000)
        .map(|v| v as u64)
        .collect();
    let paid: u64 = payouts.iter().sum();
    let dust = total.checked_sub(paid).unwrap();
    if let Some(last) = payouts.last_mut() {
        *last = last.checked_add(dust).unwrap();
    }
    state.cumulative_rounding_error = state.cumulative_rounding_error
        .checked_add(dust).unwrap();
    payouts
}
```
