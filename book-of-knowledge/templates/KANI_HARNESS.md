# Kani Harness Template

Use this template to generate Kani formal verification harnesses for Solana program math.

## Template Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `{FUNCTION_NAME}` | Snake_case function name | `calculate_swap_output` |
| `{MODULE_PATH}` | Rust module path for imports | `crate::math::swap` |
| `{PROPERTY_NAME}` | Snake_case property being verified | `conservation_of_value` |
| `{UNWIND_BOUND}` | Loop unwind depth | `10` |
| `{PRECONDITIONS}` | `kani::assume!()` calls | See below |
| `{POSTCONDITIONS}` | `kani::assert!()` calls | See below |
| `{FUNCTION_CALL}` | Actual function invocation | `calculate_swap_output(input_amount, reserve_a, reserve_b)` |

## Base Template

```rust
// BOK Verification Harness — {FUNCTION_NAME}
// Property: {PROPERTY_NAME}
// Generated by Book of Knowledge

#[cfg(kani)]
mod bok_kani_{FUNCTION_NAME} {
    use {MODULE_PATH}::*;

    #[kani::proof]
    #[kani::unwind({UNWIND_BOUND})]
    fn verify_{PROPERTY_NAME}() {
        // Symbolic inputs — Kani checks ALL possible values within bounds
        {SYMBOLIC_INPUTS}

        // Preconditions — realistic input constraints
        {PRECONDITIONS}

        // Execute the function under verification
        let result = {FUNCTION_CALL};

        // Postconditions — the property that must hold
        {POSTCONDITIONS}
    }
}
```

## Common Patterns

### Overflow Check

```rust
#[kani::proof]
#[kani::unwind(1)]
fn verify_no_overflow_{FUNCTION_NAME}() {
    let a: u64 = kani::any();
    let b: u64 = kani::any();

    // Bound inputs to realistic ranges
    kani::assume!(a > 0 && a <= 1_000_000_000_000); // max ~1T tokens
    kani::assume!(b > 0 && b <= 1_000_000_000_000);

    // The function must not panic from overflow
    let result = {FUNCTION_NAME}(a, b);

    // Result must be within expected bounds
    kani::assert!(result <= u64::MAX);
}
```

### Division-by-Zero

```rust
#[kani::proof]
#[kani::unwind(1)]
fn verify_no_div_zero_{FUNCTION_NAME}() {
    let numerator: u64 = kani::any();
    let denominator: u64 = kani::any();

    kani::assume!(numerator > 0);
    // NOTE: Do NOT assume denominator > 0 — we're checking the function handles it
    // If the function should reject zero, verify it does so safely (returns error, not panic)

    let result = {FUNCTION_NAME}(numerator, denominator);
    // Function must return a valid result or error, never panic
}
```

### Rounding Direction

```rust
#[kani::proof]
#[kani::unwind(1)]
fn verify_rounding_favors_protocol_{FUNCTION_NAME}() {
    let amount: u64 = kani::any();
    let rate_bps: u64 = kani::any();

    kani::assume!(amount > 0 && amount <= 1_000_000_000_000);
    kani::assume!(rate_bps > 0 && rate_bps <= 10_000); // 0-100%

    let fee = {FUNCTION_NAME}(amount, rate_bps);

    // Fee must never be zero when amount and rate are both nonzero
    // (rounding toward zero would shortchange the protocol)
    kani::assert!(fee > 0);

    // Fee must never exceed the principal
    kani::assert!(fee <= amount);
}
```

### Precision Loss

```rust
#[kani::proof]
#[kani::unwind(1)]
fn verify_precision_{FUNCTION_NAME}() {
    let amount: u128 = kani::any();
    kani::assume!(amount > 0 && amount <= u128::from(u64::MAX));

    // Convert to different decimal precision and back
    let scaled = {FUNCTION_NAME}_scale_up(amount);
    let restored = {FUNCTION_NAME}_scale_down(scaled);

    // Round-trip must not lose more than 1 unit (acceptable rounding)
    let diff = if restored > amount { restored - amount } else { amount - restored };
    kani::assert!(diff <= 1);
}
```

### Conservation of Value

```rust
#[kani::proof]
#[kani::unwind(1)]
fn verify_conservation_{FUNCTION_NAME}() {
    let input_amount: u64 = kani::any();
    let reserve_a: u64 = kani::any();
    let reserve_b: u64 = kani::any();

    kani::assume!(input_amount > 0 && input_amount <= 1_000_000_000_000);
    kani::assume!(reserve_a > 0 && reserve_a <= 1_000_000_000_000);
    kani::assume!(reserve_b > 0 && reserve_b <= 1_000_000_000_000);

    let (output_amount, fee) = {FUNCTION_NAME}(input_amount, reserve_a, reserve_b);

    // Total value must be conserved: input = output + fee
    kani::assert!(output_amount + fee == input_amount || output_amount + fee + 1 == input_amount);
    // Allow off-by-one for rounding, but no more
}
```

## Kani Tips

- Start with `#[kani::unwind(10)]` — increase if Kani reports incomplete unwinding
- Use `kani::any()` for symbolic inputs, `kani::assume!()` to bound them
- Kani verifies ALL values within bounds — if it passes, the property is proven
- For functions that return `Result`, handle both Ok and Err paths
- Kani doesn't support all Rust features (e.g., no async, limited trait objects)
- For Anchor types: create concrete test instances, don't try to make them symbolic
