# VP-055: Partial Liquidation Fairness

**Category:** Liquidation
**Verification tool:** Kani

## What Can Go Wrong
Partial liquidation allows a liquidator to repay a fraction of a borrower debt and seize proportional collateral plus a bonus. Rounding errors or incorrect fraction calculations can result in the liquidator seizing more collateral than proportional to debt repaid, or the borrower remaining position having a worse health factor after partial liquidation than before.

## Why It Matters
If partial liquidation is not proportional, a liquidator can repeatedly perform small partial liquidations, each time extracting slightly more collateral than deserved. Over many iterations, this drains the borrower collateral faster than debt decreases. The borrower position deteriorates with each liquidation instead of improving.

## Real-World Incident
Various lending protocol liquidation bugs. Compound V2 had issues where partial liquidation close factors interacted poorly with bonus calculations, allowing liquidators to extract disproportionate value.

## Invariant

### Formal Property
```
forall debt_repaid, total_debt, total_collateral, bonus_bps:
  seized = (debt_repaid / total_debt) * total_collateral * (10000 + bonus_bps) / 10000
  health_factor_after >= health_factor_before OR position_fully_liquidated
```

### Kani Precondition/Postcondition
```rust
kani::assume!(debt_repaid > 0 && debt_repaid <= total_debt);
kani::assume!(total_debt > 0 && total_debt <= u64::MAX / 20000);
kani::assume!(total_collateral > 0 && total_collateral <= u64::MAX / 20000);
kani::assume!(bonus_bps > 0 && bonus_bps <= 2000);
let seized = (debt_repaid as u128) * (total_collateral as u128)
    * (10000u128 + bonus_bps as u128) / ((total_debt as u128) * 10000u128);
kani::assert!(seized <= total_collateral as u128);
let rem_c = total_collateral as u128 - seized;
let rem_d = total_debt as u128 - debt_repaid as u128;
if rem_d > 0 {
    let hf_before = (total_collateral as u128 * 10000) / (total_debt as u128);
    let hf_after = (rem_c * 10000) / rem_d;
    kani::assert!(hf_after >= hf_before);
}
```

### Proptest Property
```rust
proptest! {{
    #[test]
    fn partial_liquidation_fairness(
        total_debt in 1000u64..=1_000_000_000,
        total_collateral in 1000u64..=1_000_000_000,
        close_factor_bps in 1000u16..=5000u16,
        bonus_bps in 100u16..=1500u16
    ) {{
        let debt_repaid = (total_debt as u128 * close_factor_bps as u128 / 10000) as u64;
        let seized = compute_partial_liq(debt_repaid, total_debt, total_collateral, bonus_bps).unwrap();
        prop_assert!(seized <= total_collateral);
        let rem_c = total_collateral - seized;
        let rem_d = total_debt - debt_repaid;
        if rem_d > 0 {{
            let ratio_before = total_collateral as f64 / total_debt as f64;
            let ratio_after = rem_c as f64 / rem_d as f64;
            prop_assert!(ratio_after >= ratio_before * 0.999);
        }}
    }}
}}
```

### LiteSVM Assertion
```rust
let hf_before = get_health_factor(&ctx, borrower);
partial_liquidate(&mut ctx, liquidator, borrower, close_factor_bps);
let hf_after = get_health_factor(&ctx, borrower);
assert!(hf_after >= hf_before || get_debt(&ctx, borrower) == 0);
```

## Suggested Fix
```rust
pub fn compute_partial_liq(
    debt_repaid: u64, total_debt: u64, total_collateral: u64, bonus_bps: u16,
) -> Result<u64, ProgramError> {{
    require!(debt_repaid <= total_debt, "Repay exceeds debt");
    let num = (debt_repaid as u128)
        .checked_mul(total_collateral as u128)?
        .checked_mul(10000u128 + bonus_bps as u128)?;
    let den = (total_debt as u128).checked_mul(10000u128)?;
    let seized = (num / den) as u64; // Round DOWN to protect borrower
    require!(seized <= total_collateral, "Seized exceeds collateral");
    Ok(seized)
}}
```
