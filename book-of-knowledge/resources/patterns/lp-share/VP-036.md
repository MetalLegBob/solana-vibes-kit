# VP-036: First Depositor Edge Case

**Category:** LP Share
**Verification tool:** LiteSVM

## What Can Go Wrong
The first depositor in a pool sets the initial exchange rate between deposits and shares. If they deposit a tiny amount (e.g., 1 lamport), then donate tokens directly to the pool vault, the share price inflates. The next depositor's deposit (possibly large) rounds to 0 shares due to the inflated price. The first depositor then redeems their 1 share for all tokens.

## Why It Matters
This is the classic "ERC-4626 inflation attack" adapted to Solana. An attacker with minimal capital can steal all subsequent deposits until the pool reaches sufficient depth.

## Real-World Incident
The vault share inflation attack is one of DeFi's most well-documented vulnerabilities. OpenZeppelin's ERC-4626 documentation explicitly warns about this "Security concern." The attack was demonstrated in the Resupply exploit, and multiple Uniswap V2-style AMM forks on Solana have been flagged for lacking the dead shares mitigation (burning initial LP tokens to address(0)).

## Invariant

### Formal Property
```
For first deposit:
  shares_minted >= MINIMUM_SHARES (e.g., 1000)
OR
  virtual_reserves > 0 (preventing initial manipulation)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_first_deposit_safe() {
    let first_deposit: u64 = kani::any();
    kani::assume!(first_deposit > 0);

    let shares = if first_deposit >= MINIMUM_INITIAL_DEPOSIT {
        first_deposit // 1:1 for first deposit
    } else {
        0 // rejected
    };

    if shares > 0 {
        kani::assert!(shares >= MINIMUM_SHARES);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn first_deposit_minimum_enforced(first_deposit in 1u64..1_000_000_000) {
        let result = initialize_pool(first_deposit);
        match result {
            Ok(shares) => {
                prop_assert!(shares >= MINIMUM_SHARES);
                prop_assert!(first_deposit >= MINIMUM_INITIAL_DEPOSIT);
            }
            Err(_) => prop_assert!(first_deposit < MINIMUM_INITIAL_DEPOSIT),
        }
    }
}
```

### LiteSVM Assertion
```rust
// Attack: deposit 1 lamport, donate 1M tokens, then deposit as victim
deposit(&mut ctx, &attacker, 1).await.unwrap();
// Donate tokens directly to vault (not via deposit)
transfer_to_vault(&mut ctx, &attacker, 1_000_000).await.unwrap();
// Victim deposits 500K
let result = deposit(&mut ctx, &victim, 500_000).await;
if result.is_ok() {
    let victim_shares = get_user_shares(&ctx, &victim).await;
    assert!(victim_shares > 0, "victim got 0 shares (inflation attack succeeded)");
}
```

## Suggested Fix
```rust
pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    if pool.total_shares == 0 {
        // First deposit: enforce minimum and use virtual offset
        require!(amount >= MINIMUM_INITIAL_DEPOSIT, PoolError::DepositTooSmall);
        // Mint shares with virtual offset to prevent inflation attack
        let shares = amount + VIRTUAL_OFFSET; // e.g., VIRTUAL_OFFSET = 1000
        pool.total_shares = shares;
        pool.virtual_offset = VIRTUAL_OFFSET;
    } else {
        let shares = (amount as u128) * (pool.total_shares as u128)
            / (pool.total_value() as u128);
        require!(shares > 0, PoolError::DepositTooSmall);
        pool.total_shares += shares as u64;
    }
    Ok(())
}
```
