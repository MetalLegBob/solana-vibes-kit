# VP-057: Linear Vesting Unlock Correctness

**Category:** Vesting
**Verification tool:** Kani

## What Can Go Wrong
Linear vesting calculates unlocked tokens as `total_grant * elapsed_time / total_duration`. Integer division truncates the result, and if the numerator overflows u64 before division, the unlocked amount wraps to zero or produces a wildly incorrect value. Users receive far fewer tokens than entitled, or the unlock curve becomes non-linear with sudden jumps at certain timestamps where the arithmetic happens to work differently.

## Why It Matters
An attacker or protocol bug creates a vesting schedule with a very large grant amount. When `elapsed_time` is small, the multiplication `total_grant * elapsed` overflows u64 before the division occurs, producing a nonsensical result. A beneficiary could be permanently locked out of their tokens, receive them all at once at an unexpected time, or exploit the overflow to claim more than allocated.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Multiple Solana vesting contract audits have flagged u64 overflow in linear unlock calculations as high-severity findings. The pattern appears in any contract computing proportional amounts with large token supplies.

## Invariant

### Formal Property
```
forall total_grant, elapsed, duration:
  unlocked = total_grant * elapsed / duration
  unlocked <= total_grant AND
  unlocked(duration) = total_grant AND
  unlocked(t+1) >= unlocked(t)  // monotonically non-decreasing
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_linear_vesting() {
    let total_grant: u64 = kani::any();
    let elapsed: u64 = kani::any();
    let duration: u64 = kani::any();

    kani::assume!(total_grant > 0 && total_grant <= u64::MAX);
    kani::assume!(duration > 0);
    kani::assume!(elapsed <= duration);

    let unlocked = (total_grant as u128)
        .checked_mul(elapsed as u128).unwrap()
        / (duration as u128);

    kani::assert!(unlocked <= total_grant as u128, "unlocked exceeds grant");
    kani::assert!(
        elapsed != duration || unlocked == total_grant as u128,
        "full duration must unlock full grant"
    );
    kani::assert!(elapsed != 0 || unlocked == 0, "zero elapsed must unlock zero");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn linear_vesting_correctness(
        grant in 1u64..=10_000_000_000,
        duration in 1u64..=315_360_000,   // up to 10 years in seconds
        elapsed_pct in 0u64..=100
    ) {
        let elapsed = (duration as u128 * elapsed_pct as u128 / 100) as u64;
        let unlocked = linear_unlock(grant, elapsed, duration).unwrap();

        prop_assert!(unlocked <= grant, "unlocked {} > grant {}", unlocked, grant);

        if elapsed == duration {
            prop_assert_eq!(unlocked, grant, "full duration did not unlock full grant");
        }
        if elapsed == 0 {
            prop_assert_eq!(unlocked, 0, "zero elapsed unlocked non-zero");
        }

        // Monotonicity: unlocking one second later should never decrease
        if elapsed < duration {
            let next = linear_unlock(grant, elapsed + 1, duration).unwrap();
            prop_assert!(next >= unlocked, "non-monotonic: {} < {}", next, unlocked);
        }
    }
}
```

### LiteSVM Assertion
```rust
let schedule = create_vesting_schedule(&mut ctx, admin, beneficiary, grant, start_ts, duration);

// Warp to 25%, 50%, 75%, and 100% of vesting duration
for pct in [25u64, 50, 75, 100] {
    let warp_ts = start_ts + (duration * pct / 100);
    ctx.warp_to_timestamp(warp_ts);

    let claimable = get_claimable_amount(&ctx, schedule);
    let expected = (grant as u128 * pct as u128 / 100) as u64;

    assert!(claimable <= grant, "claimable {} exceeds grant {}", claimable, grant);
    // Allow 1 token rounding tolerance
    assert!(
        claimable.abs_diff(expected) <= 1,
        "at {}%: claimable {} deviates from expected {}", pct, claimable, expected
    );
}

// At full duration, must unlock exactly the full grant
ctx.warp_to_timestamp(start_ts + duration);
let final_claimable = get_claimable_amount(&ctx, schedule);
assert_eq!(final_claimable, grant, "full duration did not unlock full grant");
```

## Suggested Fix
```rust
pub fn linear_unlock(total_grant: u64, elapsed: u64, duration: u64) -> Result<u64> {
    require!(duration > 0, VestingError::ZeroDuration);

    if elapsed >= duration {
        return Ok(total_grant);
    }

    // Use u128 to prevent overflow on large grants
    let unlocked = (total_grant as u128)
        .checked_mul(elapsed as u128)
        .ok_or(VestingError::Overflow)?
        / (duration as u128);

    // Safety: result is <= total_grant which fits in u64
    Ok(unlocked as u64)
}
```
