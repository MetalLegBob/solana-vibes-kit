# VP-001: Conservation of Value in Constant-Product Swap

**Category:** Token Swaps
**Verification tool:** All

## What Can Go Wrong
A constant-product AMM must ensure total value entering the pool equals total value leaving, adjusted for fees. If the conservation equation is violated due to rounding errors, incorrect fee subtraction, or flawed math, tokens can be created from thin air or silently destroyed.

## Why It Matters
An attacker who discovers a conservation violation can repeatedly swap in a loop, extracting a small surplus each iteration. With flash loans providing volume, even 1-wei discrepancies per swap compound into complete pool drains.

## Real-World Incident
Numerous AMM exploits involved conservation violations. Many Uniswap V2 forks on BSC/Polygon had faulty fee math breaking conservation, allowing arbitrage bots to drain pools over hours.

## Invariant

### Formal Property
```
For pool (x, y), fee rate f, input Δx:
  Δx_net = Δx * (1 - f)
  x_new * y_new >= x_old * y_old
  Δy = y_old - (x_old * y_old) / (x_old + Δx_net)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_conservation_of_value() {
    let x: u64 = kani::any();
    let y: u64 = kani::any();
    let input: u64 = kani::any();
    let fee_bps: u64 = kani::any();

    kani::assume!(x > 1_000_000 && x < u64::MAX / 2);
    kani::assume!(y > 1_000_000 && y < u64::MAX / 2);
    kani::assume!(input > 0 && input < x);
    kani::assume!(fee_bps > 0 && fee_bps <= 10_000);

    let k_before = (x as u128) * (y as u128);
    let net = input as u128 * (10_000 - fee_bps) as u128 / 10_000;
    let output = (y as u128) * net / ((x as u128) + net);
    let k_after = ((x as u128) + (input as u128)) * ((y as u128) - output);

    kani::assert!(k_after >= k_before);
    kani::assert!(output < y as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn conservation_holds(
        x in 1_000_000u64..1_000_000_000,
        y in 1_000_000u64..1_000_000_000,
        input in 1u64..100_000_000,
        fee_bps in 1u64..300
    ) {
        let k_before = (x as u128) * (y as u128);
        let net = (input as u128) * (10_000 - fee_bps) as u128 / 10_000;
        let output = (y as u128) * net / ((x as u128) + net);
        let k_after = ((x as u128) + (input as u128)) * ((y as u128) - output);
        prop_assert!(k_after >= k_before);
    }
}
```

### LiteSVM Assertion
```rust
let pool_before = get_pool_state(&banks_client, pool_key).await;
let k_before = pool_before.reserve_a as u128 * pool_before.reserve_b as u128;

process_transaction(&mut banks_client, swap_ix, &payer).await.unwrap();

let pool_after = get_pool_state(&banks_client, pool_key).await;
let k_after = pool_after.reserve_a as u128 * pool_after.reserve_b as u128;
assert!(k_after >= k_before, "k-invariant violated");
```

## Suggested Fix
```rust
let k_before = (pool.reserve_x as u128).checked_mul(pool.reserve_y as u128)?;
let new_x = (pool.reserve_x as u128) + (input_after_fee as u128);
let new_y = k_before / new_x; // floor division favors pool
let output = (pool.reserve_y as u128) - new_y;
let k_after = ((pool.reserve_x as u128) + (input as u128)) * new_y;
require!(k_after >= k_before, SwapError::KInvariantViolated);
```
