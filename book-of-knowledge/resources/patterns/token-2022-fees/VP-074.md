# VP-074: Transfer Fee Basis Point Precision

**Category:** Token-2022 Fees
**Verification tool:** Kani

## What Can Go Wrong
Token-2022 transfer fees are calculated as `amount * fee_bps / 10000`. If the division truncates (rounds down), tiny transfers produce zero fees, allowing attackers to split large transfers into dust-sized pieces that each pay no fee. The fee must use ceiling division so that any nonzero amount with a nonzero fee rate always produces at least 1 lamport of fee. Additionally, the multiplication `amount * fee_bps` can overflow u64 when amount is large, silently producing a wrong fee.

## Why It Matters
An attacker splits a 1,000,000 token transfer into 10,000 transfers of 100 tokens each. At 50 bps (0.5%), the fee per 100-token transfer is 0.5 tokens, which rounds to 0 under floor division. The attacker moves the full million tokens paying zero total fees, while honest users who transfer in bulk pay the full 0.5%. This systematically drains protocol fee revenue and gives sophisticated users an unfair advantage.

## Real-World Incident
No single named exploit, but transfer fee rounding issues are among the most common findings in Token-2022 extension audits on Solana. The SPL Token-2022 reference implementation explicitly uses ceiling division for this reason. Multiple third-party token programs have been found using floor division during audits.

## Invariant

### Formal Property
```
For amount > 0, fee_bps > 0, fee_bps <= 10000:
  fee = ceil(amount * fee_bps / 10000)
  fee >= 1                          (no zero fees on nonzero inputs)
  fee <= amount                     (fee cannot exceed transfer amount)
  fee * 10000 >= amount * fee_bps   (ceiling property)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_transfer_fee_precision() {
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(amount > 0 && amount <= 10_000_000_000_000_000_000);
    kani::assume!(fee_bps > 0 && fee_bps <= 10_000);

    let numerator = (amount as u128) * (fee_bps as u128);
    let fee_ceil = (numerator + 9_999) / 10_000;  // ceiling division
    let fee_floor = numerator / 10_000;

    kani::assert!(fee_ceil >= 1);               // never zero
    kani::assert!(fee_ceil >= fee_floor);        // ceil >= floor
    kani::assert!(fee_ceil <= amount as u128);   // fee <= amount
    kani::assert!(fee_ceil * 10_000 >= numerator); // ceiling property
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_never_zero_on_nonzero_inputs(
        amount in 1u64..10_000_000_000,
        fee_bps in 1u16..=10_000
    ) {
        let numerator = (amount as u128) * (fee_bps as u128);
        let fee_ceil = ((numerator + 9_999) / 10_000) as u64;
        let fee_floor = (numerator / 10_000) as u64;

        prop_assert!(fee_ceil >= 1, "zero fee for amount={}, bps={}", amount, fee_bps);
        prop_assert!(fee_ceil >= fee_floor, "ceil < floor");
        prop_assert!(fee_ceil <= amount, "fee {} exceeds amount {}", fee_ceil, amount);
    }
}
```

### LiteSVM Assertion
```rust
// Transfer 1 lamport with 1 bps fee -- fee must be 1 (ceil), not 0 (floor)
let amount: u64 = 1;
let fee_bps: u16 = 1;
process_transaction(&mut banks_client, transfer_ix(amount), &payer).await.unwrap();
let withheld = get_withheld_fees(&banks_client, token_account).await;
assert_eq!(withheld, 1, "fee on 1 lamport at 1 bps must ceil to 1");

// Transfer 199 tokens at 50 bps: floor=0.995->0, ceil=1
let amount2: u64 = 199;
process_transaction(&mut banks_client, transfer_ix(amount2), &payer).await.unwrap();
let withheld2 = get_withheld_fees(&banks_client, token_account).await;
assert!(withheld2 >= 1, "small transfer must still pay at least 1 lamport fee");
```

## Suggested Fix
```rust
pub fn calculate_transfer_fee(amount: u64, fee_bps: u16) -> Result<u64> {
    if fee_bps == 0 {
        return Ok(0);
    }
    let numerator = (amount as u128)
        .checked_mul(fee_bps as u128)
        .ok_or(TokenError::Overflow)?;
    // Ceiling division: (a + b - 1) / b
    let fee = (numerator + 9_999) / 10_000;
    Ok(fee.min(amount as u128) as u64) // fee capped at amount
}
```
