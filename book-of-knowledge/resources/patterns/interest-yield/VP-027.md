# VP-027: Continuous vs Discrete Compounding Divergence

**Category:** Interest/Yield
**Verification tool:** Proptest

## What Can Go Wrong
Lending protocols often advertise APY assuming continuous compounding (e^(rt)) but implement discrete compounding (per-slot or per-block). The divergence between continuous and discrete grows with the interest rate and compounding frequency. If the implementation doesn't match the specification, yields are wrong.

## Why It Matters
Users expecting continuous compounding APY may receive significantly less. At high rates (common in DeFi), the difference between continuous and discrete compounding can be several percentage points annually.

## Real-World Incident
Solend and other Solana lending protocols explicitly document their compounding methodology. Early DeFi protocols on Ethereum (Compound V1) had divergence between advertised and actual rates due to block-time variability.

## Invariant

### Formal Property
```
For discrete compounding with rate r per period over N periods:
  discrete = principal * (1 + r)^N
  continuous = principal * e^(r*N)
  |discrete - continuous| / principal <= expected_divergence(r, N)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_compounding_divergence_bounded() {
    let principal: u64 = kani::any();
    let rate_bps: u16 = kani::any();

    kani::assume!(principal > 1_000_000 && principal < 1_000_000_000);
    kani::assume!(rate_bps > 0 && rate_bps <= 100);

    // Single period: discrete = principal * (1 + r)
    let discrete = (principal as u128) + (principal as u128) * (rate_bps as u128) / 10_000;

    kani::assert!(discrete >= principal as u128);
    kani::assert!(discrete < (principal as u128) * 2); // rate < 100%
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn discrete_vs_continuous_divergence_bounded(
        principal in 1_000_000u64..1_000_000_000,
        annual_rate_bps in 100u16..5000, // 1%-50% APR
        slots_per_year in 100_000u64..200_000_000
    ) {
        let rate_per_slot = (annual_rate_bps as f64) / 10_000.0 / (slots_per_year as f64);
        let discrete = (principal as f64) * (1.0 + rate_per_slot).powi(slots_per_year as i32);
        let continuous = (principal as f64) * (rate_per_slot * slots_per_year as f64).exp();
        let divergence = ((discrete - continuous) / principal as f64).abs();
        prop_assert!(divergence < 0.001, "divergence {} too large", divergence);
    }
}
```

### LiteSVM Assertion
```rust
let initial = get_deposit_balance(&ctx, &user).await;
advance_slots(&mut ctx, SLOTS_PER_YEAR).await;
accrue_interest(&mut ctx).await.unwrap();
let final_balance = get_deposit_balance(&ctx, &user).await;
let actual_rate = (final_balance as f64 / initial as f64) - 1.0;
let expected_rate = annual_rate_bps as f64 / 10_000.0;
assert!((actual_rate - expected_rate).abs() < 0.01, "rate divergence too large");
```

## Suggested Fix
```rust
/// Document compounding method explicitly
/// This implementation uses per-slot discrete compounding
pub fn accrue_interest(market: &mut Market, slots_elapsed: u64) -> Result<()> {
    let rate_per_slot = market.annual_rate as u128 * PRECISION
        / (SLOTS_PER_YEAR as u128) / 10_000;
    for _ in 0..slots_elapsed.min(MAX_CATCH_UP_SLOTS) {
        market.cumulative_borrow_rate = market.cumulative_borrow_rate
            + market.cumulative_borrow_rate * rate_per_slot / PRECISION;
    }
    Ok(())
}
```
