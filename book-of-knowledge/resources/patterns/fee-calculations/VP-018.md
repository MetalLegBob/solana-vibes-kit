# VP-018: Dynamic Fee Update Race Condition

**Category:** Fee Calculations
**Verification tool:** LiteSVM

## What Can Go Wrong
When a protocol allows dynamic fee updates (governance changes fee rate), transactions in-flight at the moment of update may use the old or new rate non-deterministically. If the fee is read before the update but applied after, or vice versa, users can be overcharged or undercharged relative to what they expected.

## Why It Matters
Governance can front-run users by submitting a fee increase just before a large swap. Or users can front-run governance by submitting swaps just before a fee increase takes effect. Neither scenario is fair.

## Real-World Incident
Fee update race conditions have been documented in Uniswap governance proposals. Solana's parallel transaction execution makes this especially relevant â€” two transactions in the same slot can see different fee states.

## Invariant

### Formal Property
```
For transaction T submitted when fee = F_old:
  T must execute with fee = F_old OR revert
  Fee updates take effect only for transactions submitted AFTER the update
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_consistency_within_tx() {
    let fee_at_start: u16 = kani::any();
    let fee_at_end: u16 = kani::any();

    kani::assume!(fee_at_start > 0 && fee_at_start <= 10_000);
    kani::assume!(fee_at_end > 0 && fee_at_end <= 10_000);

    // Within a single transaction, fee must be consistent
    // The fee used for calculation must equal fee read at instruction start
    kani::assert!(fee_at_start == fee_at_start); // tautology showing intent
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_update_doesnt_affect_inflight(
        old_fee in 1u16..300,
        new_fee in 1u16..300,
        amount in 1_000u64..1_000_000_000
    ) {
        // Simulate: read fee, update fee, apply fee
        let fee_read = old_fee;
        // Even if pool.fee_bps changes between read and apply,
        // the transaction should use the read value
        let applied_fee = calculate_fee(amount, fee_read);
        let expected_fee = calculate_fee(amount, old_fee);
        prop_assert_eq!(applied_fee, expected_fee);
    }
}
```

### LiteSVM Assertion
```rust
// Transaction 1: Start swap (reads fee)
// Transaction 2: Update fee
// Verify swap used old fee, not new fee
let pool_fee_before = get_pool_fee(&ctx).await;
let swap_tx = build_swap_ix(amount, 0);
let update_tx = build_update_fee_ix(new_fee_bps);

// Execute update THEN swap in same slot
process_transaction(&mut ctx, update_tx, &admin).await.unwrap();
process_transaction(&mut ctx, swap_tx, &user).await.unwrap();

// Swap should have used the new fee since it executed after update
let expected_output = calc_output_with_fee(amount, new_fee_bps);
let actual_output = get_user_received(&ctx).await;
assert_eq!(actual_output, expected_output, "fee inconsistency");
```

## Suggested Fix
```rust
pub fn swap(ctx: Context<Swap>, amount: u64, min_output: u64) -> Result<()> {
    // Read fee ONCE at instruction start, use it throughout
    let fee_bps = ctx.accounts.pool.fee_bps;
    let fee = fee_ceil(amount, fee_bps);
    let input_after_fee = amount.checked_sub(fee)?;
    let output = calculate_output(&ctx.accounts.pool, input_after_fee)?;
    require!(output >= min_output, SwapError::SlippageExceeded);
    // ... execute with consistent fee
    Ok(())
}
```
