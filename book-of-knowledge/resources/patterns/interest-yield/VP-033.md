# VP-033: Yield Harvest Rounding

**Category:** Interest/Yield
**Verification tool:** Kani

## What Can Go Wrong
When users harvest yield, the amount is computed from an accumulator. If floor division is used, the protocol keeps the dust. If ceiling division is used, the protocol may pay out more than it has. The rounding direction must be consistent and in the protocol's favor for payouts.

## Why It Matters
Ceiling-rounded payouts mean each harvest takes slightly more than earned. With many users, the cumulative overpayment drains the yield reserve. The last users to harvest find the vault empty.

## Real-World Incident
ERC-4626 vault standard explicitly specifies rounding direction (favor the vault on withdrawals). Multiple vault implementations on Solana had rounding bugs that created small insolvencies over time.

## Invariant

### Formal Property
```
For yield payout:
  payout = floor(user_share * accumulated_yield / PRECISION)
  payout rounds DOWN (protocol keeps dust)
  Î£(all payouts) <= total yield generated
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_harvest_rounds_down() {
    let accumulated: u128 = kani::any();
    let user_share: u64 = kani::any();
    let total_shares: u64 = kani::any();

    kani::assume!(accumulated > 0 && accumulated < u128::MAX / 2);
    kani::assume!(user_share > 0 && user_share <= total_shares);
    kani::assume!(total_shares > 0);

    let payout = accumulated * (user_share as u128) / (total_shares as u128); // floor

    // Payout must not exceed user's proportional share (rounded up)
    let max_payout = (accumulated * (user_share as u128) + (total_shares as u128) - 1) / (total_shares as u128);
    kani::assert!(payout <= max_payout);
    kani::assert!(payout <= accumulated);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn harvest_floor_preserves_solvency(
        total_yield in 1_000u64..1_000_000_000,
        shares in prop::collection::vec(1u64..1_000_000, 2..=50)
    ) {
        let total_shares: u64 = shares.iter().sum();
        let total_paid: u128 = shares.iter()
            .map(|&s| (total_yield as u128) * (s as u128) / (total_shares as u128))
            .sum();
        prop_assert!(total_paid <= total_yield as u128,
            "total payouts {} > yield {}", total_paid, total_yield);
    }
}
```

### LiteSVM Assertion
```rust
let vault_before = get_token_balance(&ctx, yield_vault).await;
// All users harvest
for user in &all_users {
    harvest(&mut ctx, user).await.unwrap();
}
let vault_after = get_token_balance(&ctx, yield_vault).await;
assert!(vault_after >= 0, "vault drained below 0");
```

## Suggested Fix
```rust
pub fn harvest(user: &mut UserAccount, pool: &Pool) -> Result<u64> {
    let gross = pool.yield_per_share * (user.shares as u128) / PRECISION;
    let payout = gross.saturating_sub(user.yield_debt); // floor, never negative
    user.yield_debt = gross;
    Ok(payout as u64) // truncated to u64 = floor
}
```
