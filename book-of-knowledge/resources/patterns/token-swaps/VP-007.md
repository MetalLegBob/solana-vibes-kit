# VP-007: Virtual Reserve Manipulation

**Category:** Token Swaps
**Verification tool:** LiteSVM

## What Can Go Wrong
Some AMMs use virtual reserves (amplified reserves) to concentrate liquidity around a target price. If virtual reserves drift from actual token balances, the pool's pricing becomes detached from reality. An attacker can exploit this gap to extract real tokens at incorrect virtual prices.

## Why It Matters
Virtual reserves are an abstraction layer over real balances. If the invariant linking virtual to actual reserves breaks, the pool may quote prices that don't reflect actual liquidity. An attacker can drain real tokens by trading against phantom virtual liquidity.

## Real-World Incident
Wormhole bridge exploit (Feb 2022) involved minting tokens without corresponding backing — conceptually similar to virtual/actual reserve divergence. Mercurial Finance (Solana) had stable swap virtual reserve issues found during audit.

## Invariant

### Formal Property
```
∀ operations on pool:
  actual_balance_a >= virtual_reserve_a - amplification_offset
  actual_balance_b >= virtual_reserve_b - amplification_offset
  After swap: token_account.amount matches pool.reserve_{a,b}
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_virtual_tracks_actual() {
    let actual: u64 = kani::any();
    let virtual_r: u64 = kani::any();
    let amp: u64 = kani::any();

    kani::assume!(actual > 0 && actual < u64::MAX / 2);
    kani::assume!(amp > 0 && amp <= 1000);

    let virtual_with_amp = actual.saturating_mul(amp);
    kani::assert!(virtual_with_amp >= actual);
    // Virtual reserve must be derivable from actual + amplification
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn virtual_reserves_consistent(
        actual_a in 1_000u64..1_000_000_000,
        actual_b in 1_000u64..1_000_000_000,
        amp in 1u64..100
    ) {
        let pool = create_pool(actual_a, actual_b, amp);
        let (va, vb) = pool.virtual_reserves();
        prop_assert!(va >= actual_a, "virtual < actual for token A");
        prop_assert!(vb >= actual_b, "virtual < actual for token B");
    }
}
```

### LiteSVM Assertion
```rust
let pool = get_pool_state(&ctx, pool_key).await;
let actual_a = get_token_balance(&ctx, pool_token_a).await;
let actual_b = get_token_balance(&ctx, pool_token_b).await;
assert_eq!(pool.reserve_a, actual_a, "reserve A mismatch");
assert_eq!(pool.reserve_b, actual_b, "reserve B mismatch");
```

## Suggested Fix
```rust
// After every swap, sync virtual reserves with actual balances
let actual_a = ctx.accounts.pool_token_a.amount;
let actual_b = ctx.accounts.pool_token_b.amount;
pool.reserve_a = actual_a;
pool.reserve_b = actual_b;
pool.virtual_a = actual_a.checked_mul(pool.amplification)?;
pool.virtual_b = actual_b.checked_mul(pool.amplification)?;
```
