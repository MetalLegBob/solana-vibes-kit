# VP-070: Time-Weighted Voting Power

**Category:** Vote/Governance
**Verification tool:** Proptest

## What Can Go Wrong
Vote-escrowed (ve) tokens grant voting power that decreases linearly over the lock period via `power = balance * (lock_end - now) / (lock_end - lock_start)`. This must be monotonically decreasing and reach zero at expiry. Integer truncation can cause power to plateau across consecutive timestamps, and expired locks may retain nonzero power if the expiry check uses strict inequality incorrectly.

## Why It Matters
An attacker creates many small locks at staggered expiries, exploiting integer truncation to retain more aggregate voting power than the decay curve allows. By choosing balances and durations where the numerator truncates identically across consecutive seconds, phantom power accumulates. Combined with flash loans, this grants temporary governance control sufficient to pass treasury-draining proposals.

## Real-World Incident
No single named exploit, but veToken power calculation bugs have been found in multiple governance audits. Curve's veCRV model inspired dozens of forks, several of which had truncation bugs. Trail of Bits flagged this class of issue in a 2023 governance audit.

## Invariant

### Formal Property
```
For balance B, lock_start S, lock_end E, timestamps t1 < t2 where S <= t1:
  power(B, t1, S, E) >= power(B, t2, S, E)   (monotonic decay)
  power(B, E, S, E) == 0                       (zero at expiry)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_ve_power_monotonic_decay() {
    let balance: u64 = kani::any();
    let lock_start: u64 = kani::any();
    let lock_end: u64 = kani::any();
    let now: u64 = kani::any();
    kani::assume!(balance > 0 && balance < 1_000_000_000_000);
    kani::assume!(lock_start < lock_end);
    kani::assume!(now >= lock_start && now + 1 <= lock_end);

    let dur = (lock_end - lock_start) as u128;
    let p1 = (balance as u128) * (lock_end - now) as u128 / dur;
    let p2 = (balance as u128) * (lock_end - now - 1) as u128 / dur;
    kani::assert!(p2 <= p1);
    let p_end = (balance as u128) * 0u128 / dur;
    kani::assert!(p_end == 0);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn ve_power_decays_monotonically(
        balance in 1u64..1_000_000_000,
        duration in 100u64..126_144_000,
        elapsed_pct in 0u64..99
    ) {
        let lock_end = duration;
        let t1 = duration * elapsed_pct / 100;
        let t2 = t1 + 1;
        prop_assume!(t2 < lock_end);

        let dur = duration as u128;
        let p1 = (balance as u128) * (lock_end - t1) as u128 / dur;
        let p2 = (balance as u128) * (lock_end - t2) as u128 / dur;
        prop_assert!(p2 <= p1, "power increased from {} to {}", p1, p2);
        prop_assert!(p1 <= balance as u128, "power exceeds balance");
    }
}
```

### LiteSVM Assertion
```rust
let power_t0 = get_voting_power(&banks_client, voter_key).await;
warp_to_slot(&mut ctx, current_slot + 100);
let power_t1 = get_voting_power(&banks_client, voter_key).await;
warp_to_slot(&mut ctx, current_slot + 200);
let power_t2 = get_voting_power(&banks_client, voter_key).await;
assert!(power_t1 <= power_t0, "power did not decay after first advance");
assert!(power_t2 <= power_t1, "power did not decay after second advance");
warp_to_slot(&mut ctx, lock_end_slot);
let power_expired = get_voting_power(&banks_client, voter_key).await;
assert_eq!(power_expired, 0, "expired lock retains voting power");
```

## Suggested Fix
```rust
pub fn ve_power(balance: u64, now: u64, lock_start: u64, lock_end: u64) -> Result<u64> {
    if now >= lock_end { return Ok(0); }
    let remaining = (lock_end - now) as u128;
    let duration = (lock_end - lock_start) as u128;
    let power = (balance as u128).checked_mul(remaining)
        .ok_or(GovernanceError::Overflow)? / duration;
    Ok(power as u64)
}
```
