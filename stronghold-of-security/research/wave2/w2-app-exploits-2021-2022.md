# Solana Application-Level Exploits (2021-2022)

**Research Status:** INCOMPLETE - WebSearch/WebFetch tools unavailable
**Source:** Training data (January 2025 cutoff) - UNVERIFIED
**Confidence:** LOW - Requires web research to verify and expand

**CRITICAL LIMITATION:** This research was conducted without access to WebSearch or WebFetch tools. The requested methodology required:
1. Fetching the Helius blog post for overview
2. Searching for technical writeups on each incident
3. Finding post-mortem reports from protocols
4. Locating security firm analyses

None of these steps were possible. The information below is based solely on training data and should be considered INCOMPLETE and requiring verification.

---

## Research Methodology (Intended vs Actual)

### Intended Methodology
1. Fetch Helius blog: https://www.helius.dev/blog/solana-hacks
2. For each incident, search: "[Protocol] exploit technical analysis"
3. Search for post-mortems from affected protocols
4. Search for security firm analyses (OtterSec, Neodyme, Zellic, CertiK)
5. Extract technical details, code patterns, lessons learned

### Actual Methodology
- Training data recall only
- No source verification possible
- No additional technical details fetched
- Marked as LOW confidence throughout

---

## 1. Solend Auth Bypass Attempt (August 2021)

**Date:** August 2021
**Amount Lost:** $0 (attempted, not successful)
**Root Cause Category:** Authorization bypass attempt

### Technical Mechanism (UNVERIFIED)
From training data, this appears to have been an attempted governance/authorization bypass on the Solend protocol. The attempt was caught before funds were lost.

**RESEARCH NEEDED:**
- Exact nature of the authorization bypass
- What authority checks were targeted
- How the attempt was detected
- Code patterns involved

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Pattern requires confirmation
// Insufficient authority validation
pub fn admin_function(ctx: Context<AdminAction>) -> Result<()> {
    // Missing: proper authority check
    // Attacker may have tried to call admin functions
    Ok(())
}
```

### Secure Code Pattern
```rust
pub fn admin_function(ctx: Context<AdminAction>) -> Result<()> {
    require!(
        ctx.accounts.authority.key() == EXPECTED_AUTHORITY,
        ErrorCode::Unauthorized
    );
    Ok(())
}
```

### Detection Strategy
- Audit all privileged functions for proper authority validation
- Check that admin functions have appropriate access controls
- Verify upgrade authority patterns

### Lessons Learned
- Even failed attempts provide valuable intelligence
- Authority checks must be explicit and comprehensive
- Governance mechanisms need careful review

### Sources Required
- Solend blog/announcement about the incident
- Security firm analysis
- Helius blog post

**CONFIDENCE: LOW** - Requires web research for technical details

---

## 2. Wormhole Bridge Exploit (February 2022, $326M)

**Date:** February 2, 2022
**Amount Lost:** ~$326 million (120,000 wETH)
**Root Cause Category:** Signature verification bypass

### Technical Mechanism (PARTIALLY VERIFIED FROM TRAINING)

The Wormhole bridge exploit was one of the largest DeFi hacks. The attacker exploited a signature verification flaw in the guardian validation system.

**Attack Flow:**
1. Wormhole uses "Guardians" (validators) to sign cross-chain messages (VAAs - Verified Action Approvals)
2. The Solana contract should verify guardian signatures before minting wrapped tokens
3. The attacker found a way to bypass signature verification
4. They crafted a fake VAA claiming to have deposited ETH on Ethereum
5. The Solana contract accepted the fake VAA and minted 120,000 wETH
6. The attacker bridged these tokens back to Ethereum

**Key Technical Details (UNVERIFIED):**
- The vulnerability was in the `verify_signatures` function
- The attacker exploited the Solana `sysvar` account mechanism
- Specifically, they manipulated the instruction data validation
- The contract failed to properly verify that signatures came from authorized guardians

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Requires source code review
pub fn complete_transfer(ctx: Context<CompleteTransfer>, vaa: Vec<u8>) -> Result<()> {
    // Parse VAA
    let vaa_data = parse_vaa(&vaa)?;

    // VULNERABILITY: Insufficient signature verification
    // The contract may have skipped or improperly verified guardian signatures
    verify_signatures(&vaa_data, &ctx.accounts)?;

    // Mint tokens based on VAA claim
    mint_wrapped_tokens(
        &ctx.accounts.mint,
        &ctx.accounts.recipient,
        vaa_data.amount
    )?;

    Ok(())
}

// The verify_signatures function had a critical flaw
fn verify_signatures(vaa: &VAA, accounts: &Accounts) -> Result<()> {
    // VULNERABILITY: Bypassed or insufficient validation
    // May have accepted invalid guardian signatures
    // or allowed manipulation of the signature verification process
    Ok(())
}
```

### Secure Code Pattern
```rust
pub fn complete_transfer(ctx: Context<CompleteTransfer>, vaa: Vec<u8>) -> Result<()> {
    let vaa_data = parse_and_verify_vaa(&vaa)?;

    // Verify guardian signatures cryptographically
    let guardian_set = &ctx.accounts.guardian_set;
    require!(
        verify_guardian_signatures(&vaa_data, guardian_set)?,
        ErrorCode::InvalidSignatures
    );

    // Verify quorum (enough guardians signed)
    require!(
        vaa_data.guardian_signatures.len() >= guardian_set.quorum,
        ErrorCode::InsufficientSignatures
    );

    // Verify guardian set is current
    require!(
        vaa_data.guardian_set_index == guardian_set.index,
        ErrorCode::GuardianSetMismatch
    );

    // Prevent replay
    let emitter_key = derive_emitter_key(&vaa_data);
    require!(
        !ctx.accounts.processed_vaa.is_initialized(),
        ErrorCode::VAAReplayed
    );

    mint_wrapped_tokens(
        &ctx.accounts.mint,
        &ctx.accounts.recipient,
        vaa_data.amount
    )?;

    // Mark VAA as processed
    ctx.accounts.processed_vaa.initialize()?;

    Ok(())
}
```

### Detection Strategy
- Audit all signature verification logic thoroughly
- Verify cryptographic signature checks are performed correctly
- Check that all sysvar accounts are validated
- Ensure replay protection is implemented
- Verify guardian set validation
- Check quorum requirements are enforced

### Lessons Learned
- Bridge contracts are high-value targets requiring extensive security review
- Signature verification must be cryptographically sound
- All external validators (guardians) must be properly verified
- Replay protection is critical for cross-chain messages
- Never trust client-provided data without cryptographic proof

### Sources Required
- Wormhole post-mortem
- OtterSec or Neodyme analysis
- Helius blog post
- GitHub issue/fix

**CONFIDENCE: MEDIUM** - Well-known incident with public details, but specific code patterns need verification

---

## 3. Cashio Exploit (March 2022, $52M)

**Date:** March 23, 2022
**Amount Lost:** ~$52 million
**Root Cause Category:** Missing account validation (Anchor constraint bypass)

### Technical Mechanism (PARTIALLY VERIFIED FROM TRAINING)

The Cashio exploit was a textbook case of missing Anchor account validation. The protocol allowed users to mint stablecoins (CASH) by depositing collateral.

**Attack Flow:**
1. Cashio used an "Arrow" token as collateral for minting CASH stablecoins
2. The minting function should verify the collateral token mint account
3. The attacker created a fake "Arrow" token mint with arbitrary supply
4. They passed the fake mint account to the Cashio minting function
5. The function failed to validate that the mint was the legitimate Arrow token
6. The attacker minted unlimited CASH using worthless fake tokens
7. They swapped CASH for real assets (USDC, etc.) and drained liquidity

**Key Technical Details:**
- Missing `constraint` in Anchor account validation
- No verification that `collateral_mint` matched the expected Arrow mint address
- The program accepted any SPL token mint as collateral

### Vulnerable Code Pattern
```rust
// VULNERABLE CODE - Cashio pattern
#[derive(Accounts)]
pub struct MintCash<'info> {
    #[account(mut)]
    pub cash_mint: Account<'info, Mint>,

    #[account(mut)]
    pub user_collateral: Account<'info, TokenAccount>,

    // VULNERABILITY: No constraint on collateral_mint!
    // Should verify this is the legitimate Arrow token
    pub collateral_mint: Account<'info, Mint>,

    #[account(mut)]
    pub user_cash_account: Account<'info, TokenAccount>,

    pub user: Signer<'info>,
    pub token_program: Program<'info, Token>,
}

pub fn mint_cash(ctx: Context<MintCash>, collateral_amount: u64) -> Result<()> {
    // Transfer collateral from user
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_collateral.to_account_info(),
                to: ctx.accounts.protocol_vault.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            }
        ),
        collateral_amount
    )?;

    // VULNERABILITY: Mints CASH without verifying collateral is legitimate!
    // Attacker can use fake collateral_mint with arbitrary supply
    let cash_amount = calculate_cash_amount(collateral_amount);

    token::mint_to(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            MintTo {
                mint: ctx.accounts.cash_mint.to_account_info(),
                to: ctx.accounts.user_cash_account.to_account_info(),
                authority: ctx.accounts.mint_authority.to_account_info(),
            }
        ),
        cash_amount
    )?;

    Ok(())
}
```

### Secure Code Pattern
```rust
// SECURE CODE - Proper validation
use anchor_lang::prelude::*;

// Define the legitimate collateral mint as a constant
pub const ARROW_MINT: Pubkey = pubkey!("ArrowXYZ..."); // Real Arrow mint address

#[derive(Accounts)]
pub struct MintCash<'info> {
    #[account(mut)]
    pub cash_mint: Account<'info, Mint>,

    #[account(
        mut,
        constraint = user_collateral.mint == ARROW_MINT @ ErrorCode::InvalidCollateral
    )]
    pub user_collateral: Account<'info, TokenAccount>,

    // SECURE: Validate that collateral_mint matches expected address
    #[account(
        constraint = collateral_mint.key() == ARROW_MINT @ ErrorCode::InvalidCollateralMint
    )]
    pub collateral_mint: Account<'info, Mint>,

    #[account(mut)]
    pub user_cash_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub protocol_vault: Account<'info, TokenAccount>,

    pub user: Signer<'info>,
    pub token_program: Program<'info, Token>,

    /// CHECK: PDA authority for minting
    #[account(
        seeds = [b"mint_authority"],
        bump
    )]
    pub mint_authority: AccountInfo<'info>,
}

pub fn mint_cash(ctx: Context<MintCash>, collateral_amount: u64) -> Result<()> {
    // Additional runtime check (defense in depth)
    require!(
        ctx.accounts.user_collateral.mint == ARROW_MINT,
        ErrorCode::InvalidCollateral
    );

    // Transfer legitimate collateral from user
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_collateral.to_account_info(),
                to: ctx.accounts.protocol_vault.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            }
        ),
        collateral_amount
    )?;

    // Now safe to mint CASH
    let cash_amount = calculate_cash_amount(collateral_amount);

    let bump = *ctx.bumps.get("mint_authority").unwrap();
    let seeds = &[b"mint_authority".as_ref(), &[bump]];
    let signer_seeds = &[&seeds[..]];

    token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            MintTo {
                mint: ctx.accounts.cash_mint.to_account_info(),
                to: ctx.accounts.user_cash_account.to_account_info(),
                authority: ctx.accounts.mint_authority.to_account_info(),
            },
            signer_seeds
        ),
        cash_amount
    )?;

    Ok(())
}

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid collateral token account")]
    InvalidCollateral,
    #[msg("Invalid collateral mint")]
    InvalidCollateralMint,
}
```

### Detection Strategy
- **Audit all token account validations** - Check every `Account<'info, TokenAccount>` and `Account<'info, Mint>`
- **Look for missing constraints** - Every token account should have mint validation
- **Check collateral systems** - Any protocol accepting deposits must validate the asset
- **Verify hardcoded addresses** - Legitimate token mints should be constants or PDAs
- **Test with fake tokens** - Try passing wrong mints in testing

### Lessons Learned
1. **Never trust account addresses without validation** - Anchor doesn't validate by default
2. **Use constraints liberally** - `constraint = mint == EXPECTED @ Error` is critical
3. **Collateral protocols are high-risk** - Infinite mint vulnerabilities are catastrophic
4. **Defense in depth** - Use both Anchor constraints AND runtime checks
5. **This is the most common Solana vulnerability pattern** - Missing account validation

### Sources Required
- Cashio post-mortem
- Security firm analysis (likely OtterSec or Neodyme)
- Helius blog post
- Anchor security documentation

**CONFIDENCE: MEDIUM** - Well-documented incident, specific code patterns known from training

---

## 4. Crema Finance Exploit (July 2022, $8.8M)

**Date:** July 3, 2022
**Amount Lost:** ~$8.8 million
**Root Cause Category:** Missing account validation + flash loan manipulation

### Technical Mechanism (UNVERIFIED)

Crema Finance was a Solana-based AMM (concentrated liquidity like Uniswap v3). The exploit involved flash loans and fake tick accounts.

**Attack Flow (UNVERIFIED):**
1. Crema used a tick-based pricing system (similar to Uniswap v3)
2. The protocol should validate that tick accounts are legitimate program-owned accounts
3. The attacker created fake tick accounts with manipulated liquidity data
4. They used flash loans to amplify the attack
5. By passing fake tick accounts, they manipulated price calculations
6. This allowed them to extract more tokens than they deposited

**Key Technical Details (REQUIRES VERIFICATION):**
- Missing validation on tick account ownership
- Tick accounts should be PDAs owned by the program
- Flash loan allowed large position without upfront capital

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Requires Crema source code
#[derive(Accounts)]
pub struct Swap<'info> {
    pub pool: Account<'info, Pool>,

    // VULNERABILITY: No validation that tick account is legitimate
    // Should verify it's a PDA owned by program
    pub tick_account: AccountInfo<'info>,

    #[account(mut)]
    pub user_source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub user_dest: Account<'info, TokenAccount>,

    pub user: Signer<'info>,
}

pub fn swap(ctx: Context<Swap>, amount: u64) -> Result<()> {
    // Parse tick data WITHOUT validating ownership
    let tick_data = TickData::try_from_slice(&ctx.accounts.tick_account.data.borrow())?;

    // VULNERABILITY: Uses attacker-controlled tick_data for price calculation
    let output_amount = calculate_output(amount, &tick_data);

    // Swap tokens based on manipulated calculation
    token::transfer(/* ... */)?;

    Ok(())
}
```

### Secure Code Pattern
```rust
#[derive(Accounts)]
pub struct Swap<'info> {
    pub pool: Account<'info, Pool>,

    // SECURE: Validate tick account is program-owned PDA
    #[account(
        seeds = [b"tick", pool.key().as_ref(), &tick_index.to_le_bytes()],
        bump,
        constraint = tick_account.owner == program_id() @ ErrorCode::InvalidTickOwner
    )]
    pub tick_account: Account<'info, TickState>,

    #[account(mut)]
    pub user_source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub user_dest: Account<'info, TokenAccount>,

    pub user: Signer<'info>,
}

pub fn swap(ctx: Context<Swap>, amount: u64, tick_index: i32) -> Result<()> {
    // Now safe to use tick_account - it's verified as program-owned PDA
    let output_amount = calculate_output(amount, &ctx.accounts.tick_account)?;

    // Swap tokens
    token::transfer(/* ... */)?;

    Ok(())
}
```

### Detection Strategy
- Audit all account validations in DeFi primitives
- Check that state accounts (ticks, positions, etc.) are PDAs
- Verify account ownership constraints
- Test with attacker-controlled accounts
- Review flash loan integration points

### Lessons Learned
- Complex DeFi primitives (concentrated liquidity) need extra scrutiny
- All state accounts must be validated as program-owned PDAs
- Flash loans amplify account validation bugs
- AMM price calculations must use only validated data

### Sources Required
- Crema Finance post-mortem
- Security firm analysis
- Helius blog post
- Technical writeup on the specific vulnerability

**CONFIDENCE: LOW** - Details are unclear from training data, requires research

---

## 5. Audius Governance Exploit (July 2022)

**Date:** July 2022
**Amount Lost:** Unclear (governance manipulation, tokens minted)
**Root Cause Category:** Uninitialized storage vulnerability

### Technical Mechanism (UNVERIFIED)

Audius is a music streaming protocol with components on both Ethereum and Solana. The governance exploit involved the Solana side.

**Attack Flow (REQUIRES VERIFICATION):**
1. Audius governance used Solana for some operations
2. An attacker exploited uninitialized storage in the governance contract
3. This allowed them to manipulate governance proposals or voting
4. They potentially minted unauthorized governance tokens or executed unauthorized proposals

**Key Technical Details (HIGHLY UNCERTAIN):**
- Involved uninitialized account exploitation
- May have been an initialization check bypass
- Governance authority manipulation

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Pattern requires confirmation
#[derive(Accounts)]
pub struct ExecuteProposal<'info> {
    #[account(mut)]
    pub proposal: Account<'info, Proposal>,

    // VULNERABILITY: May not check if governance account is initialized
    pub governance: AccountInfo<'info>,

    pub executor: Signer<'info>,
}

pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {
    // VULNERABILITY: Uses governance data without checking initialization
    let governance_data = Governance::try_from_slice(
        &ctx.accounts.governance.data.borrow()
    )?;

    // If governance is uninitialized, this could contain attacker-controlled data
    require!(
        governance_data.voting_threshold <= ctx.accounts.proposal.yes_votes,
        ErrorCode::InsufficientVotes
    );

    // Execute proposal
    Ok(())
}
```

### Secure Code Pattern
```rust
#[derive(Accounts)]
pub struct ExecuteProposal<'info> {
    #[account(mut)]
    pub proposal: Account<'info, Proposal>,

    // SECURE: Use proper Account type which checks initialization
    #[account(
        seeds = [b"governance"],
        bump,
    )]
    pub governance: Account<'info, Governance>,

    pub executor: Signer<'info>,
}

pub fn execute_proposal(ctx: Context<ExecuteProposal>) -> Result<()> {
    // governance is guaranteed to be initialized by Anchor
    require!(
        ctx.accounts.governance.voting_threshold <= ctx.accounts.proposal.yes_votes,
        ErrorCode::InsufficientVotes
    );

    // Execute proposal safely
    Ok(())
}
```

### Detection Strategy
- Check all `AccountInfo` usage - should be `Account<'info, T>` when possible
- Verify initialization checks on all accounts
- Audit governance mechanisms thoroughly
- Test with uninitialized accounts

### Lessons Learned
- Governance systems require extreme scrutiny
- Always check account initialization
- Use Anchor's `Account` wrapper instead of raw `AccountInfo` when possible
- Uninitialized storage can contain arbitrary data

### Sources Required
- Audius blog post about the incident
- Security analysis
- Helius blog post
- Technical details on the specific vulnerability

**CONFIDENCE: LOW** - Limited details from training data

---

## 6. Nirvana Finance Exploit (July 2022, $3.5M)

**Date:** July 28, 2022
**Amount Lost:** ~$3.5 million
**Root Cause Category:** Flash loan + price oracle manipulation

### Technical Mechanism (PARTIALLY VERIFIED)

Nirvana was a Solana-based protocol with the ANA token. The exploit used flash loans to manipulate the token price.

**Attack Flow:**
1. Attacker obtained a large flash loan (likely from Solend or similar)
2. Used the borrowed funds to manipulate the ANA token price
3. The protocol's oracle or pricing mechanism relied on on-chain liquidity
4. By creating extreme imbalance, the attacker manipulated the price
5. They exploited the inflated/deflated price to drain value
6. Repaid the flash loan and kept the profit

**Key Technical Details (REQUIRES VERIFICATION):**
- The protocol may have used a naive on-chain oracle
- Price calculation likely based on AMM reserves
- No flash loan protection or time-weighted average price (TWAP)

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Pattern requires confirmation
pub fn calculate_ana_price(ctx: Context<PriceCheck>) -> Result<u64> {
    let pool = &ctx.accounts.pool;

    // VULNERABILITY: Instant price from AMM reserves
    // Can be manipulated with flash loans in single transaction
    let price = (pool.token_b_reserve * PRECISION) / pool.ana_reserve;

    Ok(price)
}

pub fn buy_ana(ctx: Context<BuyAna>, amount: u64) -> Result<()> {
    // Get current price (manipulable!)
    let price = calculate_ana_price(ctx.as_ref())?;

    // Calculate cost based on manipulated price
    let cost = amount * price / PRECISION;

    // Transfer tokens at wrong price
    // ... transfer logic

    Ok(())
}
```

### Secure Code Pattern
```rust
use switchboard_v2::AggregatorAccountData;

pub fn calculate_ana_price(ctx: Context<PriceCheck>) -> Result<u64> {
    // SECURE: Use external oracle like Switchboard or Pyth
    let feed = &ctx.accounts.price_feed;
    let aggregator = AggregatorAccountData::new(feed)?;

    // Get oracle price (not manipulable by flash loans)
    let price = aggregator.get_result()?.try_into()?;

    // Additional security: Check price freshness
    let staleness = Clock::get()?.unix_timestamp - aggregator.latest_confirmed_round.round_open_timestamp;
    require!(staleness < 60, ErrorCode::StalePrice);

    Ok(price)
}

// Alternative: TWAP from on-chain data
pub struct PriceAccumulator {
    pub cumulative_price: u128,
    pub last_update: i64,
    pub observation_count: u64,
}

pub fn update_twap(ctx: Context<UpdateTWAP>) -> Result<()> {
    let pool = &ctx.accounts.pool;
    let accumulator = &mut ctx.accounts.accumulator;
    let clock = Clock::get()?;

    // Time-weighted accumulation
    let time_elapsed = clock.unix_timestamp - accumulator.last_update;
    let current_price = (pool.token_b_reserve * PRECISION) / pool.ana_reserve;

    accumulator.cumulative_price += (current_price as u128) * (time_elapsed as u128);
    accumulator.observation_count += 1;
    accumulator.last_update = clock.unix_timestamp;

    Ok(())
}

pub fn get_twap(accumulator: &PriceAccumulator, window: i64) -> u64 {
    // Return average over time window, not instant price
    (accumulator.cumulative_price / window as u128) as u64
}
```

### Detection Strategy
- Identify all price calculation points
- Check if prices come from on-chain liquidity (AMM reserves)
- Verify that oracles are used (Switchboard, Pyth, Chainlink)
- Look for flash loan protection mechanisms
- Test with flash loan simulation

### Lessons Learned
- Never use instant AMM prices for critical operations
- Use external price oracles (Pyth, Switchboard)
- If using on-chain prices, implement TWAP
- Flash loans enable single-transaction price manipulation
- Consider flash loan protection (transaction-level state)

### Sources Required
- Nirvana Finance post-mortem
- Security analysis
- Helius blog post
- Flash loan attack technical details

**CONFIDENCE: MEDIUM** - Flash loan oracle manipulation is well-understood pattern

---

## 7. Slope Mobile Wallet Exploit (August 2022, $4.1M)

**Date:** August 3, 2022
**Amount Lost:** ~$4.1 million (9,231 wallets affected)
**Root Cause Category:** Private key exposure via logging

### Technical Mechanism (VERIFIED FROM TRAINING)

This was NOT a protocol exploit but a wallet software vulnerability. Slope mobile wallet inadvertently logged users' private keys.

**Attack Flow:**
1. Slope mobile wallet used Sentry (error tracking service) for logging
2. The wallet code logged sensitive data including mnemonic phrases/private keys
3. These logs were sent to Sentry's servers
4. An attacker gained access to the Sentry logs (details unclear)
5. They extracted private keys from the logs
6. Used the keys to drain affected wallets

**Key Technical Details:**
- ~9,231 wallets affected
- Private keys/mnemonics were in plaintext in logs
- Not a blockchain vulnerability, but a client-side security failure

### Vulnerable Code Pattern
```typescript
// VULNERABLE - Mobile wallet code (React Native / JavaScript)
import * as Sentry from '@sentry/react-native';

async function importWallet(mnemonic: string) {
    try {
        const keypair = Keypair.fromMnemonic(mnemonic);

        // Store wallet
        await storeWallet(keypair);

        return keypair.publicKey;
    } catch (error) {
        // VULNERABILITY: Logging error with full context
        // Sentry captures all variables in scope, including mnemonic!
        Sentry.captureException(error, {
            extra: {
                mnemonic, // CRITICAL: Private key exposed
                context: 'wallet_import'
            }
        });
        throw error;
    }
}

// Another vulnerability pattern
function debugLog(message: string, data: any) {
    console.log(message, data);

    // VULNERABILITY: Sending all logs to remote server
    Sentry.addBreadcrumb({
        message,
        data // May contain sensitive info
    });
}

// Usage that exposes keys
const wallet = await generateWallet();
debugLog('Wallet generated', {
    publicKey: wallet.publicKey,
    privateKey: wallet.privateKey // EXPOSED!
});
```

### Secure Code Pattern
```typescript
import * as Sentry from '@sentry/react-native';

// Configure Sentry to strip sensitive data
Sentry.init({
    dsn: 'YOUR_DSN',
    beforeSend(event, hint) {
        // Strip sensitive fields
        if (event.extra) {
            delete event.extra.mnemonic;
            delete event.extra.privateKey;
            delete event.extra.secretKey;
        }

        // Sanitize breadcrumbs
        if (event.breadcrumbs) {
            event.breadcrumbs = event.breadcrumbs.map(breadcrumb => {
                if (breadcrumb.data) {
                    const sanitized = { ...breadcrumb.data };
                    delete sanitized.mnemonic;
                    delete sanitized.privateKey;
                    delete sanitized.secretKey;
                    return { ...breadcrumb, data: sanitized };
                }
                return breadcrumb;
            });
        }

        return event;
    }
});

// Define sensitive field names
const SENSITIVE_FIELDS = [
    'mnemonic', 'privateKey', 'secretKey', 'seed',
    'private_key', 'secret_key', 'seedPhrase'
];

function sanitizeObject(obj: any): any {
    if (!obj || typeof obj !== 'object') return obj;

    const sanitized = { ...obj };
    for (const field of SENSITIVE_FIELDS) {
        if (field in sanitized) {
            sanitized[field] = '[REDACTED]';
        }
    }
    return sanitized;
}

async function importWallet(mnemonic: string) {
    try {
        const keypair = Keypair.fromMnemonic(mnemonic);
        await storeWallet(keypair);
        return keypair.publicKey;
    } catch (error) {
        // SECURE: Never log mnemonic
        Sentry.captureException(error, {
            extra: {
                context: 'wallet_import',
                // Only log non-sensitive data
                publicKey: keypair?.publicKey.toBase58()
            }
        });
        throw error;
    }
}

// Secure debug logging
function debugLog(message: string, data: any) {
    const sanitized = sanitizeObject(data);
    console.log(message, sanitized);

    Sentry.addBreadcrumb({
        message,
        data: sanitized
    });
}

// Usage - safe
const wallet = await generateWallet();
debugLog('Wallet generated', {
    publicKey: wallet.publicKey.toBase58()
    // privateKey intentionally omitted
});
```

### Detection Strategy
- Audit all logging statements in wallet code
- Search for Sentry, Bugsnag, Datadog, or similar integrations
- Check what data is included in error reports
- Verify that private keys never appear in:
  - Console logs
  - Error tracking services
  - Analytics
  - Crash reports
- Code review for any serialization of keypair objects

### Lessons Learned
1. **Never log private keys or mnemonics** - Not even in error cases
2. **Sanitize all remote logging** - Assume logging services can be compromised
3. **Client-side security is critical** - Not just smart contract security
4. **Error tracking services are risky** - They capture full context by default
5. **This was not a Solana vulnerability** - But it affected many Solana users
6. **Trust boundaries matter** - Don't send sensitive data to third-party services

### Sources Required
- Slope official statement
- Security analysis
- Helius blog post
- Details on number of affected wallets

**CONFIDENCE: MEDIUM** - Well-publicized incident with clear details

---

## 8. OptiFi Lockup Bug (August 2022, $661K)

**Date:** August 2022
**Amount Lost:** $661,000 (locked, not stolen)
**Root Cause Category:** Operational error - accidental program closure

### Technical Mechanism (VERIFIED FROM TRAINING)

This was NOT an exploit by an attacker, but an operational mistake by the OptiFi team.

**What Happened:**
1. OptiFi team was attempting to update their program
2. They accidentally called `solana program close` instead of an upgrade command
3. This permanently closed the program account
4. Once closed, the program could no longer execute
5. ~$661K in user funds became locked in program-owned accounts
6. The accounts existed but could not be accessed without the program

**Key Technical Details:**
- Not a vulnerability exploit, but an operational error
- The `close` instruction is irreversible
- Program accounts can be closed to reclaim rent
- User funds were in PDAs controlled by the now-closed program

### The Dangerous Pattern
```bash
# What OptiFi intended to do:
solana program deploy --program-id <PROGRAM_ID> optimized.so

# What they actually did:
solana program close <PROGRAM_ID>

# Result: Program account closed, irreversible
```

### Smart Contract Equivalent
```rust
// This is what makes fund recovery impossible
pub fn close_program(ctx: Context<CloseProgram>) -> Result<()> {
    // Closes the program account and reclaims rent
    // After this, PDAs owned by the program cannot be accessed
    // because no program code exists to sign for them

    let dest = &ctx.accounts.destination;
    let program = &ctx.accounts.program_account;

    **dest.lamports.borrow_mut() += program.lamports();
    **program.lamports.borrow_mut() = 0;

    Ok(())
}
```

### Prevention Patterns
```rust
// 1. Use upgrade authority properly
#[derive(Accounts)]
pub struct UpgradeProgram<'info> {
    #[account(mut)]
    pub program_data: Account<'info, ProgramData>,

    #[account(
        constraint = upgrade_authority.key() == program_data.upgrade_authority.unwrap()
    )]
    pub upgrade_authority: Signer<'info>,
}

// 2. Implement emergency withdrawal before any closure
pub fn emergency_withdraw_all(ctx: Context<EmergencyWithdraw>) -> Result<()> {
    require!(
        ctx.accounts.authority.key() == EMERGENCY_AUTHORITY,
        ErrorCode::Unauthorized
    );

    // Allow withdrawing all user funds before program closure
    // This should be tested thoroughly before mainnet

    Ok(())
}

// 3. Use timelock for critical operations
pub struct Timelock {
    pub operation: Operation,
    pub scheduled_time: i64,
    pub executed: bool,
}

pub fn schedule_close(ctx: Context<ScheduleClose>) -> Result<()> {
    let timelock = &mut ctx.accounts.timelock;
    let clock = Clock::get()?;

    timelock.operation = Operation::Close;
    timelock.scheduled_time = clock.unix_timestamp + 86400; // 24 hour delay
    timelock.executed = false;

    Ok(())
}
```

### Operational Best Practices
```bash
# 1. Always use --dry-run first
solana program deploy --program-id <ID> --dry-run program.so

# 2. Use a multisig for upgrade authority
# Set upgrade authority to a multisig, not a single key

# 3. Test on devnet/testnet first
solana program deploy --url devnet program.so

# 4. Implement emergency withdrawal function
# Before any mainnet deployment, ensure user funds can be rescued

# 5. Use program upgrade, not close
solana program upgrade <PROGRAM_ID> new_program.so

# 6. Backup and verify
solana program dump <PROGRAM_ID> backup.so
# Verify the dump before any changes
```

### Detection Strategy (for auditors)
- Check if emergency withdrawal functions exist
- Verify upgrade authority is a multisig
- Review operational procedures with team
- Ensure they understand upgrade vs close
- Recommend testing on devnet first

### Lessons Learned
1. **Operational security is as important as code security**
2. **Program closure is permanent and irreversible**
3. **Always implement emergency withdrawal mechanisms**
4. **Use multisig for upgrade authority**
5. **Test critical operations on devnet first**
6. **Understand the difference between upgrade and close**
7. **Consider timelock for destructive operations**

### Sources Required
- OptiFi official statement
- Analysis of the incident
- Helius blog post

**CONFIDENCE: HIGH** - Well-documented incident with clear technical details

---

## 9. Mango Markets Exploit (October 2022, $114M)

**Date:** October 11, 2022
**Amount Lost:** ~$114 million
**Root Cause Category:** Oracle price manipulation

### Technical Mechanism (VERIFIED FROM TRAINING)

The Mango Markets exploit was executed by Avraham Eisenberg and is one of the most sophisticated DeFi attacks. It exploited thin liquidity and oracle dependence.

**Attack Flow:**
1. **Setup:** Eisenberg used two accounts on Mango Markets
2. **Price Manipulation:**
   - Account A took a massive long position in MNGO token perpetual futures
   - Account B took the opposite short position
   - He then used significant capital to buy MNGO tokens on thin liquidity markets
3. **Oracle Impact:**
   - Mango used oracles that reflected the manipulated spot price
   - The oracle price for MNGO increased dramatically (5x+)
   - Account A's long position value increased proportionally
4. **Exploitation:**
   - Account A now had massive "collateral" value from inflated MNGO position
   - Used this inflated collateral to borrow maximum amounts of other assets (USDC, SOL, BTC, etc.)
   - Withdrew the borrowed assets
5. **Result:**
   - Account B's short position lost money (as intended)
   - Account A extracted $114M in real assets
   - The protocol was left insolvent
   - MNGO price collapsed after the attack

**Key Technical Details:**
- Mango used oracles (likely Pyth or similar) that reflected spot market prices
- MNGO had thin liquidity (~$1M), allowing price manipulation with ~$10M
- The protocol allowed borrowing based on the inflated collateral value
- No circuit breakers or price manipulation detection

### Vulnerable Code Pattern
```rust
// UNVERIFIED - Conceptual pattern based on known behavior
pub fn calculate_collateral_value(ctx: Context<CollateralCheck>) -> Result<u64> {
    let position = &ctx.accounts.user_position;
    let oracle = &ctx.accounts.oracle;

    // Get current oracle price
    let price = get_oracle_price(oracle)?;

    // VULNERABILITY: Uses current price without:
    // 1. Checking if price changed dramatically (circuit breaker)
    // 2. Using TWAP to smooth manipulation
    // 3. Limiting position size relative to liquidity
    // 4. Checking if price is being manipulated

    let collateral_value = position.amount * price;

    Ok(collateral_value)
}

pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {
    let collateral_value = calculate_collateral_value(ctx.as_ref())?;

    // VULNERABILITY: Allows borrowing based on potentially manipulated collateral
    let max_borrow = collateral_value * COLLATERAL_RATIO / 100;

    require!(
        ctx.accounts.user_position.borrowed + amount <= max_borrow,
        ErrorCode::InsufficientCollateral
    );

    // Transfer borrowed assets
    token::transfer(/* ... */)?;

    ctx.accounts.user_position.borrowed += amount;

    Ok(())
}
```

### Secure Code Pattern
```rust
use pyth_sdk_solana::load_price_feed_from_account_info;
use std::cmp::min;

pub struct PriceGuard {
    pub last_price: u64,
    pub last_update: i64,
    pub max_price_change_bps: u16, // Basis points (e.g., 1000 = 10%)
}

pub fn calculate_collateral_value(ctx: Context<CollateralCheck>) -> Result<u64> {
    let position = &ctx.accounts.user_position;
    let oracle = &ctx.accounts.oracle;
    let price_guard = &mut ctx.accounts.price_guard;
    let clock = Clock::get()?;

    // Get oracle price
    let price_feed = load_price_feed_from_account_info(&oracle)?;
    let current_price = price_feed.get_current_price()
        .ok_or(ErrorCode::InvalidPrice)?;

    // SECURITY 1: Check price staleness
    let staleness = clock.unix_timestamp - current_price.publish_time;
    require!(staleness < 60, ErrorCode::StalePrice);

    // SECURITY 2: Check confidence interval
    let confidence_ratio = current_price.conf * 10000 / current_price.price as u64;
    require!(confidence_ratio < 500, ErrorCode::LowConfidence); // 5% max

    // SECURITY 3: Circuit breaker - limit price change
    if price_guard.last_update > 0 {
        let time_elapsed = clock.unix_timestamp - price_guard.last_update;

        if time_elapsed < 3600 { // Within 1 hour
            let price_change_bps = if current_price.price > price_guard.last_price as i64 {
                ((current_price.price - price_guard.last_price as i64) * 10000
                    / price_guard.last_price as i64) as u16
            } else {
                ((price_guard.last_price as i64 - current_price.price) * 10000
                    / price_guard.last_price as i64) as u16
            };

            require!(
                price_change_bps <= price_guard.max_price_change_bps,
                ErrorCode::PriceChangeExceedsLimit
            );
        }
    }

    // Update price guard
    price_guard.last_price = current_price.price as u64;
    price_guard.last_update = clock.unix_timestamp;

    // SECURITY 4: Use EMA (exponential moving average) or TWAP
    // Instead of instant price, use time-weighted average
    let smoothed_price = calculate_ema(current_price.price as u64, &ctx.accounts.price_history)?;

    let collateral_value = position.amount * smoothed_price;

    Ok(collateral_value)
}

pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {
    let collateral_value = calculate_collateral_value(ctx.as_ref())?;
    let market = &ctx.accounts.market;

    // SECURITY 5: Position size limits relative to market depth
    let position_value = ctx.accounts.user_position.amount * market.current_price;
    let max_position_value = market.total_liquidity * market.max_position_size_bps / 10000;

    require!(
        position_value <= max_position_value,
        ErrorCode::PositionTooLarge
    );

    // SECURITY 6: Borrow limits
    let max_borrow = min(
        collateral_value * COLLATERAL_RATIO / 100,
        market.max_borrow_per_user
    );

    require!(
        ctx.accounts.user_position.borrowed + amount <= max_borrow,
        ErrorCode::InsufficientCollateral
    );

    // Transfer borrowed assets
    token::transfer(/* ... */)?;

    ctx.accounts.user_position.borrowed += amount;

    Ok(())
}

#[error_code]
pub enum ErrorCode {
    #[msg("Price data is stale")]
    StalePrice,
    #[msg("Oracle confidence too low")]
    LowConfidence,
    #[msg("Price change exceeds circuit breaker limit")]
    PriceChangeExceedsLimit,
    #[msg("Position size too large relative to market")]
    PositionTooLarge,
    #[msg("Insufficient collateral")]
    InsufficientCollateral,
    #[msg("Invalid price")]
    InvalidPrice,
}
```

### Detection Strategy
- **Identify oracle usage** - Find all price feed integrations
- **Check for circuit breakers** - Verify price change limits exist
- **Review position size limits** - Ensure positions are capped relative to liquidity
- **Test price manipulation** - Simulate extreme price changes
- **Verify oracle configuration** - Check staleness bounds, confidence intervals
- **Look for TWAP/EMA** - Instant prices are more manipulable than time-weighted
- **Review liquidation logic** - Ensure it can't be exploited with manipulated prices

### Lessons Learned
1. **Oracles are not perfect** - They reflect market prices, which can be manipulated
2. **Thin liquidity = manipulation risk** - Small markets are easier to manipulate
3. **Circuit breakers are essential** - Limit how fast prices can change
4. **Position size limits matter** - Don't allow positions larger than market can support
5. **Use time-weighted prices** - TWAP/EMA reduce instant manipulation impact
6. **This was technically legal** - Eisenberg argued it was permissionless trading
7. **Protocol design matters** - Risk parameters must account for manipulation
8. **Oracle confidence intervals** - Check that oracle data is reliable
9. **Not a code bug** - This was a protocol design flaw, not a smart contract bug

### Legal/Ethical Note
Avraham Eisenberg was later arrested and charged with market manipulation. He argued the attack was legal "profitable trading strategy" under DeFi's permissionless ethos. The case highlighted gray areas in DeFi regulation.

### Sources Required
- Mango Markets post-mortem
- Avraham Eisenberg's Twitter thread
- Security analysis (OtterSec, Neodyme)
- Helius blog post
- Court documents from Eisenberg case

**CONFIDENCE: HIGH** - Extremely well-documented incident with public attacker

---

## 10. UXD Protocol Exploit (October 2022)

**Date:** October 2022 (shortly after Mango)
**Amount Lost:** Unclear (cascade effect)
**Root Cause Category:** Dependency risk / oracle cascade

### Technical Mechanism (UNVERIFIED)

UXD Protocol was affected by the Mango Markets exploit as a cascade effect.

**Attack Flow (REQUIRES VERIFICATION):**
1. UXD Protocol held positions or deposits on Mango Markets
2. When Mango Markets was exploited, protocol became insolvent
3. UXD's collateral on Mango was locked or lost
4. This affected UXD's ability to maintain its stablecoin peg or fulfill obligations
5. Users potentially couldn't redeem UXD stablecoins

**Key Technical Details (HIGHLY UNCERTAIN):**
- UXD used Mango for some DeFi operations
- The protocol had counterparty risk to Mango
- May have been using Mango for derivatives or lending
- Oracle prices from Mango may have affected UXD's calculations

### Vulnerable Pattern
```rust
// UNVERIFIED - Conceptual pattern
pub fn calculate_backing(ctx: Context<BackingCheck>) -> Result<u64> {
    // VULNERABILITY: Depends on external protocol solvency
    let mango_position = get_mango_position(&ctx.accounts.mango_account)?;

    // If Mango is exploited, this value is unreliable
    let backing_value = mango_position.collateral_value;

    Ok(backing_value)
}
```

### Secure Pattern
```rust
// Diversify risk across multiple protocols
pub struct ProtocolBacking {
    pub protocol_a_value: u64,
    pub protocol_b_value: u64,
    pub protocol_c_value: u64,
    pub max_single_protocol_exposure_bps: u16, // e.g., 3000 = 30%
}

pub fn calculate_total_backing(ctx: Context<BackingCheck>) -> Result<u64> {
    let backing = &ctx.accounts.backing;

    let total = backing.protocol_a_value
        + backing.protocol_b_value
        + backing.protocol_c_value;

    // SECURITY: Enforce diversification
    let max_exposure = total * backing.max_single_protocol_exposure_bps as u64 / 10000;

    require!(
        backing.protocol_a_value <= max_exposure,
        ErrorCode::ExcessiveConcentration
    );
    require!(
        backing.protocol_b_value <= max_exposure,
        ErrorCode::ExcessiveConcentration
    );
    require!(
        backing.protocol_c_value <= max_exposure,
        ErrorCode::ExcessiveConcentration
    );

    Ok(total)
}

// Circuit breaker for external protocol issues
pub fn update_external_position(ctx: Context<UpdatePosition>) -> Result<()> {
    let health_check = &ctx.accounts.protocol_health;

    // SECURITY: Pause operations if external protocol shows distress
    require!(
        health_check.is_healthy(),
        ErrorCode::ExternalProtocolUnhealthy
    );

    // Update position
    Ok(())
}
```

### Detection Strategy
- Identify all external protocol dependencies
- Check concentration limits (don't put all eggs in one basket)
- Verify circuit breakers for external protocol failures
- Review counterparty risk
- Ensure protocol can survive external failures

### Lessons Learned
1. **Composability creates risk** - DeFi protocols depend on each other
2. **Cascading failures happen** - One exploit can affect many protocols
3. **Diversify dependencies** - Don't rely on a single external protocol
4. **Monitor external protocol health** - Implement circuit breakers
5. **Counterparty risk is real** - Even in "trustless" DeFi

### Sources Required
- UXD Protocol statement
- Analysis of Mango cascade effects
- Helius blog post

**CONFIDENCE: LOW** - Limited details on exact mechanism

---

## 11. Tulip Protocol Exploit (October 2022)

**Date:** October 2022 (around same time as Mango)
**Amount Lost:** Unclear
**Root Cause Category:** Likely Mango Markets cascade

### Technical Mechanism (UNVERIFIED)

Similar to UXD, Tulip Protocol was likely affected by the Mango Markets exploit.

**Possible Attack Flow (REQUIRES VERIFICATION):**
1. Tulip Protocol integrated with Mango for yield farming or leveraged positions
2. When Mango was exploited, Tulip's positions were affected
3. May have faced insolvency or inability to honor user withdrawals

**RESEARCH NEEDED:**
- Was this a separate exploit or Mango cascade?
- What was the specific vulnerability?
- How much was lost?
- Technical mechanism

### Detection Strategy
Same as UXD - check external dependencies and cascade risk.

### Sources Required
- Tulip Protocol statement
- Technical analysis
- Helius blog post

**CONFIDENCE: VERY LOW** - Minimal information from training data

---

## 12. Save/Solend Exploit (November 2022)

**Date:** November 2022
**Amount Lost:** Unclear
**Root Cause Category:** Oracle manipulation

### Technical Mechanism (UNVERIFIED)

Another oracle manipulation attack on Solend/Save protocol.

**Possible Attack Flow (REQUIRES VERIFICATION):**
1. Attacker manipulated oracle prices for a specific asset
2. Used inflated collateral values to borrow assets
3. Drained protocol funds

**RESEARCH NEEDED:**
- Specific oracle manipulated
- Technical mechanism
- Amount lost
- How it differed from Mango exploit

### Detection Strategy
Same as Mango Markets - oracle security, circuit breakers, position limits.

### Sources Required
- Solend/Save statement
- Security analysis
- Helius blog post

**CONFIDENCE: VERY LOW** - Minimal information from training data

---

## 13. Raydium Exploit (December 2022, $4.4M)

**Date:** December 2022
**Amount Lost:** ~$4.4 million
**Root Cause Category:** Admin key compromise

### Technical Mechanism (PARTIALLY VERIFIED)

This was a private key compromise, not a smart contract vulnerability.

**Attack Flow:**
1. Attacker obtained the admin private key for Raydium
2. The key had authority over protocol functions (possibly pool management)
3. Used the key to execute unauthorized transactions
4. Drained ~$4.4M from the protocol

**Key Technical Details (REQUIRES VERIFICATION):**
- How was the key compromised? (phishing, malware, insider, hack?)
- What authority did the key have?
- What functions were called?
- Was there a multisig, and how was it bypassed?

### Vulnerable Pattern
```rust
// Single key with excessive authority
pub const ADMIN_PUBKEY: Pubkey = pubkey!("AdminKey...");

#[derive(Accounts)]
pub struct AdminWithdraw<'info> {
    #[account(
        constraint = authority.key() == ADMIN_PUBKEY @ ErrorCode::Unauthorized
    )]
    pub authority: Signer<'info>,

    #[account(mut)]
    pub protocol_vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,
}

// VULNERABILITY: Single key can drain entire protocol
pub fn admin_withdraw(ctx: Context<AdminWithdraw>, amount: u64) -> Result<()> {
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.protocol_vault.to_account_info(),
                to: ctx.accounts.destination.to_account_info(),
                authority: ctx.accounts.vault_authority.to_account_info(),
            }
        ),
        amount
    )?;

    Ok(())
}
```

### Secure Pattern
```rust
use squads_multisig_program::state::Ms;

// Use multisig for all admin functions
#[derive(Accounts)]
pub struct AdminWithdraw<'info> {
    // Require multisig transaction, not single key
    #[account(
        constraint = multisig.threshold <= multisig.signers.len() @ ErrorCode::InvalidMultisig
    )]
    pub multisig: Account<'info, Ms>,

    #[account(
        constraint = transaction.did_execute == false @ ErrorCode::AlreadyExecuted,
        constraint = transaction.signers.iter().filter(|s| *s).count() >= multisig.threshold @ ErrorCode::NotEnoughSigners
    )]
    pub transaction: Account<'info, MsTransaction>,

    #[account(mut)]
    pub protocol_vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,
}

// SECURE: Requires M-of-N signatures
pub fn admin_withdraw(ctx: Context<AdminWithdraw>, amount: u64) -> Result<()> {
    // Verify multisig requirements
    verify_multisig_transaction(&ctx.accounts.multisig, &ctx.accounts.transaction)?;

    // Limit withdrawal amount (daily/weekly caps)
    let config = &ctx.accounts.config;
    require!(
        amount <= config.max_daily_withdrawal,
        ErrorCode::ExceedsWithdrawalLimit
    );

    // Timelock (delay between proposal and execution)
    let clock = Clock::get()?;
    require!(
        clock.unix_timestamp >= ctx.accounts.transaction.created_at + TIMELOCK_DURATION,
        ErrorCode::TimelockNotExpired
    );

    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.protocol_vault.to_account_info(),
                to: ctx.accounts.destination.to_account_info(),
                authority: ctx.accounts.vault_authority.to_account_info(),
            }
        ),
        amount
    )?;

    ctx.accounts.transaction.did_execute = true;

    Ok(())
}

// Additional security: Key rotation
pub struct AdminAuthority {
    pub current_keys: Vec<Pubkey>,
    pub pending_keys: Option<Vec<Pubkey>>,
    pub rotation_scheduled: i64,
}

pub fn schedule_key_rotation(ctx: Context<ScheduleRotation>, new_keys: Vec<Pubkey>) -> Result<()> {
    let authority = &mut ctx.accounts.authority;
    let clock = Clock::get()?;

    authority.pending_keys = Some(new_keys);
    authority.rotation_scheduled = clock.unix_timestamp + ROTATION_TIMELOCK;

    Ok(())
}
```

### Operational Security Best Practices
1. **Use hardware wallets** for admin keys
2. **Implement multisig** (at least 3-of-5 or 4-of-7)
3. **Geographic distribution** of signers
4. **Timelock critical operations** (24-48 hour delay)
5. **Withdrawal limits** (daily/weekly caps)
6. **Key rotation** (regularly update keys)
7. **Cold storage** (keep keys offline when not in use)
8. **Monitoring** (alert on any admin function calls)
9. **Audit logs** (track all admin operations)
10. **Incident response plan** (what to do if key compromised)

### Detection Strategy (for auditors)
- Check if admin functions use multisig
- Verify timelock implementation
- Review withdrawal limits
- Ask about key management practices
- Check if upgrade authority is secure
- Verify emergency pause mechanisms exist

### Lessons Learned
1. **Single key is single point of failure**
2. **Operational security matters as much as code security**
3. **Multisig is essential for DeFi protocols**
4. **Timelock provides circuit breaker if key compromised**
5. **Limit admin powers** (withdrawal caps, function restrictions)
6. **Key compromise can happen to anyone** (phishing, malware, etc.)

### Sources Required
- Raydium official statement
- Details on key compromise method
- Helius blog post

**CONFIDENCE: MEDIUM** - Key compromise incidents are common, pattern is well-understood

---

## Summary Analysis

### Root Cause Distribution

| Category | Incidents | % |
|----------|-----------|---|
| Missing Account Validation | 3 (Solend Auth?, Cashio, Crema) | 23% |
| Oracle/Price Manipulation | 4 (Nirvana, Mango, Save/Solend, UXD/Tulip cascade) | 31% |
| Key Compromise | 2 (Slope, Raydium) | 15% |
| Signature Verification | 1 (Wormhole) | 8% |
| Operational Error | 1 (OptiFi) | 8% |
| Uninitialized Storage | 1 (Audius) | 8% |
| Needs Research | 1 (Tulip) | 8% |

### Confidence Assessment

| Confidence | Incidents |
|------------|-----------|
| HIGH | 1 (OptiFi) |
| MEDIUM | 5 (Wormhole, Cashio, Slope, Mango, Raydium) |
| LOW | 6 (Solend Auth, Crema, Audius, Nirvana, UXD, Save/Solend) |
| VERY LOW | 1 (Tulip) |

### Key Patterns for Auditors

1. **Account Validation is #1 Risk**
   - Always check `constraint` on token accounts
   - Verify mint addresses match expected values
   - Use PDAs instead of arbitrary accounts

2. **Oracle Security is Critical**
   - Never use instant AMM prices for critical operations
   - Implement circuit breakers
   - Use TWAP or external oracles (Pyth, Switchboard)
   - Check oracle staleness and confidence

3. **Operational Security Matters**
   - Multisig for admin functions
   - Timelock for critical operations
   - Key management best practices
   - Test on devnet first

4. **Composability Creates Risk**
   - External protocol dependencies are attack vectors
   - Cascading failures happen
   - Diversify integrations
   - Monitor external protocol health

### Research Gaps (HIGH PRIORITY)

The following incidents need comprehensive web research:

1. **Solend Auth Bypass (Aug 2021)** - No technical details in training data
2. **Crema Finance (Jul 2022)** - Partial understanding, need specifics
3. **Audius Governance (Jul 2022)** - Unclear mechanism
4. **Nirvana Finance (Jul 2022)** - Need technical details on flash loan mechanism
5. **UXD Protocol (Oct 2022)** - Cascade effect needs documentation
6. **Tulip Protocol (Oct 2022)** - Almost no information
7. **Save/Solend (Nov 2022)** - Minimal details
8. **Raydium (Dec 2022)** - How was key compromised?

### Sources Required

**Primary Source:**
- Helius Blog: https://www.helius.dev/blog/solana-hacks

**Per-Incident Research Needed:**
- Protocol post-mortems (official blogs)
- Security firm analyses (OtterSec, Neodyme, Zellic, CertiK)
- GitHub issues/PRs with fixes
- Twitter threads from security researchers
- Court documents (Mango/Eisenberg case)

---

## RESEARCH STATUS: INCOMPLETE

This document represents the limit of what can be compiled from training data alone. To create a comprehensive knowledge base suitable for security audits, the following research must be completed:

**Required Actions:**
1. Fetch Helius blog post for accurate overview
2. Search for each incident's technical writeup
3. Verify all code patterns with actual source code
4. Cross-reference multiple sources for each incident
5. Update confidence levels after verification
6. Add specific exploit transaction IDs where available
7. Include links to fixed code (GitHub PRs)

**Estimated Completeness:** 40-50%
- High confidence: ~8%
- Medium confidence: ~38%
- Low/Unverified: ~54%

**Next Steps:**
Re-run this research with WebSearch and WebFetch enabled to achieve 90%+ confidence across all incidents.

---

## Metadata

**Research Date:** 2026-02-06
**Researcher:** GSD Phase Researcher (Training Data Only)
**Tool Limitations:** WebSearch and WebFetch unavailable
**Source:** Training data (cutoff: January 2025)
**Total Incidents:** 13
**Time Period:** August 2021 - December 2022
**Total Documented Losses:** ~$513M+ (verified incidents)
**Confidence:** LOW - Requires web research for verification

**Valid Until:** This document requires immediate web research to be considered valid. Training data alone is insufficient for security audit knowledge base.
