# Proptest Suite Template

Use this template to generate Proptest property-based testing suites. Proptest is the universal fast verification layer — every invariant gets a Proptest suite.

## When to Use Proptest

- **Always** — Proptest is the first line of defense. Fast, catches obvious failures.
- Runs 10,000+ random inputs by default
- Shrinker finds minimal failing inputs automatically
- Complements Kani (which proves exhaustively but is slower) and LiteSVM (which tests at runtime but with specific inputs)

## Template Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `{FUNCTION_NAME}` | Function being tested | `calculate_swap_output` |
| `{MODULE_PATH}` | Import path | `crate::math::swap` |
| `{PROPERTY_NAME}` | Snake_case property | `output_never_exceeds_reserve` |
| `{INPUT_STRATEGIES}` | Proptest strategies | `1u64..1_000_000_000_000u64` |
| `{PROPERTY_ASSERTION}` | `prop_assert!()` call | See patterns below |

## Base Template

```rust
// BOK Proptest Suite — {FUNCTION_NAME}
// Generated by Book of Knowledge

use proptest::prelude::*;
use {MODULE_PATH}::*;

// Custom strategies for realistic inputs
prop_compose! {
    fn realistic_amount()(amount in 1u64..1_000_000_000_000u64) -> u64 {
        amount
    }
}

prop_compose! {
    fn realistic_bps()(bps in 1u64..10_000u64) -> u64 {
        bps
    }
}

prop_compose! {
    fn realistic_reserve()(reserve in 1_000u64..1_000_000_000_000_000u64) -> u64 {
        reserve
    }
}

proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_{PROPERTY_NAME}(
        {INPUTS}
    ) {
        {PROPERTY_ASSERTION}
    }
}
```

## Common Patterns

### Overflow Safety

```rust
proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_no_overflow_{FUNCTION_NAME}(
        a in 1u64..u64::MAX,
        b in 1u64..u64::MAX,
    ) {
        // Function should never panic — it must use checked arithmetic
        let result = std::panic::catch_unwind(|| {
            {FUNCTION_NAME}(a, b)
        });
        prop_assert!(result.is_ok(), "Panicked with inputs: a={}, b={}", a, b);
    }
}
```

### Conservation of Value

```rust
proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_conservation_{FUNCTION_NAME}(
        input_amount in realistic_amount(),
        reserve_a in realistic_reserve(),
        reserve_b in realistic_reserve(),
    ) {
        let (output, fee) = {FUNCTION_NAME}(input_amount, reserve_a, reserve_b);

        // Value must be conserved: output + fee == input (within rounding)
        let total_out = output.checked_add(fee).unwrap_or(u64::MAX);
        let diff = if total_out > input_amount {
            total_out - input_amount
        } else {
            input_amount - total_out
        };
        prop_assert!(diff <= 1,
            "Conservation violated: input={} output={} fee={} diff={}",
            input_amount, output, fee, diff);
    }
}
```

### Rounding Direction

```rust
proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_fee_rounds_up_{FUNCTION_NAME}(
        amount in realistic_amount(),
        rate_bps in realistic_bps(),
    ) {
        let fee = {FUNCTION_NAME}(amount, rate_bps);

        // Fee must never be zero when both inputs are nonzero
        prop_assert!(fee > 0,
            "Fee rounded to zero: amount={} rate_bps={}", amount, rate_bps);

        // Fee must not exceed principal
        prop_assert!(fee <= amount,
            "Fee exceeds principal: fee={} amount={}", fee, amount);

        // Fee must be at least floor(amount * rate / 10000)
        let floor_fee = (amount as u128 * rate_bps as u128 / 10_000u128) as u64;
        prop_assert!(fee >= floor_fee,
            "Fee below floor: fee={} floor={}", fee, floor_fee);
    }
}
```

### Monotonicity

```rust
proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_monotonic_{FUNCTION_NAME}(
        a in realistic_amount(),
        b in realistic_amount(),
        reserve in realistic_reserve(),
    ) {
        prop_assume!(a < b); // Ensure a < b for comparison

        let result_a = {FUNCTION_NAME}(a, reserve);
        let result_b = {FUNCTION_NAME}(b, reserve);

        // Larger input should give larger (or equal) output
        prop_assert!(result_b >= result_a,
            "Monotonicity violated: f({})={} > f({})={}", a, result_a, b, result_b);
    }
}
```

### K-Invariant (Constant Product)

```rust
proptest! {
    #![proptest_config(ProptestConfig::with_cases(10_000))]

    #[test]
    fn prop_k_invariant_{FUNCTION_NAME}(
        input_amount in realistic_amount(),
        reserve_a in realistic_reserve(),
        reserve_b in realistic_reserve(),
    ) {
        let k_before = (reserve_a as u128) * (reserve_b as u128);

        let (output, _fee) = {FUNCTION_NAME}(input_amount, reserve_a, reserve_b);
        let new_reserve_a = reserve_a + input_amount;
        let new_reserve_b = reserve_b - output;

        let k_after = (new_reserve_a as u128) * (new_reserve_b as u128);

        // K must not decrease (fees should increase it)
        prop_assert!(k_after >= k_before,
            "K decreased: before={} after={}", k_before, k_after);
    }
}
```

## Proptest Tips

- Default 10,000 cases is good for most properties. Increase for critical math.
- `prop_assume!()` skips invalid inputs (use sparingly — too many skips reduce coverage)
- The shrinker automatically finds minimal failing inputs
- Use `prop_compose!` for complex input generation
- Edge cases to include in strategies: 0, 1, u64::MAX, near-overflow boundaries
- Run with `PROPTEST_CASES=100000` env var for deeper testing
