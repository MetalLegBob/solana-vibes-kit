# AI-Generated Code Pitfalls: Frontend & Client
<!-- Domain: frontend -->
<!-- Relevant auditors: FE-01, FE-02, FE-03 -->

Common security mistakes AI code generators make when producing frontend and client-side code. These patterns appear frequently in code generated by ChatGPT, Claude, Copilot, and similar LLMs. They look correct, often compile and run without errors, but introduce serious security vulnerabilities in dApp frontends and mobile applications.

---

## AIP-094: Storing Auth Tokens in localStorage

**Affects patterns:** OC-186, OC-187
**Severity:** HIGH

When asked to implement authentication in a React or Next.js app, AI generators consistently store JWTs and session tokens in `localStorage`. This is the single most common AI-generated frontend security mistake. The generated code works perfectly -- login, logout, token refresh, protected routes -- but every token is trivially stealable via any XSS vector.

```typescript
// AI-generated: "Add JWT auth to my Next.js Solana dApp"
async function login(signature: Uint8Array) {
  const res = await fetch('/api/auth/verify', {
    method: 'POST',
    body: JSON.stringify({ signature: bs58.encode(signature) }),
  });
  const { token } = await res.json();
  // AI always does this -- it's the #1 pattern in training data
  localStorage.setItem('auth_token', token);
}

function useAuthFetch() {
  return (url: string, opts?: RequestInit) =>
    fetch(url, {
      ...opts,
      headers: {
        ...opts?.headers,
        Authorization: `Bearer ${localStorage.getItem('auth_token')}`,
      },
    });
}

// SECURE alternative: Use HttpOnly cookies set by the server
// The token never touches JavaScript -- browser sends it automatically
async function login(signature: Uint8Array) {
  await fetch('/api/auth/verify', {
    method: 'POST',
    credentials: 'include', // Server sets HttpOnly cookie in response
    body: JSON.stringify({ signature: bs58.encode(signature) }),
  });
}
```

**Why AI does this:** localStorage-based auth dominates Stack Overflow answers and tutorial blogs. LLMs learn that `localStorage.setItem('token', jwt)` is the "standard" approach because it appears thousands of times in training data. HttpOnly cookie setups require server-side configuration that LLMs do not generate unless specifically prompted.

**Detection:** `grep -rn "localStorage.*token\|localStorage.*jwt\|localStorage.*auth" -i --include="*.ts" --include="*.tsx"`

---

## AIP-095: Missing SRI on CDN Script Tags

**Affects patterns:** OC-191, OC-193
**Severity:** MEDIUM

When AI generates HTML templates or Next.js `<Head>` sections that include external scripts, it never includes the `integrity` attribute for Subresource Integrity. The AI correctly fetches from CDN URLs and even chooses pinned versions, but omits the SRI hash that would protect against CDN compromise.

```html
<!-- AI-generated: "Add Chart.js and Solana web3.js from CDN" -->
<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- SECURE alternative: Always include integrity and crossorigin -->
<script
  src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"
  integrity="sha384-correctHashHere"
  crossorigin="anonymous"
></script>
```

**Why AI does this:** SRI hashes are content-specific and change with each version. LLMs cannot compute SHA-384 hashes at generation time, so they omit the `integrity` attribute entirely rather than produce a wrong hash. The resulting code loads and runs fine without SRI.

**Detection:** `grep -rn "<script.*src=.*http" --include="*.html" --include="*.tsx" | grep -v "integrity="`

---

## AIP-096: postMessage Listener Without Origin Validation

**Affects patterns:** OC-194
**Severity:** HIGH

AI generators routinely produce `window.addEventListener('message', handler)` code that processes messages from any origin. When asked to implement cross-window communication, wallet popup callbacks, or iframe messaging, the AI focuses on making the functionality work without adding origin validation. This is exploitable by any page that can open or frame the target.

```typescript
// AI-generated: "Handle wallet connection callback via postMessage"
window.addEventListener('message', (event) => {
  // AI skips origin validation entirely
  if (event.data.type === 'WALLET_CONNECTED') {
    setWallet(event.data.publicKey);
  }
  if (event.data.type === 'TX_SIGNED') {
    submitTransaction(event.data.signature);
  }
});

// SECURE alternative:
const TRUSTED_ORIGINS = new Set(['https://phantom.app', 'https://solflare.com']);
window.addEventListener('message', (event) => {
  if (!TRUSTED_ORIGINS.has(event.origin)) return; // Validate origin first
  if (event.data.type === 'WALLET_CONNECTED') {
    setWallet(event.data.publicKey);
  }
});
```

**Why AI does this:** Most postMessage tutorials and examples in training data focus on making cross-origin communication work. Origin validation is shown as an "optional" step. Since the code works identically with or without the check during development (same origin), the AI optimizes for the simpler version.

**Detection:** `grep -rn "addEventListener.*message" --include="*.ts" --include="*.tsx" | xargs grep -L "event\.origin\|\.origin"`

---

## AIP-097: Using Math.random() for Security Values

**Affects patterns:** OC-201
**Severity:** HIGH

When AI generates code that needs random values -- nonces, CSRF tokens, session IDs, unique identifiers -- it defaults to `Math.random()`. The AI produces perfectly formatted random-looking strings, but `Math.random()` is a non-cryptographic PRNG whose output is predictable and reversible.

```typescript
// AI-generated: "Generate a nonce for Sign-In With Solana"
function generateNonce(): string {
  return Math.random().toString(36).substring(2, 15);
}

// AI-generated: "Create a CSRF token"
function csrfToken(): string {
  return [...Array(32)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
}

// SECURE alternative:
function generateNonce(): string {
  return Array.from(crypto.getRandomValues(new Uint8Array(32)),
    b => b.toString(16).padStart(2, '0')).join('');
}
```

**Why AI does this:** `Math.random()` is the most commonly used random function in JavaScript training data. `crypto.getRandomValues()` has a more complex API (requires typed arrays). LLMs default to the simpler, more frequently seen pattern.

**Detection:** `grep -rn "Math\.random" --include="*.ts" --include="*.tsx" | grep -i "nonce\|token\|secret\|csrf\|salt\|key\|session\|id"`

---

## AIP-098: Client-Side Route Guards Without Server-Side Enforcement

**Affects patterns:** OC-205
**Severity:** HIGH

When asked to "add authentication to routes" or "protect admin pages," AI generators implement client-side route guards that check `isAuthenticated` or `role` in React context/state. The AI correctly redirects unauthenticated users from the UI, but it does not add corresponding server-side authorization checks on the API endpoints that serve the protected data.

```typescript
// AI-generated: "Protect admin dashboard route"
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, role } = useAuth();
  if (!isAuthenticated) return <Navigate to="/login" />;
  if (role !== 'admin') return <Navigate to="/unauthorized" />;
  return <>{children}</>;
}

// AI generates the admin page -- but the API route has NO auth check
// pages/api/admin/users.ts (AI-generated)
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const users = await db.users.findMany(); // No session check!
  res.json(users);
}

// SECURE: Every API route must independently verify authorization
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getServerSession(req, res, authOptions);
  if (!session || session.user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }
  const users = await db.users.findMany();
  res.json(users);
}
```

**Why AI does this:** The AI treats the route guard as "the" auth solution. It generates the client-side component first (because that is what was asked for), and when generating API routes, it focuses on the data-fetching logic. Unless the prompt specifically says "add auth to the API route," the LLM omits it.

**Detection:** Compare files containing `ProtectedRoute` or `RequireAuth` against API route files -- look for API handlers that lack `getServerSession`, `verifyToken`, or similar server-side checks.

---

## AIP-099: Sensitive Data in NEXT_PUBLIC_ Environment Variables

**Affects patterns:** OC-202
**Severity:** MEDIUM

AI generators do not consistently distinguish between server-only and client-exposed environment variables. When asked to configure API keys, RPC endpoints, or database URLs, the AI frequently prefixes everything with `NEXT_PUBLIC_` (or `VITE_`) to make the variables accessible in the code it is generating, without considering that these values end up in the client bundle.

```typescript
// AI-generated .env.local
NEXT_PUBLIC_DATABASE_URL=postgres://user:pass@db.example.com/mydb
NEXT_PUBLIC_RPC_API_KEY=helius_api_key_12345
NEXT_PUBLIC_ADMIN_SECRET=supersecret

// AI-generated component that uses these
const rpcUrl = `https://rpc.helius.xyz/?api-key=${process.env.NEXT_PUBLIC_RPC_API_KEY}`;

// SECURE: Only NEXT_PUBLIC_ for truly public values
// .env.local
NEXT_PUBLIC_RPC_URL=https://rpc.helius.xyz  // No key in URL
RPC_API_KEY=helius_api_key_12345            // Server-only, no prefix
DATABASE_URL=postgres://...                  // Server-only
```

**Why AI does this:** The AI encounters the "process.env is undefined" error pattern in its training data and learns that `NEXT_PUBLIC_` (or `VITE_`) is the fix. It applies this prefix universally without reasoning about which values are sensitive.

**Detection:** `grep -rn "NEXT_PUBLIC_.*KEY\|NEXT_PUBLIC_.*SECRET\|NEXT_PUBLIC_.*PASSWORD\|NEXT_PUBLIC_.*DATABASE\|VITE_.*KEY\|VITE_.*SECRET" -i --include="*.env*" --include="*.ts"`

---

## AIP-100: AsyncStorage for Sensitive Data in React Native

**Affects patterns:** OC-198
**Severity:** HIGH

When building React Native mobile apps, AI generators use `AsyncStorage` for all persistent data -- including auth tokens, API keys, and in crypto wallet contexts, even private keys or seed phrases. AsyncStorage stores data in unencrypted SQLite on Android and plaintext plists on iOS. The AI never suggests `expo-secure-store` or `react-native-keychain` unless the prompt explicitly asks about secure storage.

```typescript
// AI-generated: "Save wallet credentials in React Native"
import AsyncStorage from '@react-native-async-storage/async-storage';

await AsyncStorage.setItem('auth_token', token);
await AsyncStorage.setItem('wallet_seed', seedPhrase); // Catastrophic!
await AsyncStorage.setItem('pin_hash', hashedPin);

// SECURE alternative:
import * as SecureStore from 'expo-secure-store';

await SecureStore.setItemAsync('auth_token', token, {
  keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
});
```

**Why AI does this:** `AsyncStorage` is the most-documented React Native storage solution and appears in virtually every tutorial. `expo-secure-store` and `react-native-keychain` are specialized libraries the AI treats as optional extras.

**Detection:** `grep -rn "AsyncStorage.*setItem.*token\|AsyncStorage.*setItem.*key\|AsyncStorage.*setItem.*seed\|AsyncStorage.*setItem.*secret" -i --include="*.ts" --include="*.tsx"`

---

## AIP-101: No Data Cleanup on Logout/Disconnect

**Affects patterns:** OC-188
**Severity:** MEDIUM

AI-generated logout and wallet disconnect handlers typically clear the auth state variable (setting `isAuthenticated = false` or calling `disconnect()`) but forget to clear localStorage, sessionStorage, IndexedDB, and React Query caches. The AI focuses on the state transition and overlooks persistent storage cleanup.

```typescript
// AI-generated: "Add logout button to wallet dApp"
function LogoutButton() {
  const { disconnect } = useWallet();
  const { setUser } = useAuth();

  const handleLogout = () => {
    disconnect();
    setUser(null);
    router.push('/');
    // AI stops here -- localStorage, sessionStorage, IndexedDB all retain data
  };

  return <button onClick={handleLogout}>Disconnect</button>;
}

// SECURE: Clear ALL client-side storage
const handleLogout = async () => {
  await disconnect();
  setUser(null);
  localStorage.clear();
  sessionStorage.clear();
  queryClient.clear();
  await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
  window.location.href = '/'; // Hard redirect clears in-memory state
};
```

**Why AI does this:** Logout tutorials focus on clearing auth state. The "clear all storage" pattern is less common in training data. The AI also avoids `localStorage.clear()` because it might delete unrelated application data, but this caution leads it to skip cleanup entirely.

**Detection:** Find logout/disconnect handlers and verify they include `localStorage.clear()` or `removeItem` calls for all sensitive keys.

---

## AIP-102: Rendering Seed Phrases Directly in DOM

**Affects patterns:** OC-203
**Severity:** HIGH

When asked to build a wallet backup or seed phrase display component, AI generators render the full mnemonic as a grid of `<span>` elements in the DOM. This makes the seed phrase readable by any browser extension, screen reader, session replay tool, or DOM scraper. The AI also typically adds a "Copy to Clipboard" button, which makes the seed phrase accessible via the clipboard API.

```typescript
// AI-generated: "Create seed phrase backup component"
function SeedPhraseDisplay({ mnemonic }: { mnemonic: string }) {
  return (
    <div className="grid grid-cols-3 gap-2">
      {mnemonic.split(' ').map((word, i) => (
        <div key={i} className="p-2 bg-gray-100 rounded">
          <span className="text-gray-500">{i + 1}.</span> {word}
        </div>
      ))}
      <button onClick={() => navigator.clipboard.writeText(mnemonic)}>
        Copy All Words
      </button>
    </div>
  );
}

// SECURE: Progressive reveal, no clipboard, timed display
// See OC-203 for the secure implementation pattern
```

**Why AI does this:** The AI generates the most straightforward React component for displaying a list of words. The concept of "DOM exposure to extensions" is not a common pattern in training data. Clipboard copying is a standard UX pattern the AI includes by default.

**Detection:** `grep -rn "mnemonic\|seedPhrase\|seed_phrase" --include="*.tsx" --include="*.jsx" | grep -v "test\|spec\|mock"`

---

## AIP-103: Trusting window.solana Without Verification

**Affects patterns:** OC-203, OC-197
**Severity:** MEDIUM

AI-generated wallet connection code checks for `window.solana` or `window.ethereum` and calls `.connect()` without any verification that the injected provider is the real wallet extension. Malicious browser extensions can inject a fake `window.solana` object that intercepts connection requests, captures signing calls, and replaces transaction payloads.

```typescript
// AI-generated: "Connect to Phantom wallet"
async function connectWallet() {
  const provider = (window as any).solana;
  if (provider?.isPhantom) {
    // AI trusts the isPhantom flag -- but a malicious extension sets this too
    const response = await provider.connect();
    return response.publicKey.toString();
  }
  throw new Error('Phantom wallet not found');
}

// SECURE: Use @solana/wallet-adapter which provides standard detection
// and handles provider verification through the wallet-standard protocol
import { useWallet } from '@solana/wallet-adapter-react';
function ConnectButton() {
  const { select, connect, wallets } = useWallet();
  // wallet-adapter uses wallet-standard for provider discovery
  // which is harder (though not impossible) for extensions to fake
}
```

**Why AI does this:** Direct `window.solana` access is the pattern shown in Phantom's original documentation and countless tutorials. The wallet-adapter library abstraction is newer and less represented in training data. The AI generates what it has seen most frequently.

**Detection:** `grep -rn "window\.solana\|window\.ethereum\|window\.phantom\|window\.solflare" --include="*.ts" --include="*.tsx" | grep -v "\.d\.ts"`
