# VP-020: Share Dilution Fairness on New Deposits

**Category:** Staking Rewards
**Verification tool:** LiteSVM

## What Can Go Wrong
When a new staker deposits, they should not receive credit for rewards that accrued before their deposit. If the reward accumulator isn't snapshotted at deposit time, the new staker claims a proportional share of all historical rewards, diluting existing stakers.

## Why It Matters
An attacker can deposit a large amount just before a reward distribution, claim a disproportionate share of rewards, then immediately withdraw. This "vampire attack" on the reward pool drains value from long-term stakers.

## Real-World Incident
The ERC-4626 inflation attack (first depositor attack) is one of the best-documented DeFi vulnerabilities. An attacker deposits 1 wei, donates a large amount to inflate share price, then subsequent depositors receive fewer shares than expected. OpenZeppelin's ERC-4626 implementation includes explicit mitigations. The Resupply exploit demonstrated this attack vector in practice.

## Invariant

### Formal Property
```
For staker depositing at time T:
  user.reward_debt = pool.reward_per_token_stored * user.staked_amount
  user can only earn rewards accrued AFTER time T
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_retroactive_rewards() {
    let pool_rpt: u128 = kani::any(); // reward per token at deposit time
    let deposit_amount: u64 = kani::any();

    kani::assume!(pool_rpt > 0 && pool_rpt < u128::MAX / 2);
    kani::assume!(deposit_amount > 0 && deposit_amount < u64::MAX / 2);

    let reward_debt = pool_rpt * (deposit_amount as u128) / PRECISION;

    // At claim time with same rpt, reward should be 0
    let pending = pool_rpt * (deposit_amount as u128) / PRECISION - reward_debt;
    kani::assert!(pending == 0, "new staker earned retroactive rewards");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn new_deposit_earns_zero_initially(
        rpt_stored in 1u128..1_000_000_000,
        deposit in 1u64..1_000_000_000
    ) {
        let reward_debt = rpt_stored * (deposit as u128) / PRECISION;
        let pending = rpt_stored * (deposit as u128) / PRECISION - reward_debt;
        prop_assert_eq!(pending, 0, "retroactive reward earned");
    }
}
```

### LiteSVM Assertion
```rust
// Alice stakes at T=0, earns rewards for 100 seconds
// Bob stakes at T=100
// At T=100, Bob's pending rewards must be 0
advance_clock(&mut ctx, 100).await;
stake(&mut ctx, &bob, bob_amount).await.unwrap();
let bob_pending = get_pending_reward(&ctx, &bob).await;
assert_eq!(bob_pending, 0, "Bob earned retroactive rewards");
```

## Suggested Fix
```rust
pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    update_reward_per_token(pool, Clock::get()?.unix_timestamp as u64)?;

    let user = &mut ctx.accounts.user_stake;
    // Snapshot current reward_per_token as debt
    user.reward_debt = pool.reward_per_token_stored
        .checked_mul(amount as u128)?
        / PRECISION;
    user.staked_amount = user.staked_amount.checked_add(amount)?;
    pool.total_staked = pool.total_staked.checked_add(amount)?;
    // Transfer tokens...
    Ok(())
}
```
