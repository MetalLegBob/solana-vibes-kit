# VP-067: Margin of Safety Maintenance

**Category:** Collateral Ratios
**Verification tool:** Proptest

## What Can Go Wrong
There must be a sufficient buffer (margin of safety) between a position's current LTV and the liquidation threshold. Without this buffer, any small price movement immediately triggers liquidation, giving borrowers no time to add collateral. If the margin check is missing from the borrow instruction, users can open positions right at the liquidation boundary that become instantly liquidatable.

## Why It Matters
Without adequate margin of safety, an attacker can create positions right at the liquidation boundary, then use small oracle price manipulations to force liquidations on demand. This lets the attacker systematically harvest liquidation bonuses from positions that would be healthy under normal market conditions. The attacker profits while borrowers lose collateral to forced liquidations they had no chance to prevent.

## Real-World Incident
No specific public incident documented, but margin of safety configuration issues have been identified in multiple Solana lending protocol audits. The Jet Protocol audit recommended enforcing a minimum gap between borrow LTV and liquidation LTV to prevent users from creating instantly-liquidatable positions.

## Invariant

### Formal Property
```
forall new_position:
  current_ltv_bps + MIN_MARGIN_BPS <= liquidation_threshold_bps
  MIN_MARGIN_BPS >= 200 (2%)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_margin_of_safety() {
    let current_ltv: u64 = kani::any();
    let liq_threshold: u64 = kani::any();
    let min_margin: u64 = kani::any();

    kani::assume!(current_ltv > 0 && current_ltv <= 10_000);
    kani::assume!(liq_threshold > 0 && liq_threshold <= 10_000);
    kani::assume!(min_margin >= 200 && min_margin <= 2_000);
    kani::assume!(current_ltv + min_margin <= liq_threshold);

    kani::assert!(current_ltv < liq_threshold);
    kani::assert!(liq_threshold - current_ltv >= min_margin);
    kani::assert!(liq_threshold - current_ltv >= 200);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn margin_always_maintained(
        loan in 1u64..1_000_000_000,
        collateral in 1u64..1_000_000_000,
        liq_threshold_bps in 5_000u64..9_500,
        min_margin_bps in 200u64..1_000,
    ) {
        prop_assume!(collateral > 0);
        let ltv_bps = (loan as u128) * 10_000 / (collateral as u128);
        prop_assume!(ltv_bps <= 10_000);
        let max_borrow_ltv = liq_threshold_bps.saturating_sub(min_margin_bps);

        if ltv_bps <= max_borrow_ltv as u128 {
            // Position accepted: margin is maintained
            prop_assert!(liq_threshold_bps as u128 - ltv_bps >= min_margin_bps as u128);
        } else {
            // Position rejected: would violate margin
            prop_assert!(ltv_bps > max_borrow_ltv as u128);
        }
    }
}
```

### LiteSVM Assertion
```rust
// Attempt to borrow right up to liquidation threshold (no margin)
let near_limit = collateral_value * (liq_threshold_bps - 100) / 10_000;
let result = borrow(&mut ctx, position, near_limit).await;
assert!(result.is_err(), "borrow within margin buffer must be rejected");

// Borrow within safe margin
let safe_amount = collateral_value * (liq_threshold_bps - min_margin_bps) / 10_000;
borrow(&mut ctx, position, safe_amount).await.unwrap();
let state = get_position_state(&ctx, position).await;
assert!(state.ltv_bps + min_margin_bps <= liq_threshold_bps);
```

## Suggested Fix
```rust
pub fn validate_borrow(position: &Position, config: &MarketConfig) -> Result<()> {
    let ltv_bps = calculate_ltv_bps(position.loan_value, position.collateral_value)?;
    let max_borrow_ltv = config.liquidation_threshold_bps
        .checked_sub(config.min_margin_bps)
        .ok_or(LendingError::InvalidConfig)?;

    require!(
        ltv_bps <= max_borrow_ltv,
        LendingError::InsufficientMargin
    );
    Ok(())
}
```
