# VP-062: Dutch Auction Price Decay Correctness

**Category:** Auction
**Verification tool:** Proptest

## What Can Go Wrong
Dutch auction price decreases over time from a start price to an end price. The decay function must be monotonically decreasing. Integer division in the decay calculation can cause price jumps, non-monotonic behavior, or the price getting stuck above the end price due to truncation of small decrements.

## Why It Matters
An attacker monitors the decay function and identifies a timestamp where integer truncation causes a discontinuous price drop. They buy at the exact moment the price jumps, getting a better deal than the smooth curve would provide. Other buyers waiting for gradual decrease miss the opportunity entirely.

## Real-World Incident
No specific public incident documented, but multiple NFT marketplace audits on Solana have flagged integer arithmetic issues in Dutch auction price decay, including cases where the price became non-monotonic near the tail end of the auction.

## Invariant

### Formal Property
```
For start_price > end_price, duration > 0, t1 < t2 <= duration:
  dutch_price(t1) >= dutch_price(t2)
  dutch_price(duration) == end_price
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_dutch_decay_monotonic() {
    let start: u64 = kani::any();
    let end: u64 = kani::any();
    let dur: u64 = kani::any();
    let t1: u64 = kani::any();
    let t2: u64 = kani::any();

    kani::assume!(start > end && end > 0 && start < 1_000_000_000);
    kani::assume!(dur > 0 && dur <= 86_400);
    kani::assume!(t1 < t2 && t2 <= dur);

    let spread = (start - end) as u128;
    let p1 = start as u128 - spread * t1 as u128 / dur as u128;
    let p2 = start as u128 - spread * t2 as u128 / dur as u128;
    kani::assert!(p1 >= p2);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn dutch_decay_monotonic(
        start_price in 1_000u64..1_000_000_000,
        end_price in 1u64..1_000u64,
        duration in 1u64..86_400,
        t1 in 0u64..86_400,
        t2 in 0u64..86_400,
    ) {
        prop_assume!(start_price > end_price);
        prop_assume!(t1 < t2 && t2 <= duration);

        let spread = (start_price - end_price) as u128;
        let p1 = start_price as u128 - spread * t1 as u128 / duration as u128;
        let p2 = start_price as u128 - spread * t2 as u128 / duration as u128;
        prop_assert!(p1 >= p2, "price must decrease: p1={} p2={}", p1, p2);
    }
}
```

### LiteSVM Assertion
```rust
let auction = create_dutch_auction(&mut ctx, seller, start_price, end_price, duration).await;

ctx.warp_to_slot(slot_at_t1);
let price_early = fetch_current_price(&ctx, auction).await;
ctx.warp_to_slot(slot_at_t2);
let price_late = fetch_current_price(&ctx, auction).await;

assert!(price_early >= price_late, "price must be monotonically decreasing");
assert!(price_late >= end_price, "price must not drop below end_price before duration");
```

## Suggested Fix
```rust
pub fn dutch_price(elapsed: u64, start: u64, end: u64, duration: u64) -> Result<u64> {
    require!(start > end, AuctionError::InvalidPriceRange);
    require!(duration > 0, AuctionError::ZeroDuration);
    if elapsed >= duration {
        return Ok(end);
    }
    let spread = (start as u128).checked_sub(end as u128).unwrap();
    let decay = spread.checked_mul(elapsed as u128).unwrap() / (duration as u128);
    Ok((start as u128 - decay) as u64)
}
```
