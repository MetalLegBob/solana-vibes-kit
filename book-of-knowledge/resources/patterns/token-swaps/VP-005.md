# VP-005: Fee Extraction Doesn't Exceed Principal

**Category:** Token Swaps
**Verification tool:** Kani

## What Can Go Wrong
If the fee calculation uses incorrect basis points, wrong denominators, or overflows, the computed fee can exceed the input amount. This would result in an underflow when subtracting fee from input, potentially wrapping to a huge number or causing the swap to consume more tokens than the user sent.

## Why It Matters
A fee exceeding 100% of input is nonsensical and always indicates a bug. If the underflow isn't caught, the user loses their entire input. If it wraps (in unchecked math), the swap may operate on a massive phantom amount.

## Real-World Incident
No specific public incident documented, but fee-exceeds-principal bugs are a common finding in DeFi audits. Multiple Solana program audits by Neodyme and OtterSec flagged this pattern.

## Invariant

### Formal Property
```
âˆ€ input, fee_rate:
  fee(input, fee_rate) <= input
  input - fee(input, fee_rate) >= 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_never_exceeds_input() {
    let input: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(input > 0);
    kani::assume!(fee_bps <= 10_000); // max 100%

    let fee = (input as u128) * (fee_bps as u128) / 10_000;

    // Fee must never exceed input
    kani::assert!(fee <= input as u128);
    // Input after fee must be non-negative
    kani::assert!((input as u128) >= fee);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_bounded_by_principal(
        input in 1u64..u64::MAX,
        fee_bps in 0u16..=10_000
    ) {
        let fee = calculate_fee(input, fee_bps);
        prop_assert!(fee <= input, "fee {} > input {}", fee, input);
        prop_assert!(input - fee <= input, "underflow in input - fee");
    }
}
```

### LiteSVM Assertion
```rust
let user_balance_before = get_token_balance(&ctx, user_token).await;
process_transaction(&mut ctx, swap_ix, &payer).await.unwrap();
let user_balance_after = get_token_balance(&ctx, user_token).await;
// User should never lose more than they sent
let spent = user_balance_before - user_balance_after;
assert!(spent <= input_amount, "spent {} > input {}", spent, input_amount);
```

## Suggested Fix
```rust
pub fn calculate_fee(amount: u64, fee_bps: u16) -> Result<u64> {
    require!(fee_bps <= 10_000, FeeError::InvalidRate);
    let fee = (amount as u128)
        .checked_mul(fee_bps as u128)
        .ok_or(FeeError::Overflow)?
        / 10_000;
    Ok(fee as u64) // Safe: fee <= amount since fee_bps <= 10_000
}
```
