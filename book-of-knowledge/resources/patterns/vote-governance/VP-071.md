# VP-071: Delegation Math Consistency

**Category:** Vote/Governance
**Verification tool:** LiteSVM

## What Can Go Wrong
When a user delegates voting power to another address, the delegatee must receive exactly the delegator's balance. No voting power should be created or destroyed. If the delegatee gains more than the delegator loses, phantom power is minted. If the sum decreases, power is silently burned. Either breaks conservation: total voting power must equal total locked tokens.

## Why It Matters
An attacker exploits delegation math to create phantom voting power. By delegating and undelegating across a ring of controlled addresses, surplus power accumulates each cycle. After enough iterations the attacker holds enough phantom power to unilaterally pass proposals that drain the treasury or grant admin privileges.

## Real-World Incident
Delegation math inconsistencies have been found in multiple DAO governance audits. Compound's GovernorBravo had a documented edge case where self-delegation during a proposal could double-count power. Multiple Solana governance forks have had similar findings.

## Invariant

### Formal Property
```
For delegation from A to B with A's balance bal:
  power(B, after) == power(B, before) + bal
  power(A, after) == 0
  total_power(after) == total_power(before)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_delegation_conservation() {
    let bal_a: u64 = kani::any();
    let existing_b: u64 = kani::any();
    kani::assume!(bal_a > 0 && bal_a < 1_000_000_000_000);
    kani::assume!(existing_b < u64::MAX - bal_a);

    let total_before = (bal_a as u128) + (existing_b as u128);
    let power_a_after: u64 = 0;
    let power_b_after = existing_b.checked_add(bal_a).unwrap();
    let total_after = (power_a_after as u128) + (power_b_after as u128);

    kani::assert!(power_b_after == existing_b + bal_a);
    kani::assert!(power_a_after == 0);
    kani::assert!(total_after == total_before);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn delegation_conserves_power(
        bal_a in 1u64..1_000_000_000,
        existing_b in 0u64..1_000_000_000
    ) {
        let total_before = bal_a as u128 + existing_b as u128;
        let power_b_after = existing_b.checked_add(bal_a).unwrap();
        let total_after = 0u128 + power_b_after as u128;

        prop_assert_eq!(total_after, total_before, "power not conserved");
        prop_assert_eq!(power_b_after, existing_b + bal_a, "delegatee wrong amount");
    }
}
```

### LiteSVM Assertion
```rust
let power_a = get_voting_power(&banks_client, user_a).await;
let power_b = get_voting_power(&banks_client, user_b).await;
let total_before = power_a as u128 + power_b as u128;

process_transaction(&mut banks_client, delegate_ix(user_a, user_b), &payer).await.unwrap();

let power_a_after = get_voting_power(&banks_client, user_a).await;
let power_b_after = get_voting_power(&banks_client, user_b).await;
let total_after = power_a_after as u128 + power_b_after as u128;
assert_eq!(power_a_after, 0, "delegator still has power");
assert_eq!(power_b_after, power_b + power_a, "delegatee power mismatch");
assert_eq!(total_after, total_before, "total power changed");
```

## Suggested Fix
```rust
pub fn delegate(ctx: &mut Context, from: Pubkey, to: Pubkey) -> Result<()> {
    let delegator = &mut ctx.accounts.delegator;
    let delegatee = &mut ctx.accounts.delegatee;
    let amount = delegator.voting_power;
    delegator.voting_power = 0;
    delegatee.voting_power = delegatee.voting_power
        .checked_add(amount).ok_or(GovernanceError::Overflow)?;
    delegator.delegate = Some(to);
    Ok(())
}
```
