# VP-061: Vesting Schedule Modification Safety

**Category:** Vesting
**Verification tool:** LiteSVM

## What Can Go Wrong
When a vesting schedule is modified after creation, the change must not reduce amounts that have already vested. If an admin shortens the duration or reduces the total grant, tokens that should already be unlocked become locked again, effectively stealing from the beneficiary. Conversely, extending the schedule could dilute the vesting rate, causing the beneficiary to receive less per unit of time than originally agreed.

## Why It Matters
A malicious or compromised admin modifies a vesting schedule after the beneficiary has partially vested, reducing the total grant below what has already been claimed, or shortening the duration so the linear curve retroactively reduces the vested amount. Already-vested tokens become inaccessible, and the beneficiary has no recourse if the modification was authorized by the admin key. This is especially dangerous when the admin is a multisig that could be socially compromised.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Admin privilege abuse in vesting contracts is a common audit finding across Solana programs. Several projects have been flagged for allowing unrestricted schedule modifications without protecting already-vested amounts.

## Invariant

### Formal Property
```
forall modification:
  vested_amount(new_params, now) >= vested_amount(old_params, now)
  new_grant >= claimed_so_far
  new_duration > 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_modification_safety() {
    let old_grant: u64 = kani::any();
    let old_duration: u64 = kani::any();
    let new_grant: u64 = kani::any();
    let new_duration: u64 = kani::any();
    let elapsed: u64 = kani::any();

    kani::assume!(old_grant > 0 && old_grant <= 10_000_000_000);
    kani::assume!(old_duration > 0 && old_duration <= 315_360_000);
    kani::assume!(new_grant > 0 && new_grant <= 10_000_000_000);
    kani::assume!(new_duration > 0 && new_duration <= 315_360_000);
    kani::assume!(elapsed > 0 && elapsed <= old_duration);

    let vested_before = (old_grant as u128 * elapsed as u128 / old_duration as u128) as u64;

    // The modification check: new params must not reduce what's already vested
    let vested_after = (new_grant as u128 * elapsed as u128 / new_duration as u128) as u64;
    let modification_safe = vested_after >= vested_before && new_grant >= vested_before;

    // If modification is allowed, invariant must hold
    if modification_safe {
        kani::assert!(vested_after >= vested_before, "modification reduced vested amount");
        kani::assert!(new_grant >= vested_before, "new grant below already vested");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn modification_preserves_vested(
        old_grant in 1_000u64..10_000_000_000,
        old_duration in 86_400u64..315_360_000,  // 1 day to 10 years
        elapsed_pct in 1u64..99,
        grant_delta in -500_000_000i64..500_000_000
    ) {
        let elapsed = old_duration * elapsed_pct / 100;
        let vested_before = (old_grant as u128 * elapsed as u128 / old_duration as u128) as u64;

        let new_grant = (old_grant as i64 + grant_delta).max(1) as u64;
        let new_duration = old_duration; // keep duration same for this test

        let vested_after = (new_grant as u128 * elapsed as u128 / new_duration as u128) as u64;

        // Simulate the validation check
        let should_allow = vested_after >= vested_before && new_grant >= vested_before;
        let result = validate_modification(
            old_grant, old_duration, new_grant, new_duration, elapsed
        );

        if should_allow {
            prop_assert!(result.is_ok(), "rejected safe modification");
        } else {
            prop_assert!(result.is_err(), "accepted unsafe modification: vested_before={} vested_after={}", vested_before, vested_after);
        }
    }
}
```

### LiteSVM Assertion
```rust
let schedule = create_vesting_schedule(&mut ctx, admin, beneficiary, grant, start_ts, duration);

// Warp to 50% vested
ctx.warp_to_timestamp(start_ts + duration / 2);
let vested_before = get_vested_amount(&ctx, schedule);
assert!(vested_before > 0, "should have vested tokens at 50%");

// Attempt to reduce grant below vested amount: must fail
let reduce_result = modify_schedule(&mut ctx, admin, schedule, vested_before - 1, duration);
assert!(
    reduce_result.is_err(),
    "allowed reducing grant below vested amount"
);

// Attempt to increase grant: must succeed and preserve vested amount
let new_grant = grant + 1_000_000;
let increase_result = modify_schedule(&mut ctx, admin, schedule, new_grant, duration);
assert!(increase_result.is_ok(), "rejected valid grant increase");

let vested_after = get_vested_amount(&ctx, schedule);
assert!(
    vested_after >= vested_before,
    "modification reduced vested: {} < {}", vested_after, vested_before
);

// Verify the schedule state is consistent
let state = get_vesting_state(&ctx, schedule);
assert_eq!(state.total_grant, new_grant, "grant not updated");
assert!(state.claimed_so_far <= state.total_grant, "claimed exceeds new grant");
```

## Suggested Fix
```rust
pub fn modify_schedule(
    ctx: Context<ModifySchedule>,
    new_grant: u64,
    new_duration: u64,
) -> Result<()> {
    let schedule = &mut ctx.accounts.vesting_schedule;
    let clock = Clock::get()?;
    let now = clock.unix_timestamp as u64;

    require!(new_grant > 0, VestingError::InvalidGrant);
    require!(new_duration > 0, VestingError::InvalidDuration);

    // Compute what has already vested under the OLD parameters
    let vested_so_far = compute_vested(
        schedule.total_grant, now, schedule.start_ts, schedule.duration,
    )?;

    // New grant must cover everything already vested
    require!(new_grant >= vested_so_far, VestingError::ModificationReducesVested);

    // New parameters must not reduce what has vested at current timestamp
    let would_vest = compute_vested(new_grant, now, schedule.start_ts, new_duration)?;
    require!(
        would_vest >= vested_so_far,
        VestingError::ModificationReducesVested
    );

    schedule.total_grant = new_grant;
    schedule.duration = new_duration;
    emit!(ScheduleModified { schedule: schedule.key(), new_grant, new_duration });
    Ok(())
}
```
