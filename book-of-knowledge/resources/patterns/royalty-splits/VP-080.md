# VP-080: Minimum Payout Threshold

**Category:** Royalty/Revenue Splits
**Verification tool:** LiteSVM

## What Can Go Wrong
When a revenue split produces individual payouts below a minimum threshold, it is more economical to accumulate and distribute later. Without a threshold, an attacker can send thousands of tiny payments to trigger micro-distributions where the transaction fee (5,000 lamports base) exceeds the payout itself. Recipients receive near-zero value while the protocol burns SOL on compute.

## Why It Matters
An attacker sends 10,000 payments of 100 lamports each to a 4-way split. Each distribution triggers 4 transfers of 25 lamports, costing ~5,000 lamports in fees per transaction. Total attack cost: 1 SOL. Total protocol loss: 50 SOL in wasted gas. A minimum threshold of 10,000 lamports prevents this by accumulating until the payout is economically viable.

## Real-World Incident
Multiple Solana NFT marketplace revenue-sharing contracts were flagged for lacking minimum distribution thresholds. Sec3 and OtterSec audit reports have repeatedly recommended threshold-gating distributions to prevent gas-griefing attacks on splitter contracts.

## Invariant

### Formal Property
```
forall payout_i, threshold T:
  payout_i < T  =>  accumulated[i] += payout_i, no transfer
  payout_i >= T =>  transfer(payout_i + accumulated[i]), accumulated[i] = 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_threshold_logic() {
    let payout: u64 = kani::any();
    let accumulated: u64 = kani::any();
    let threshold: u64 = kani::any();
    kani::assume!(payout < 1_000_000_000 && accumulated < 1_000_000_000);
    kani::assume!(threshold > 0 && threshold <= 1_000_000);
    let effective = payout.checked_add(accumulated).unwrap();
    if effective < threshold {
        let new_acc = effective;
        kani::assert!(new_acc == payout + accumulated);
        kani::assert!(new_acc < threshold);
    } else {
        kani::assert!(effective >= threshold);
        let new_acc: u64 = 0;
        kani::assert!(new_acc == 0);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn threshold_boundary_behavior(
        payout in 0u64..100_000,
        accumulated in 0u64..100_000,
        threshold in 1u64..50_000
    ) {
        let effective = payout + accumulated;
        if effective < threshold {
            prop_assert!(effective < threshold);
            prop_assert_eq!(effective, payout + accumulated);
        } else {
            prop_assert!(effective >= threshold);
        }
    }
}
```

### LiteSVM Assertion
```rust
let threshold: u64 = 10_000;
let shares = vec![5000u16, 5000];

// 100 lamports total -> 50 each, below threshold -> accumulate
let ix1 = distribute(&program_id, &split_account, 100);
process_transaction(&mut banks_client, ix1, &payer).await.unwrap();
let state = get_split_state(&banks_client, &split_account).await;
assert_eq!(state.accumulated[0], 50, "should accumulate below threshold");
let bal_a = get_balance(&banks_client, &recipient_a).await;
assert_eq!(bal_a, 0, "no transfer below threshold");

// 30,000 lamports -> 15,000 each + 50 accumulated = 15,050 >= threshold
let ix2 = distribute(&program_id, &split_account, 30_000);
process_transaction(&mut banks_client, ix2, &payer).await.unwrap();
let bal_a = get_balance(&banks_client, &recipient_a).await;
assert_eq!(bal_a, 15_050, "accumulated + new payout transferred");
let state = get_split_state(&banks_client, &split_account).await;
assert_eq!(state.accumulated[0], 0, "accumulator reset after transfer");
```

## Suggested Fix
```rust
pub fn distribute_with_threshold(
    total: u64, shares: &[u16], accumulated: &mut [u64], threshold: u64,
) -> Vec<(usize, u64)> {
    let mut transfers = Vec::new();
    for (i, share) in shares.iter().enumerate() {
        let payout = (total as u128).checked_mul(*share as u128).unwrap() / 10_000;
        let effective = accumulated[i].checked_add(payout as u64).unwrap();
        if effective >= threshold {
            transfers.push((i, effective));
            accumulated[i] = 0;
        } else {
            accumulated[i] = effective;
        }
    }
    transfers
}
```
