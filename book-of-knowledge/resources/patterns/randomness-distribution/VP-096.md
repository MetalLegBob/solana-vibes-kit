# VP-096: Modulo Bias in Random Distribution

**Category:** Randomness/Distribution
**Verification tool:** Proptest

## What Can Go Wrong
When converting a random number to a range using `random % n`, the distribution is biased if n doesn't evenly divide the random number's range. For u64, values 0..n-1 appear (u64::MAX/n + 1) times while values n..u64::MAX%n appear one extra time. This bias is exploitable for high-stakes outcomes.

## Why It Matters
In a lottery or random selection, modulo bias means some outcomes are slightly more likely than others. For a protocol distributing rewards randomly, this creates a measurable unfairness that sophisticated attackers can exploit at scale.

## Real-World Incident
Modulo bias is a classic cryptographic pitfall. Multiple NFT minting protocols on Solana used biased randomness for trait selection, resulting in uneven rarity distributions.

## Invariant

### Formal Property
```
For uniform random r ∈ [0, 2^64) and range n:
  Unbiased: reject r when r >= (2^64 / n) * n, then return r % n
  Bias magnitude: at most 1/2^64 per outcome (negligible for most uses)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rejection_sampling() {
    let r: u64 = kani::any();
    let n: u64 = kani::any();

    kani::assume!(n > 1);

    let limit = u64::MAX - (u64::MAX % n) - 1;
    let unbiased = if r <= limit {
        Some(r % n)
    } else {
        None // reject, resample
    };

    if let Some(result) = unbiased {
        kani::assert!(result < n);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn unbiased_distribution(n in 2u64..1000) {
        let mut counts = vec![0u64; n as usize];
        let samples = 100_000;
        for i in 0..samples {
            let r = pseudo_random(i); // deterministic for testing
            let idx = unbiased_modulo(r, n);
            counts[idx as usize] += 1;
        }
        let expected = samples / n;
        let tolerance = expected / 10; // 10% tolerance
        for (i, &count) in counts.iter().enumerate() {
            prop_assert!((count as i64 - expected as i64).unsigned_abs() < tolerance,
                "bucket {} has {} (expected ~{})", i, count, expected);
        }
    }
}
```

### LiteSVM Assertion
```rust
let mut buckets = [0u32; 10];
for seed in 0..10_000u64 {
    let idx = unbiased_random_range(seed, 10);
    assert!(idx < 10);
    buckets[idx as usize] += 1;
}
// Each bucket should have ~1000 ± 100
for (i, &count) in buckets.iter().enumerate() {
    assert!(count > 800 && count < 1200, "bucket {} = {}", i, count);
}
```

## Suggested Fix
```rust
pub fn unbiased_modulo(random: u64, n: u64) -> u64 {
    // Rejection sampling: discard values that cause bias
    let limit = u64::MAX - (u64::MAX % n);
    debug_assert!(random < limit, "caller must reject and resample");
    random % n
}
```
