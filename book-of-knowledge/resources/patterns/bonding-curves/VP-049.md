# VP-049: Price/Supply Relationship Accuracy

**Category:** Bonding Curves
**Verification tool:** Proptest

## What Can Go Wrong
The implemented price function may diverge from the intended mathematical curve due to integer approximations. For polynomial curves (price = a*supply^2 + b*supply + c), integer overflow in supply^2 or truncation in division can create errors that grow with supply.

## Why It Matters
If the implemented curve diverges from spec, the token economics change unpredictably. Users paying more or less than the designed curve means the protocol's economic model (market cap targets, graduation thresholds) doesn't behave as intended.

## Real-World Incident
No specific public incident documented, but curve accuracy is a common concern in bonding curve audits. The sigmoid and polynomial curves used by some Solana token launchpads required extensive testing to ensure integer math accuracy.

## Invariant

### Formal Property
```
|price_impl(supply) - price_spec(supply)| / price_spec(supply) <= 0.01 (1% tolerance)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_curve_accuracy() {
    let supply: u64 = kani::any();
    kani::assume!(supply > 0 && supply < 1_000_000_000);

    let price = linear_bonding_price(supply);

    // Must be positive
    kani::assert!(price > 0, "zero price at supply {}", supply);
    // Must fit in u64
    kani::assert!(price <= u64::MAX as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn integer_curve_matches_float_curve(supply in 1u64..1_000_000_000) {
        let int_price = bonding_price_integer(supply);
        let float_price = (BASE_PRICE as f64 + SLOPE as f64 * supply as f64 / PRECISION as f64);
        let tolerance = float_price * 0.01; // 1% tolerance
        prop_assert!(
            (int_price as f64 - float_price).abs() <= tolerance.max(1.0),
            "divergence at supply {}: int={} float={}", supply, int_price, float_price
        );
    }
}
```

### LiteSVM Assertion
```rust
// Test at key supply milestones
for supply in [0, 1000, 1_000_000, 100_000_000, 1_000_000_000u64] {
    let price = get_bonding_price(&ctx, supply).await;
    let expected = expected_price_at_supply(supply);
    let tolerance = expected / 100; // 1%
    assert!((price as i128 - expected as i128).unsigned_abs() <= tolerance as u128,
        "price divergence at supply {}: got {} expected {}", supply, price, expected);
}
```

## Suggested Fix
```rust
/// Use u128 intermediates for quadratic curves to prevent overflow
pub fn quadratic_price(supply: u64, a: u64, b: u64, c: u64) -> u64 {
    let s = supply as u128;
    let price = (a as u128) * s * s / (PRECISION * PRECISION)
        + (b as u128) * s / PRECISION
        + (c as u128);
    price as u64
}
```
