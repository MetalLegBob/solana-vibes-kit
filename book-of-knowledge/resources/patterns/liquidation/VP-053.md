# VP-053: Liquidation Incentive Overflow

**Category:** Liquidation
**Verification tool:** Kani

## What Can Go Wrong
Liquidation bonus calculations multiply the seized collateral amount by an incentive factor (e.g., 105% expressed as 10500 bps). When the collateral amount is large and the incentive multiplier pushes the product beyond u64::MAX, the result silently wraps to a small number. The liquidator receives almost nothing, or the protocol credits an impossibly large amount that corrupts accounting state.

## Why It Matters
A liquidator expecting a 5% bonus on a large position could trigger an overflow that zeroes out the bonus entirely, making liquidation unprofitable. If liquidations become unprofitable, nobody liquidates, and the protocol accumulates bad debt until insolvency. Alternatively, an overflow in the other direction could let a liquidator extract more collateral than exists in the position.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Several Solana program audits have identified u64 overflow in liquidation bonus math as a high-severity finding.

## Invariant

### Formal Property
```
forall collateral_amount, incentive_bps:
  bonus = collateral_amount * incentive_bps / 10000
  bonus <= u64::MAX AND bonus >= collateral_amount (when incentive_bps >= 10000)
```

### Kani Precondition/Postcondition
```rust
kani::assume!(collateral_amount > 0 && collateral_amount <= u64::MAX);
kani::assume!(incentive_bps >= 10000 && incentive_bps <= 15000);
let bonus_amount: u128 = (collateral_amount as u128) * (incentive_bps as u128) / 10000u128;
kani::assert!(bonus_amount <= u64::MAX as u128);
kani::assert!(bonus_amount >= collateral_amount as u128);
```

### Proptest Property
```rust
proptest! {{
    #[test]
    fn liquidation_incentive_no_overflow(
        collateral_amount in 1u64..=u64::MAX,
        incentive_bps in 10000u16..=15000u16
    ) {{
        let result = compute_liquidation_bonus(collateral_amount, incentive_bps);
        match result {{
            Ok(bonus) => prop_assert!(bonus >= collateral_amount),
            Err(_) => {{
                let check = (collateral_amount as u128) * (incentive_bps as u128);
                prop_assert!(check / 10000 > u64::MAX as u128);
            }}
        }}
    }}
}}
```

### LiteSVM Assertion
```rust
let bonus = compute_liquidation_bonus(collateral_seized, incentive_bps);
assert!(bonus.is_ok(), "Liquidation bonus overflowed");
assert!(bonus.unwrap() >= collateral_seized, "Bonus less than collateral");
```

## Suggested Fix
```rust
pub fn compute_liquidation_bonus(
    collateral_amount: u64,
    incentive_bps: u16,
) -> Result<u64, ProgramError> {{
    let product = (collateral_amount as u128)
        .checked_mul(incentive_bps as u128)
        .ok_or(ProgramError::ArithmeticOverflow)?;
    let result = product / 10_000u128;
    if result > u64::MAX as u128 {{
        return Err(ProgramError::ArithmeticOverflow);
    }}
    Ok(result as u64)
}}
```
