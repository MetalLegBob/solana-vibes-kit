# VP-029: Accumulator Overflow in Yield Tracking

**Category:** Interest/Yield
**Verification tool:** Kani

## What Can Go Wrong
Yield accumulators track cumulative interest over the protocol's lifetime. A u64 accumulator with high precision can overflow within months. Even u128 can overflow if the precision multiplier is too large or the rate too high. Once overflowed, all yield calculations break.

## Why It Matters
Accumulator overflow affects every user simultaneously. All pending interest calculations produce garbage values. The protocol becomes unusable until the bug is fixed, and retroactive correction of balances is extremely difficult.

## Real-World Incident
No specific public incident documented. However, this is a well-known concern in DeFi systems. The Compound protocol's interest rate model was designed with explicit overflow analysis for its accumulator.

## Invariant

### Formal Property
```
cumulative_rate * PRECISION must fit in u128 for the protocol's expected lifetime (10+ years)
max_accumulator = max_rate * max_time * PRECISION
max_accumulator < u128::MAX
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_yield_accumulator_fits_u128() {
    let annual_rate_bps: u16 = kani::any();
    let years: u8 = kani::any();

    kani::assume!(annual_rate_bps <= 10_000); // max 100% APR
    kani::assume!(years >= 1 && years <= 20);

    let slots = SLOTS_PER_YEAR as u128 * (years as u128);
    let rate_per_slot = (annual_rate_bps as u128) * PRECISION / SLOTS_PER_YEAR as u128 / 10_000;
    let max_accumulator = rate_per_slot.checked_mul(slots);

    kani::assert!(max_accumulator.is_some(), "accumulator overflows in {} years", years);
    kani::assert!(max_accumulator.unwrap() < u128::MAX / 2);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn accumulator_safe_for_10_years(rate_bps in 1u16..10_000) {
        let rate_per_slot = (rate_bps as u128) * PRECISION / SLOTS_PER_YEAR as u128 / 10_000;
        let slots_10_years = SLOTS_PER_YEAR as u128 * 10;
        let result = rate_per_slot.checked_mul(slots_10_years);
        prop_assert!(result.is_some(), "overflow at {} bps", rate_bps);
    }
}
```

### LiteSVM Assertion
```rust
// Set max rate, advance max time
set_rate(&mut ctx, 10_000).await.unwrap(); // 100% APR
for year in 0..10 {
    advance_slots(&mut ctx, SLOTS_PER_YEAR).await;
    let result = accrue(&mut ctx).await;
    assert!(result.is_ok(), "accumulator overflow at year {}", year);
}
```

## Suggested Fix
```rust
// Choose PRECISION to allow 20 years at 200% APR without overflow
// u128::MAX ≈ 3.4 × 10^38
// 200% APR × 20 years × SLOTS_PER_YEAR × PRECISION < u128::MAX
// With SLOTS_PER_YEAR ≈ 150M and PRECISION = 10^12:
// 2 × 20 × 150M × 10^12 = 6 × 10^21 << 3.4 × 10^38 ✓
const PRECISION: u128 = 1_000_000_000_000;
```
