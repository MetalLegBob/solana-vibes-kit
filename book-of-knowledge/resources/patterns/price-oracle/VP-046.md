# VP-046: Price Impact Calculation Accuracy

**Category:** Price Oracle
**Verification tool:** Proptest

## What Can Go Wrong
Price impact estimates how much a trade will move the price. If the estimate is inaccurate, routing algorithms select suboptimal paths, and users get worse execution than expected. Under-estimated impact leads to excessive slippage; over-estimated impact causes unnecessary trade splitting.

## Why It Matters
DEX aggregators rely on accurate price impact to route trades optimally. If a pool reports lower impact than actual, the router sends too much volume to it, causing worse execution than a more accurate estimate would produce.

## Real-World Incident
Jupiter aggregator on Solana continuously refines its price impact estimation models. Early versions sometimes routed through pools with inaccurate impact estimates, causing worse execution.

## Invariant

### Formal Property
```
For swap of size Δx in pool (x, y):
  estimated_impact = Δx / (x + Δx)  (for constant product)
  |actual_impact - estimated_impact| / estimated_impact <= tolerance
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_price_impact_formula() {
    let reserve: u64 = kani::any();
    let trade_size: u64 = kani::any();

    kani::assume!(reserve > 1_000_000 && reserve < u64::MAX / 2);
    kani::assume!(trade_size > 0 && trade_size < reserve);

    // Constant product price impact
    let impact_bps = (trade_size as u128) * 10_000 / ((reserve as u128) + (trade_size as u128));

    kani::assert!(impact_bps < 10_000, "impact > 100%");
    kani::assert!(impact_bps > 0 || trade_size == 0, "zero impact on nonzero trade");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn estimated_vs_actual_impact(
        reserve_x in 1_000_000u64..1_000_000_000,
        reserve_y in 1_000_000u64..1_000_000_000,
        trade in 1u64..10_000_000
    ) {
        let spot_price = reserve_y as f64 / reserve_x as f64;
        let output = (reserve_y as u128) * (trade as u128) / ((reserve_x as u128) + (trade as u128));
        let exec_price = output as f64 / trade as f64;
        let actual_impact = 1.0 - exec_price / spot_price;
        let estimated_impact = trade as f64 / (reserve_x as f64 + trade as f64);
        prop_assert!((actual_impact - estimated_impact).abs() < 0.01,
            "impact estimate off by {} at trade size {}", (actual_impact - estimated_impact).abs(), trade);
    }
}
```

### LiteSVM Assertion
```rust
let pool = get_pool_state(&ctx).await;
let spot_before = pool.reserve_b as f64 / pool.reserve_a as f64;
execute_swap(&mut ctx, trade_amount).await.unwrap();
let pool = get_pool_state(&ctx).await;
let spot_after = pool.reserve_b as f64 / pool.reserve_a as f64;
let actual_impact = (spot_before - spot_after) / spot_before;
let estimated = trade_amount as f64 / (pool.reserve_a as f64 + trade_amount as f64);
assert!((actual_impact - estimated).abs() < 0.01, "impact estimate off");
```

## Suggested Fix
```rust
pub fn estimate_price_impact(reserve: u64, trade_size: u64) -> u16 {
    // Returns basis points of expected price impact
    let impact_bps = (trade_size as u128) * 10_000 / ((reserve as u128) + (trade_size as u128));
    impact_bps as u16
}
```
