# VP-087: Slot-to-Time Estimation Accuracy

**Category:** Timestamp/Duration
**Verification tool:** Proptest

## What Can Go Wrong
Solana slots average ~400ms but vary significantly during congestion. Converting slots to wall-clock time using a fixed multiplier introduces error. If a protocol bases timeouts or vesting on slot counts assuming 400ms each, actual durations can be 2-3x longer during network stress.

## Why It Matters
A 24-hour lockup based on 216,000 slots (24h * 3600s/h / 0.4s/slot) could actually be 48 hours if slots slow to 800ms during congestion. Users are locked longer than expected, or time-sensitive operations trigger late.

## Real-World Incident
During Solana congestion events in 2022, slot times increased significantly, causing time-dependent protocols to behave unexpectedly. Validators throttling and restart events caused slot duration variability.

## Invariant

### Formal Property
```
slot_duration_estimate * slots_elapsed approximates actual wall time
Tolerance: actual_time âˆˆ [estimated_time * 0.5, estimated_time * 3.0]
For critical operations: use unix_timestamp, not slot count
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_slot_time_bounded() {
    let slots: u64 = kani::any();
    let avg_ms: u64 = kani::any();

    kani::assume!(slots > 0 && slots < 1_000_000_000);
    kani::assume!(avg_ms >= 200 && avg_ms <= 1000); // 200ms-1000ms range

    let estimated_seconds = (slots as u128) * (avg_ms as u128) / 1000;
    kani::assert!(estimated_seconds > 0);
    kani::assert!(estimated_seconds < u64::MAX as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn slot_time_reasonable(
        slots in 1u64..10_000_000,
        actual_ms_per_slot in 300u64..800
    ) {
        let estimated_400ms = slots as f64 * 0.4;
        let actual = slots as f64 * (actual_ms_per_slot as f64 / 1000.0);
        let ratio = actual / estimated_400ms;
        prop_assert!(ratio >= 0.5 && ratio <= 3.0,
            "slot time ratio {} outside bounds", ratio);
    }
}
```

### LiteSVM Assertion
```rust
// Use Clock::unix_timestamp for time-critical operations, not slot count
let clock = Clock::get()?;
let time_based_deadline = clock.unix_timestamp + 86400; // 24h in seconds
assert!(time_based_deadline > clock.unix_timestamp);
```

## Suggested Fix
```rust
// PREFER unix_timestamp over slot count for durations
pub fn is_expired(start_timestamp: i64, duration_seconds: i64) -> bool {
    let clock = Clock::get().unwrap();
    clock.unix_timestamp >= start_timestamp + duration_seconds
}

// If slots are needed, use a generous tolerance
pub fn slots_to_seconds_estimate(slots: u64) -> u64 {
    // Conservative: assume 500ms per slot (slower than average)
    slots * 500 / 1000
}
```
