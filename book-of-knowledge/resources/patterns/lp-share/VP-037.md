# VP-037: Dust Accumulation in LP Accounting

**Category:** LP Share
**Verification tool:** Proptest

## What Can Go Wrong
Each deposit/withdrawal involves integer division, leaving a remainder (dust). Over thousands of operations, this dust accumulates in the pool — tokens that belong to no one. If dust grows unbounded, it represents locked value. If dust is exploitable (e.g., via share manipulation), it can be extracted.

## Why It Matters
Dust accumulation means the pool slowly becomes insolvent relative to shares. Each share represents slightly less value than expected because value is trapped as dust. Over years, this can become material.

## Real-World Incident
Dust accumulation is a known issue in all integer-arithmetic DeFi protocols. Curve Finance's implementation explicitly tracks and handles dust to prevent exploits.

## Invariant

### Formal Property
```
|pool_total_value - Σ(share_value(user_i))| <= num_operations (bounded dust)
dust_per_operation <= 1 token unit
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_dust_bounded() {
    let total_value: u64 = kani::any();
    let total_shares: u64 = kani::any();
    let share_amount: u64 = kani::any();

    kani::assume!(total_value > 1_000_000);
    kani::assume!(total_shares > 1_000);
    kani::assume!(share_amount > 0 && share_amount <= total_shares);

    let withdraw_value = (share_amount as u128) * (total_value as u128) / (total_shares as u128);
    let remaining_value = total_value as u128 - withdraw_value;
    let remaining_shares = total_shares as u128 - share_amount as u128;

    // Dust from this operation
    if remaining_shares > 0 {
        let recalc = remaining_shares * (remaining_value / remaining_shares);
        let dust = remaining_value - recalc;
        kani::assert!(dust < remaining_shares, "excessive dust");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn dust_stays_bounded_over_many_ops(
        initial_value in 1_000_000u64..1_000_000_000,
        ops in prop::collection::vec((1_000u64..100_000, prop::bool::ANY), 10..100)
    ) {
        let mut value = initial_value as u128;
        let mut shares = initial_value as u128;
        for (amount, is_deposit) in ops {
            if is_deposit {
                let new_shares = (amount as u128) * shares / value;
                shares += new_shares;
                value += amount as u128;
            } else if amount as u128 <= shares / 2 {
                let withdraw = (amount as u128) * value / shares;
                value -= withdraw;
                shares -= amount as u128;
            }
        }
        // After many ops, value should still be close to shares * price
        let price = value as f64 / shares as f64;
        prop_assert!(price > 0.99 && price < 1.01, "price drift: {}", price);
    }
}
```

### LiteSVM Assertion
```rust
for _ in 0..100 {
    deposit(&mut ctx, &user, 10_000).await.unwrap();
    withdraw(&mut ctx, &user, get_user_shares(&ctx, &user).await / 2).await.unwrap();
}
let pool = get_pool_state(&ctx).await;
let accounted = total_share_value(&ctx).await;
let dust = pool.total_value - accounted;
assert!(dust < 200, "dust {} too large after 100 ops", dust); // max 2 per op
```

## Suggested Fix
```rust
// Track dust explicitly and sweep periodically
pub fn sweep_dust(pool: &mut Pool) -> u64 {
    let accounted: u128 = pool.total_shares as u128 * pool.price_per_share() as u128 / PRECISION;
    let dust = pool.total_value().saturating_sub(accounted as u64);
    pool.accumulated_dust += dust;
    dust
}
```
