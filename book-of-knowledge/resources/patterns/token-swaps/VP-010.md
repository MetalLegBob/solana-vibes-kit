# VP-010: Stable Swap Curve Deviation Bound

**Category:** Token Swaps
**Verification tool:** Proptest

## What Can Go Wrong
Stable swap curves (e.g., Curve's StableSwap) are designed for assets that should trade near 1:1 (stablecoins, wrapped assets). The curve uses an amplification parameter to flatten the pricing around the peg. If the implementation diverges from the mathematical curve, swaps may give incorrect outputs — too generous near peg or too punitive at deviation.

## Why It Matters
Stablecoins temporarily depegging is normal (e.g., USDC at $0.98). The curve must handle these deviations gracefully. If the math diverges from intended behavior at the boundaries, large swaps during depeg events create arbitrage opportunities or trap liquidity.

## Real-World Incident
Curve Finance's StableSwap invariant has been extensively battle-tested, but many forks implement the Newton's method iteration incorrectly. Cashio (Solana, Mar 2022) — infinite mint exploit on a stable swap, $52M lost.

## Invariant

### Formal Property
```
For stable swap with amplification A, reserves [x, y], swap input Δx:
  output Δy satisfies: A*n^n*(x+y) + D = A*D*n^n + D^(n+1)/(n^n * x * y)
  |actual_output - theoretical_output| <= 1 (rounding tolerance)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_stable_swap_near_peg() {
    let reserve: u64 = kani::any();
    let input: u64 = kani::any();
    let amp: u64 = kani::any();

    kani::assume!(reserve > 1_000_000 && reserve < 1_000_000_000);
    kani::assume!(input > 0 && input < reserve / 10);
    kani::assume!(amp >= 1 && amp <= 1000);

    // Near peg (balanced reserves), output ≈ input for stables
    let output = stable_swap_output(reserve, reserve, input, amp);

    // Within 1% of 1:1 for balanced pool with reasonable amp
    kani::assert!(output >= input * 99 / 100);
    kani::assert!(output <= input);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn stable_swap_output_bounded(
        reserve in 1_000_000u64..1_000_000_000,
        input in 1u64..10_000_000,
        amp in 10u64..500
    ) {
        let output = stable_swap_output(reserve, reserve, input, amp);
        // Near peg: output should be close to input (within amp-dependent tolerance)
        let min_expected = input as u128 * 98 / 100; // 2% tolerance
        prop_assert!(output as u128 >= min_expected,
            "output {} too low for input {} at amp {}", output, input, amp);
        // Output must never exceed input (no free money)
        prop_assert!(output <= input, "output {} > input {}", output, input);
    }
}
```

### LiteSVM Assertion
```rust
// Balanced USDC-USDT pool, swap should be near 1:1
let output = execute_stable_swap(&mut ctx, usdc_amount).await.unwrap();
let ratio = output as f64 / usdc_amount as f64;
assert!(ratio > 0.98 && ratio <= 1.0,
    "stable swap ratio {} outside expected range", ratio);
```

## Suggested Fix
```rust
/// Newton's method for StableSwap D calculation
fn compute_d(reserves: &[u128], amp: u128) -> Result<u128> {
    let n = reserves.len() as u128;
    let sum: u128 = reserves.iter().sum();
    let mut d = sum;
    let ann = amp * n.pow(n as u32);

    for _ in 0..256 { // max iterations
        let mut d_prod = d;
        for &r in reserves {
            d_prod = d_prod * d / (r * n);
        }
        let d_prev = d;
        d = (ann * sum + d_prod * n) * d / ((ann - 1) * d + (n + 1) * d_prod);
        if d.abs_diff(d_prev) <= 1 {
            return Ok(d);
        }
    }
    Err(StableSwapError::ConvergenceFailed)
}
```
