# VP-045: Oracle Fallback Chain Consistency

**Category:** Price Oracle
**Verification tool:** LiteSVM

## What Can Go Wrong
Protocols often use multiple oracle sources with fallback chains (e.g., Pyth → Switchboard → TWAP). If the fallback prices diverge significantly from the primary, switching oracles can cause sudden price jumps. If no validation exists between fallback sources, a compromised secondary oracle can be exploited.

## Why It Matters
A fallback oracle returning a price 50% different from the primary creates instant arbitrage opportunities. Attackers can trigger fallback conditions (e.g., making Pyth stale) then exploit the price difference.

## Real-World Incident
Multiple DeFi protocols on Ethereum experienced issues when Chainlink feeds went stale during high-gas periods, and fallback oracles returned different prices. Solana's Pyth outages in 2022 triggered fallback behaviors in several protocols.

## Invariant

### Formal Property
```
For fallback chain [oracle_1, oracle_2, ...]:
  |oracle_fallback.price - oracle_primary.price| / oracle_primary.price <= max_deviation
  If deviation exceeds threshold, pause operations rather than use divergent price
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fallback_deviation_check() {
    let primary_price: u64 = kani::any();
    let fallback_price: u64 = kani::any();
    let max_deviation_bps: u16 = kani::any();

    kani::assume!(primary_price > 0 && fallback_price > 0);
    kani::assume!(max_deviation_bps > 0 && max_deviation_bps <= 5000);

    let deviation = if fallback_price > primary_price {
        (fallback_price - primary_price) as u128 * 10_000 / primary_price as u128
    } else {
        (primary_price - fallback_price) as u128 * 10_000 / primary_price as u128
    };

    if deviation > max_deviation_bps as u128 {
        // Must reject the fallback price
        kani::assert!(true); // protocol should pause
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fallback_within_deviation_bounds(
        primary in 1_000_000u64..1_000_000_000,
        deviation_pct in 0u64..50
    ) {
        let fallback = primary + primary * deviation_pct / 100;
        let result = validate_fallback(primary, fallback, 500); // 5% max deviation
        if deviation_pct > 5 {
            prop_assert!(result.is_err(), "accepted divergent fallback at {}%", deviation_pct);
        } else {
            prop_assert!(result.is_ok(), "rejected valid fallback at {}%", deviation_pct);
        }
    }
}
```

### LiteSVM Assertion
```rust
// Make primary oracle stale
advance_clock(&mut ctx, STALENESS_THRESHOLD + 1).await;
// Set fallback to 20% different price
set_fallback_price(&mut ctx, primary_price * 120 / 100).await.unwrap();
let result = borrow_with_oracle(&mut ctx, &user, amount).await;
assert!(result.is_err(), "accepted 20% divergent fallback oracle");
```

## Suggested Fix
```rust
pub fn get_price_with_fallback(oracles: &[&OracleAccount], max_deviation_bps: u16) -> Result<u64> {
    let mut last_valid_price = None;
    for oracle in oracles {
        if let Ok(price) = validate_freshness(oracle) {
            if let Some(prev) = last_valid_price {
                let dev = price_deviation(prev, price);
                require!(dev <= max_deviation_bps, OracleError::FallbackDeviation);
            }
            return Ok(price);
        }
        // Try next fallback
    }
    Err(OracleError::AllOraclesStale)
}
```
