# VP-050: Reserve Ratio Maintenance

**Category:** Bonding Curves
**Verification tool:** Proptest

## What Can Go Wrong
A bonding curve's reserve must track the integral of the price curve. If tokens are bought/sold without correctly updating the reserve, the reserve diverges from the theoretical value. Eventually the reserve can't cover sell-side redemptions, making the curve insolvent.

## Why It Matters
The reserve is the bonding curve's backing. If reserve < integral(price, 0, current_supply), the curve can't honor all sells. Last sellers find the reserve empty.

## Real-World Incident
No specific public incident documented, but reserve tracking bugs are common in bonding curve audits. The Bancor protocol on Ethereum had to modify its reserve management after discovering drift between theoretical and actual reserves.

## Invariant

### Formal Property
```
After any buy/sell:
  actual_reserve = Σ(buy_payments) - Σ(sell_refunds) - Σ(fees)
  actual_reserve ≈ theoretical_integral(0, current_supply) (within rounding tolerance)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_reserve_tracks_integral() {
    let supply_before: u64 = kani::any();
    let buy_amount: u64 = kani::any();
    let reserve_before: u64 = kani::any();

    kani::assume!(supply_before > 0 && supply_before < u64::MAX / 4);
    kani::assume!(buy_amount > 0 && buy_amount < 1_000_000);

    let cost = curve_integral(supply_before, supply_before + buy_amount);
    let reserve_after = (reserve_before as u128) + cost;

    // Reserve must increase by exactly the cost
    kani::assert!(reserve_after > reserve_before as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn reserve_matches_integral_after_operations(
        ops in prop::collection::vec((1_000u64..100_000, prop::bool::ANY), 10..50)
    ) {
        let mut supply = 0u64;
        let mut reserve = 0u128;
        for (amount, is_buy) in ops {
            if is_buy {
                let cost = curve_integral(supply, supply + amount);
                reserve += cost;
                supply += amount;
            } else if amount <= supply {
                let refund = curve_integral(supply - amount, supply);
                reserve -= refund;
                supply -= amount;
            }
        }
        let expected_reserve = curve_integral(0, supply);
        let diff = if reserve > expected_reserve { reserve - expected_reserve } else { expected_reserve - reserve };
        prop_assert!(diff <= ops.len() as u128, "reserve drift {} > {}", diff, ops.len());
    }
}
```

### LiteSVM Assertion
```rust
let reserve_account = get_sol_balance(&ctx, reserve_pda).await;
let supply = get_token_supply(&ctx).await;
let expected_reserve = compute_theoretical_reserve(supply);
let tolerance = supply / 1000; // 0.1% tolerance
assert!((reserve_account as i128 - expected_reserve as i128).unsigned_abs() <= tolerance as u128,
    "reserve drift: actual {} vs expected {}", reserve_account, expected_reserve);
```

## Suggested Fix
```rust
pub fn buy(curve: &mut BondingCurve, amount: u64) -> Result<u64> {
    let cost = curve_integral(curve.supply, curve.supply + amount);
    // Update reserve and supply atomically
    curve.reserve = curve.reserve.checked_add(cost as u64)?;
    curve.supply = curve.supply.checked_add(amount)?;
    Ok(cost as u64)
}
```
