# VP-091: Funding Rate Calculation Precision

**Category:** Leverage/Perpetuals
**Verification tool:** Kani

## What Can Go Wrong
Perpetual futures funding rate = (mark_price - index_price) / index_price, scaled per period. Integer division of small differences between large prices produces 0 or loses precision. If funding rate truncates to 0, the perpetual drifts from the index with no correction mechanism.

## Why It Matters
Zero funding rate means longs and shorts are never incentivized to rebalance. The perpetual price diverges from spot indefinitely. Traders on the wrong side accumulate unrealized losses without the funding mechanism pushing prices back.

## Real-World Incident
Mango Markets (Solana) had funding rate precision concerns. Drift Protocol on Solana implemented high-precision funding rate calculations specifically to avoid truncation issues.

## Invariant

### Formal Property
```
funding_rate = (mark - index) * PRECISION / index / FUNDING_PERIOD
funding_rate != 0 when mark != index (no truncation to zero)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_funding_rate_precision() {
    let mark: u64 = kani::any();
    let index: u64 = kani::any();

    kani::assume!(mark > 0 && index > 0);
    kani::assume!(mark != index);
    kani::assume!(mark < u64::MAX / 2 && index < u64::MAX / 2);

    let diff = if mark > index {
        (mark - index) as u128
    } else {
        (index - mark) as u128
    };

    let rate = diff * PRECISION / (index as u128);
    kani::assert!(rate > 0, "funding rate truncated to zero");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn funding_rate_nonzero_when_divergent(
        mark in 1_000_000u64..1_000_000_000,
        index in 1_000_000u64..1_000_000_000
    ) {
        prop_assume!(mark != index);
        let rate = compute_funding_rate(mark, index);
        prop_assert!(rate != 0, "zero rate for mark={} index={}", mark, index);
    }
}
```

### LiteSVM Assertion
```rust
set_mark_price(&mut ctx, 100_500_000).await; // $100.50
set_index_price(&mut ctx, 100_000_000).await; // $100.00
let rate = get_funding_rate(&ctx).await;
assert!(rate > 0, "funding rate should be positive when mark > index");
```

## Suggested Fix
```rust
const FUNDING_PRECISION: u128 = 1_000_000_000; // 10^9

pub fn compute_funding_rate(mark: u64, index: u64) -> i128 {
    let diff = mark as i128 - index as i128;
    diff * FUNDING_PRECISION as i128 / index as i128
}
```
