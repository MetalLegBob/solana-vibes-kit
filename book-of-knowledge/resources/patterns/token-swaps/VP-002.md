# VP-002: Slippage Bound Violation

**Category:** Token Swaps
**Verification tool:** All

## What Can Go Wrong
If a swap function does not enforce the user-specified minimum output amount, the user can receive far fewer tokens than expected. Front-runners can insert transactions that move the price, causing the victim's swap to execute at a worse rate.

## Why It Matters
Sandwich attacks are the most common MEV extraction on DEXs. Without slippage protection, every swap is vulnerable. Attackers front-run with a large buy, let the victim's swap execute at inflated price, then back-run to sell.

## Real-World Incident
Sandwich attacks extract millions daily across Ethereum and Solana DEXs. The Jito validator client on Solana was specifically designed to enable MEV extraction including sandwich attacks on unprotected swaps.

## Invariant

### Formal Property
```
For any swap with user-specified min_output:
  actual_output >= min_output OR transaction reverts
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_slippage_enforcement() {
    let reserve_x: u64 = kani::any();
    let reserve_y: u64 = kani::any();
    let input: u64 = kani::any();
    let min_output: u64 = kani::any();

    kani::assume!(reserve_x > 1_000_000 && reserve_x < u64::MAX / 2);
    kani::assume!(reserve_y > 1_000_000 && reserve_y < u64::MAX / 2);
    kani::assume!(input > 0 && input < reserve_x / 10);
    kani::assume!(min_output > 0);

    let output = (reserve_y as u128) * (input as u128) / ((reserve_x as u128) + (input as u128));

    // If output >= min_output, swap succeeds; otherwise must revert
    if output < min_output as u128 {
        // This path must revert in real code
        kani::assert!(true); // revert expected
    } else {
        kani::assert!(output >= min_output as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn slippage_enforced(
        reserve_x in 1_000_000u64..1_000_000_000,
        reserve_y in 1_000_000u64..1_000_000_000,
        input in 1u64..10_000_000,
        min_output in 1u64..10_000_000
    ) {
        let output = (reserve_y as u128) * (input as u128)
            / ((reserve_x as u128) + (input as u128));
        let result = swap_with_slippage(reserve_x, reserve_y, input, min_output);
        match result {
            Ok(amount) => prop_assert!(amount >= min_output),
            Err(_) => prop_assert!(output < min_output as u128),
        }
    }
}
```

### LiteSVM Assertion
```rust
// Set min_output higher than possible output
let result = process_transaction(&mut banks_client, bad_swap_ix, &payer).await;
assert!(result.is_err(), "swap should revert when output < min_output");
```

## Suggested Fix
```rust
let output = calculate_output(pool, input_amount)?;
require!(output >= min_output, SwapError::SlippageExceeded);
```
