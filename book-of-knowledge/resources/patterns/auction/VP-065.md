# VP-065: Reserve Price Enforcement

**Category:** Auction
**Verification tool:** Kani

## What Can Go Wrong
An auction must never settle below its reserve price. If the highest bid is below the reserve, the auction should be cancelled and the item returned to the seller. Missing or incorrect reserve price checks allow items to sell for less than the minimum acceptable price. A subtle variant occurs when the check uses strict greater-than instead of greater-than-or-equal, rejecting bids that exactly match the reserve.

## Why It Matters
An attacker is the sole bidder, placing a bid far below market value. Without reserve enforcement, the item sells at a fraction of its worth. The seller suffers a direct financial loss that cannot be reversed on-chain. This is critical because the finalize instruction must check the reserve before transferring ownership of the auctioned asset.

## Real-World Incident
The OpenSea Wyvern protocol had an edge case where auctions with a reserve of zero could settle for zero, giving away NFTs. Multiple Solana audit reports have flagged missing reserve checks in finalize instructions, including Metaplex auction programs.

## Invariant

### Formal Property
```
forall auction_finalization:
  highest_bid >= reserve_price => sale_price == highest_bid
  highest_bid < reserve_price  => status == CANCELLED
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_reserve_enforcement() {
    let reserve: u64 = kani::any();
    let highest_bid: u64 = kani::any();

    kani::assume!(reserve > 0 && reserve < 1_000_000_000);
    kani::assume!(highest_bid < 2_000_000_000);

    let settled = highest_bid >= reserve;
    let cancelled = !settled;

    kani::assert!(settled || cancelled);
    kani::assert!(!(settled && cancelled));
    kani::assert!(!settled || highest_bid >= reserve);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn reserve_always_enforced(
        reserve in 1u64..1_000_000_000,
        highest_bid in 0u64..2_000_000_000,
    ) {
        let (settled, sale_price) = if highest_bid >= reserve {
            (true, highest_bid)
        } else {
            (false, 0u64)
        };
        if settled {
            prop_assert!(sale_price >= reserve, "settled below reserve");
        } else {
            prop_assert!(highest_bid < reserve);
        }
    }
}
```

### LiteSVM Assertion
```rust
let auction = create_auction(&mut ctx, seller, reserve_price, min_increment).await;
place_bid(&mut ctx, auction, bidder, reserve_price - 1).await.unwrap();

ctx.warp_to_slot(end_slot);
finalize_auction(&mut ctx, auction).await.unwrap();
let state = get_auction_state(&ctx, auction).await;
assert_eq!(state.status, AuctionStatus::Cancelled);
let balance = get_balance(&ctx, bidder).await;
assert_eq!(balance, initial_balance, "bidder must be refunded on cancel");
```

## Suggested Fix
```rust
pub fn finalize_auction(ctx: Context<FinalizeAuction>) -> Result<()> {
    let auction = &mut ctx.accounts.auction;
    require!(auction.end_time <= Clock::get()?.unix_timestamp, AuctionError::NotEnded);
    require!(!auction.finalized, AuctionError::AlreadyFinalized);

    if auction.highest_bid >= auction.reserve_price {
        transfer_item(auction, &ctx.accounts.winner)?;
        transfer_lamports(auction, &ctx.accounts.seller, auction.highest_bid)?;
        auction.status = AuctionStatus::Settled;
    } else {
        return_item(auction, &ctx.accounts.seller)?;
        refund_all_bidders(auction)?;
        auction.status = AuctionStatus::Cancelled;
    }
    auction.finalized = true;
    Ok(())
}
```
