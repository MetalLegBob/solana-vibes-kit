# VP-003: K-Invariant Maintenance After Swap

**Category:** Token Swaps
**Verification tool:** Kani

## What Can Go Wrong
In a constant-product AMM, the product k = x * y must never decrease after a swap (fees should increase it). If k decreases, value is leaking from the pool. Rounding errors in output calculation can cause k to shrink by small amounts that compound over millions of swaps.

## Why It Matters
Even a 1-unit decrease in k per swap means the pool slowly hemorrhages value. With high-frequency trading, thousands of swaps per day can drain significant reserves. The protocol accumulates a hidden deficit that eventually makes the pool insolvent.

## Real-World Incident
Crema Finance (July 2022, Solana) — attacker manipulated tick data to exploit the concentrated liquidity math, resulting in k-invariant violations that allowed draining $8.8M.

## Invariant

### Formal Property
```
For pool (x, y) with fee f and input Δx:
  k_after = (x + Δx) * (y - Δy) >= x * y = k_before
  where Δy = y * Δx_net / (x + Δx_net), Δx_net = Δx * (1 - f)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_k_never_decreases() {
    let x: u64 = kani::any();
    let y: u64 = kani::any();
    let dx: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(x > 0 && x < u64::MAX / 2);
    kani::assume!(y > 0 && y < u64::MAX / 2);
    kani::assume!(dx > 0 && dx < x);
    kani::assume!(fee_bps > 0 && fee_bps <= 10000);

    let k_before = (x as u128) * (y as u128);
    let dx_net = (dx as u128) * (10000 - fee_bps as u128) / 10000;
    let dy = (y as u128) * dx_net / ((x as u128) + dx_net);

    let x_new = (x as u128) + (dx as u128);
    let y_new = (y as u128) - dy;
    let k_after = x_new * y_new;

    // k must never decrease
    kani::assert!(k_after >= k_before);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn k_invariant_maintained(
        x in 1_000u64..1_000_000_000,
        y in 1_000u64..1_000_000_000,
        dx in 1u64..100_000_000,
        fee_bps in 1u16..300
    ) {
        let k_before = (x as u128) * (y as u128);
        let dx_net = (dx as u128) * (10000 - fee_bps as u128) / 10000;
        let dy = (y as u128) * dx_net / ((x as u128) + dx_net);
        let k_after = ((x as u128) + (dx as u128)) * ((y as u128) - dy);
        prop_assert!(k_after >= k_before, "k decreased from {} to {}", k_before, k_after);
    }
}
```

### LiteSVM Assertion
```rust
let k_before = pool.reserve_a as u128 * pool.reserve_b as u128;
execute_swap(&mut ctx, input_amount).await.unwrap();
let pool = get_pool(&ctx).await;
let k_after = pool.reserve_a as u128 * pool.reserve_b as u128;
assert!(k_after >= k_before, "k-invariant violated: {} < {}", k_after, k_before);
```

## Suggested Fix
```rust
// Compute output using floor division (favors pool, preserves k)
let new_reserve_y = k_before / new_reserve_x; // floor
let output = pool.reserve_y as u128 - new_reserve_y;
// Explicit post-check
let k_after = new_reserve_x * new_reserve_y;
require!(k_after >= k_before, "k-invariant violation");
```
