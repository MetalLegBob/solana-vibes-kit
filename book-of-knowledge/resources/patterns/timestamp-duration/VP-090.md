# VP-090: Time Window Boundary Precision

**Category:** Timestamp/Duration
**Verification tool:** Kani

## What Can Go Wrong
Time windows (e.g., voting periods, auction phases) use start and end timestamps. If both use `<=` (inclusive), adjacent windows overlap at the boundary â€” a transaction at the boundary timestamp belongs to both windows. If both use `<` (exclusive), there's a gap where no window applies.

## Why It Matters
Overlapping windows mean an action counts in two periods (double-voting, double rewards). Gaps mean an action at the boundary is rejected by all windows (denial of service at boundary moments).

## Real-World Incident
No specific public incident documented, but time window boundary bugs are a common audit finding in governance and auction protocols. SPL Governance has explicit inclusive/exclusive boundary handling.

## Invariant

### Formal Property
```
Convention: start <= t < end (half-open interval)
Adjacent windows: window_A.end == window_B.start
No overlap: window_A.end <= window_B.start
No gap: window_A.end >= window_B.start (for adjacent)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_non_overlapping_windows() {
    let w1_start: u64 = kani::any();
    let w1_end: u64 = kani::any();
    let w2_start: u64 = kani::any();
    let w2_end: u64 = kani::any();

    kani::assume!(w1_start < w1_end && w2_start < w2_end);
    kani::assume!(w1_end == w2_start); // adjacent

    let t: u64 = kani::any();

    let in_w1 = t >= w1_start && t < w1_end; // half-open
    let in_w2 = t >= w2_start && t < w2_end; // half-open

    // No timestamp can be in both windows
    kani::assert!(!(in_w1 && in_w2), "overlapping windows at t={}", t);
    // Boundary belongs to exactly one window
    if t == w1_end {
        kani::assert!(!in_w1 && in_w2);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn adjacent_windows_no_overlap(
        start in 0u64..1_000_000,
        len1 in 1u64..100_000,
        len2 in 1u64..100_000
    ) {
        let w1 = (start, start + len1);
        let w2 = (start + len1, start + len1 + len2);
        // Check boundary point
        let boundary = start + len1;
        let in_w1 = boundary >= w1.0 && boundary < w1.1;
        let in_w2 = boundary >= w2.0 && boundary < w2.1;
        prop_assert!(!in_w1 || !in_w2, "boundary in both windows");
        prop_assert!(in_w1 || in_w2, "boundary in neither window");
    }
}
```

### LiteSVM Assertion
```rust
// Vote at end of period 1 / start of period 2
let boundary = period_1_end;
let in_p1 = is_in_period(&ctx, boundary, 1).await;
let in_p2 = is_in_period(&ctx, boundary, 2).await;
assert!(in_p1 != in_p2, "boundary timestamp in both or neither period");
```

## Suggested Fix
```rust
/// Half-open interval: [start, end)
pub fn is_in_window(timestamp: i64, start: i64, end: i64) -> bool {
    timestamp >= start && timestamp < end // start inclusive, end exclusive
}
```
