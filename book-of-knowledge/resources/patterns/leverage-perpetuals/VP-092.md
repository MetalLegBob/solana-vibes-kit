# VP-092: Position PnL Overflow

**Category:** Leverage/Perpetuals
**Verification tool:** Kani

## What Can Go Wrong
Position PnL = (current_price - entry_price) * size * leverage_factor. With 100x leverage, a $100M position, and a 10% price move, the PnL is $1B. The intermediate calculation can overflow u64 and even u128 for extreme positions.

## Why It Matters
An overflowed PnL produces a garbage value â€” a massive loss could appear as a massive gain (or vice versa). The protocol pays out based on the wrong value, draining the insurance fund or vault.

## Real-World Incident
No specific public incident documented on Solana, but perpetual protocols on Ethereum have had PnL overflow issues. Drift Protocol uses u128 with explicit overflow checks.

## Invariant

### Formal Property
```
pnl = (current_price - entry_price) * position_size / PRICE_PRECISION
All intermediate calculations fit in u128
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_pnl_no_overflow() {
    let entry_price: u64 = kani::any();
    let current_price: u64 = kani::any();
    let size: u64 = kani::any();

    kani::assume!(entry_price > 0 && current_price > 0);
    kani::assume!(size > 0 && size < u64::MAX / 2);

    let diff = (current_price as i128) - (entry_price as i128);
    let pnl = diff.checked_mul(size as i128);

    kani::assert!(pnl.is_some(), "PnL overflow");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn pnl_fits_i128(
        entry in 1_000_000u64..1_000_000_000,
        current in 1_000_000u64..1_000_000_000,
        size in 1u64..1_000_000_000_000
    ) {
        let diff = current as i128 - entry as i128;
        let pnl = diff.checked_mul(size as i128);
        prop_assert!(pnl.is_some(), "PnL overflow");
    }
}
```

### LiteSVM Assertion
```rust
let pnl = compute_pnl(&ctx, &user_position).await;
// PnL should be bounded by position value
let max_pnl = position_size as i128 * 2; // max 200% loss/gain
assert!(pnl.abs() <= max_pnl, "PnL {} exceeds max {}", pnl, max_pnl);
```

## Suggested Fix
```rust
pub fn compute_pnl(entry: u64, current: u64, size: u64) -> Result<i128> {
    let diff = (current as i128) - (entry as i128);
    diff.checked_mul(size as i128).ok_or(PerpError::PnlOverflow)
}
```
