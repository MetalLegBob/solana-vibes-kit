# VP-031: Negative Interest Rate Handling

**Category:** Interest/Yield
**Verification tool:** Kani

## What Can Go Wrong
Some protocols allow negative interest rates (borrowers get paid, depositors pay). If the rate type is unsigned (u16, u64), negative rates are impossible to represent. If signed types are used but the accrual math assumes positive rates, negative accrual can underflow or produce incorrect results.

## Why It Matters
During market stress, negative rates may be needed to incentivize borrowing and reduce excess deposits. If the protocol can't handle this, it either freezes or produces incorrect balances.

## Real-World Incident
No specific public incident on Solana. However, MakerDAO on Ethereum implemented negative Dai Savings Rate during periods of excess supply. Protocols that can't handle rate sign changes face operational limitations.

## Invariant

### Formal Property
```
If negative rates supported:
  rate can be negative â†’ balance decreases over time (capped at 0)
If negative rates NOT supported:
  rate is always clamped to >= 0
  All arithmetic must be valid with rate = 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rate_clamped_to_zero() {
    let rate: i64 = kani::any();
    let effective_rate = if rate < 0 { 0i64 } else { rate };

    kani::assert!(effective_rate >= 0);

    let amount: u64 = kani::any();
    kani::assume!(amount > 0 && amount < u64::MAX / 2);

    // With clamped rate, balance never decreases
    let interest = (amount as i128) * (effective_rate as i128) / 10_000;
    kani::assert!(interest >= 0);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn negative_rate_clamped_or_handled(rate in -5000i64..5000) {
        let effective = rate.max(0) as u64;
        let interest = calculate_interest(1_000_000, effective as u16);
        prop_assert!(interest >= 0, "negative interest produced");
    }
}
```

### LiteSVM Assertion
```rust
// Try to set a rate that would result in balance decrease
let result = set_rate(&mut ctx, 0).await;
assert!(result.is_ok(), "zero rate must be valid");
let balance_before = get_balance(&ctx, &user).await;
advance_slots(&mut ctx, 1000).await;
accrue(&mut ctx).await.unwrap();
let balance_after = get_balance(&ctx, &user).await;
assert!(balance_after >= balance_before, "balance decreased at zero rate");
```

## Suggested Fix
```rust
pub fn set_interest_rate(market: &mut Market, rate_bps: i64) -> Result<()> {
    // Clamp negative rates to 0 (or handle explicitly if supported)
    market.rate_bps = rate_bps.max(0) as u16;
    Ok(())
}
```
