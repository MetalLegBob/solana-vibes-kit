# VP-100: Shift Overflow in Packing Operations

**Category:** Bit Packing
**Verification tool:** Kani

## What Can Go Wrong
Shifting a u64 by 64 or more bits is undefined behavior in many languages. In Rust, it panics in debug mode and wraps in release mode. A shift of `1u64 << 64` produces 0 instead of the expected large value. If the shift amount comes from user input or calculated field positions, a malicious value can cause incorrect packing.

## Why It Matters
A shift overflow that produces 0 means the mask is 0 — no bits are extracted or inserted. The field appears to be 0 regardless of actual content, or writing to it has no effect.

## Real-World Incident
No specific public incident documented, but shift overflow is a well-known Rust pitfall. The Rust compiler warns about it, but calculated shift amounts bypass static analysis.

## Invariant

### Formal Property
```
∀ shift operations: shift_amount < bit_width_of_type
For u64: shift < 64
For u128: shift < 128
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_shift_overflow() {
    let value: u64 = kani::any();
    let shift: u8 = kani::any();

    kani::assume!(shift < 64);

    let shifted = value << shift;
    let unshifted = shifted >> shift;

    // Right-shifting back recovers high bits (low bits may be lost)
    kani::assert!((unshifted << shift) == (shifted & (u64::MAX << shift)));
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn shift_within_bounds(value in 0u64..u64::MAX, shift in 0u8..63) {
        let shifted = value.checked_shl(shift as u32);
        prop_assert!(shifted.is_some(), "shift {} overflow", shift);
    }

    #[test]
    fn reject_excessive_shift(shift in 64u8..=255) {
        let result = 1u64.checked_shl(shift as u32);
        prop_assert!(result.is_none(), "shift {} should overflow", shift);
    }
}
```

### LiteSVM Assertion
```rust
// Verify safe packing API rejects invalid widths
let result = std::panic::catch_unwind(|| extract_field(0xFFFF, 60, 8)); // 60+8 > 64
assert!(result.is_err(), "should panic on field exceeding u64");
```

## Suggested Fix
```rust
pub fn safe_shift_left(value: u64, shift: u8) -> Result<u64> {
    if shift >= 64 { return Err(PackError::ShiftOverflow); }
    Ok(value << shift)
}

pub fn safe_shift_right(value: u64, shift: u8) -> Result<u64> {
    if shift >= 64 { return Err(PackError::ShiftOverflow); }
    Ok(value >> shift)
}
```
