# VP-019: Reward Rate Consistency Across Epochs

**Category:** Staking Rewards
**Verification tool:** Kani

## What Can Go Wrong
Staking reward calculations must produce consistent results regardless of when they're computed. If reward_rate * time_elapsed gives different results depending on how the time is chunked (one long period vs many short periods), stakers who claim frequently get different total rewards than those who claim once.

## Why It Matters
Inconsistent reward accrual means the protocol either overpays (insolvency risk) or underpays (users leave). Attackers can optimize their claim frequency to maximize rewards, extracting more than their fair share.

## Real-World Incident
Quarry (Solana staking) and multiple Solana staking protocols had reward rate precision issues in early versions. The "reward per token stored" pattern (from Synthetix) was adopted specifically to solve this.

## Invariant

### Formal Property
```
For staker with amount S, reward_rate R, time T:
  reward(S, R, T) = reward(S, R, T/2) + reward(S, R, T/2) Â± 1 (rounding)
  Total distributed <= total allocated
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_reward_consistency() {
    let stake: u64 = kani::any();
    let rate_per_second: u64 = kani::any();
    let time: u64 = kani::any();

    kani::assume!(stake > 0 && stake < 1_000_000_000);
    kani::assume!(rate_per_second > 0 && rate_per_second < 1_000_000);
    kani::assume!(time > 0 && time < 86400 * 365);

    let reward_one_shot = (stake as u128) * (rate_per_second as u128) * (time as u128) / 1_000_000_000;
    let half = time / 2;
    let reward_two_parts = (stake as u128) * (rate_per_second as u128) * (half as u128) / 1_000_000_000
        + (stake as u128) * (rate_per_second as u128) * ((time - half) as u128) / 1_000_000_000;

    // Difference must be at most 1 (rounding)
    let diff = if reward_one_shot > reward_two_parts {
        reward_one_shot - reward_two_parts
    } else {
        reward_two_parts - reward_one_shot
    };
    kani::assert!(diff <= 1);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn reward_chunking_consistent(
        stake in 1_000u64..1_000_000_000,
        rate in 1u64..1_000_000,
        total_time in 1u64..86400
    ) {
        let one_shot = compute_reward(stake, rate, total_time);
        let mut chunked = 0u128;
        let chunk_size = total_time / 10;
        for i in 0..10 {
            let t = if i < 9 { chunk_size } else { total_time - chunk_size * 9 };
            chunked += compute_reward(stake, rate, t) as u128;
        }
        let diff = (one_shot as i128 - chunked as i128).unsigned_abs();
        prop_assert!(diff <= 10, "reward diff {} too large", diff);
    }
}
```

### LiteSVM Assertion
```rust
// Claim at T=100, vs claim at T=50 + claim at T=100
let reward_single = claim_at(&mut ctx, &user, 100).await;
let reward_a = claim_at(&mut ctx2, &user2, 50).await;
let reward_b = claim_at(&mut ctx2, &user2, 100).await;
assert!((reward_single as i128 - (reward_a + reward_b) as i128).unsigned_abs() <= 1);
```

## Suggested Fix
```rust
/// Use reward-per-token-stored pattern for claim-time independence
pub fn update_reward_per_token(pool: &mut StakePool, current_time: u64) -> Result<()> {
    let elapsed = current_time.checked_sub(pool.last_update_time)?;
    if pool.total_staked > 0 {
        pool.reward_per_token_stored += (elapsed as u128)
            .checked_mul(pool.reward_rate as u128)?
            .checked_mul(PRECISION)?
            / (pool.total_staked as u128);
    }
    pool.last_update_time = current_time;
    Ok(())
}
```
