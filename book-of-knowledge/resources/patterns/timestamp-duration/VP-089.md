# VP-089: Timestamp Overflow at Large Values

**Category:** Timestamp/Duration
**Verification tool:** Kani

## What Can Go Wrong
Solana's Clock::unix_timestamp is i64 (signed). Adding a large duration to a timestamp can overflow i64 (max ~292 billion years from epoch, but signed means max ~9.2 Ã— 10^18). More practically, adding two timestamps instead of a timestamp and duration, or using u32 timestamps (Y2038 problem), causes overflow much sooner.

## Why It Matters
A timestamp overflow wraps to a negative value, which would be interpreted as a date in the past. A lockup ending at a negative timestamp appears already expired, allowing immediate withdrawal.

## Real-World Incident
The Y2038 problem (32-bit timestamp overflow) is well-documented. On Solana, i64 timestamps are safe until ~292 billion years, but arithmetic bugs can still cause overflow when adding durations.

## Invariant

### Formal Property
```
timestamp + duration does not overflow i64
Result > current_timestamp (future date)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_timestamp_no_overflow() {
    let timestamp: i64 = kani::any();
    let duration: i64 = kani::any();

    kani::assume!(timestamp > 0); // valid unix timestamp
    kani::assume!(duration > 0 && duration < 86400 * 365 * 100); // max 100 years

    let result = timestamp.checked_add(duration);
    kani::assert!(result.is_some(), "timestamp overflow");
    kani::assert!(result.unwrap() > timestamp, "deadline in the past");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn timestamp_addition_safe(
        ts in 1_600_000_000i64..2_000_000_000, // ~2020-2033
        duration in 1i64..315_360_000 // up to 10 years in seconds
    ) {
        let result = ts.checked_add(duration);
        prop_assert!(result.is_some(), "overflow at ts={} dur={}", ts, duration);
        prop_assert!(result.unwrap() > ts);
    }
}
```

### LiteSVM Assertion
```rust
let clock = Clock::get()?;
let deadline = clock.unix_timestamp.checked_add(duration_seconds)
    .expect("timestamp overflow");
assert!(deadline > clock.unix_timestamp, "deadline not in future");
```

## Suggested Fix
```rust
pub fn compute_deadline(current: i64, duration_seconds: i64) -> Result<i64> {
    require!(duration_seconds > 0, TimeError::InvalidDuration);
    current.checked_add(duration_seconds).ok_or(TimeError::Overflow)
}
```
