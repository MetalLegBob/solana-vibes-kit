# VP-009: Multi-Hop Swap Cumulative Slippage

**Category:** Token Swaps
**Verification tool:** Proptest

## What Can Go Wrong
When routing a swap through multiple pools (A→B→C), slippage compounds at each hop. Each intermediate swap has its own price impact, and the cumulative effect can far exceed what the user expects from a single-hop slippage estimate.

## Why It Matters
Users setting slippage tolerance based on single-hop expectations will get worse execution on multi-hop routes. Routers that don't account for cumulative slippage may approve routes that violate the user's actual tolerance.

## Real-World Incident
Raydium, Solana's largest AMM, was hacked in December 2022 when the attacker gained admin key access and manipulated pool parameters. While not a multi-hop bug, it demonstrates that AMM parameter manipulation across pools can cascade losses.

## Invariant

### Formal Property
```
For route [pool_1, pool_2, ..., pool_n] with input I and final output O:
  O >= min_output_specified_by_user
  cumulative_slippage = 1 - (O / ideal_output_no_impact)
  cumulative_slippage <= sum(individual_slippages) + cross_terms
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_multihop_slippage_bounded() {
    let input: u64 = kani::any();
    let min_output: u64 = kani::any();
    let hops: u8 = kani::any();

    kani::assume!(input > 1_000 && input < 1_000_000);
    kani::assume!(min_output > 0);
    kani::assume!(hops >= 2 && hops <= 4);

    // Each hop has at most 1% slippage → n hops ≈ n% worst case
    let max_slippage_bps = hops as u128 * 100; // 1% per hop
    let worst_output = (input as u128) * (10_000 - max_slippage_bps) / 10_000;

    // If min_output is achievable, it must be enforced
    if min_output as u128 <= worst_output {
        kani::assert!(worst_output >= min_output as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn multihop_respects_min_output(
        input in 1_000u64..1_000_000,
        reserves in prop::collection::vec((1_000_000u64..1_000_000_000, 1_000_000u64..1_000_000_000), 2..=4),
        min_output in 1u64..500_000
    ) {
        let mut amount = input as u128;
        for (rx, ry) in &reserves {
            amount = (*ry as u128) * amount / ((*rx as u128) + amount);
        }
        let result = execute_multihop(input, &reserves, min_output);
        match result {
            Ok(out) => prop_assert!(out >= min_output),
            Err(_) => prop_assert!(amount < min_output as u128),
        }
    }
}
```

### LiteSVM Assertion
```rust
// Route: SOL → USDC → mSOL (2 hops)
let user_balance_before = get_token_balance(&ctx, user_msol).await;
execute_route(&mut ctx, route_ix, &payer).await.unwrap();
let user_balance_after = get_token_balance(&ctx, user_msol).await;
let received = user_balance_after - user_balance_before;
assert!(received >= min_output, "multi-hop output {} < min {}", received, min_output);
```

## Suggested Fix
```rust
pub fn execute_route(route: &[PoolHop], input: u64, min_final_output: u64) -> Result<u64> {
    let mut current_amount = input;
    for hop in route {
        current_amount = hop.pool.swap(current_amount, 0)?; // no per-hop min
    }
    // Enforce min_output on FINAL output only
    require!(current_amount >= min_final_output, RouteError::SlippageExceeded);
    Ok(current_amount)
}
```
