# Historical Exploit Patterns Database

This document catalogs real-world exploits to inform attack strategy generation.
Each entry includes the attack mechanism, affected code pattern, and how to detect similar vulnerabilities.

---

## Solana-Specific Exploits

### 1. Wormhole Bridge Hack ($320M, Feb 2022)

**Attack Vector:** Missing signer verification in guardian set update

**Mechanism:**
- Attacker bypassed signature verification
- Created fake guardian signatures
- Minted unauthorized wrapped ETH

**Pattern to detect:**
```rust
// VULNERABLE: No verification that signer_account is actually a signer
pub fn process_vaa(accounts: &[AccountInfo], vaa_data: &[u8]) -> ProgramResult {
    // Missing: if !signer.is_signer { return Err(...) }
}
```

**Detection strategy:**
- Search for signature/signer verification
- Check that all authority operations require signatures
- Verify guardian/validator sets cannot be spoofed

---

### 2. Mango Markets Exploit ($114M, Oct 2022)

**Attack Vector:** Oracle price manipulation + leveraged position

**Mechanism:**
- Attacker took large long position on MNGO perps
- Simultaneously manipulated spot market price
- Oracle reported inflated price
- Borrowed against unrealized gains
- Drained protocol reserves

**Pattern to detect:**
```rust
// VULNERABLE: Direct oracle price usage without sanity checks
let price = oracle_account.price;
let collateral_value = user_position * price;  // No bounds checking
```

**Detection strategy:**
- Check oracle price sanity bounds
- Look for confidence interval validation
- Identify large position + price manipulation combos
- Check for circuit breakers on extreme moves

---

### 3. Crema Finance Hack ($8.8M, Jul 2022)

**Attack Vector:** Flash loan + fake tick account

**Mechanism:**
- Attacker created fake concentrated liquidity position
- Flash loaned large amount
- Swapped through pool with fake tick data
- Extracted fees from legitimate LPs

**Pattern to detect:**
```rust
// VULNERABLE: Account validation relies on discriminator only
let tick_account = TickAccount::try_from(&account)?;
// Missing: owner validation, PDA verification
```

**Detection strategy:**
- Verify all accounts validate owner
- Check PDA seeds include unique identifiers
- Look for account injection opportunities

---

### 4. Solend Oracle Manipulation Attempt (Jun 2022)

**Attack Vector:** Governance attack on lending protocol

**Mechanism:**
- Attacker tried to pass governance proposal
- Would have transferred large whale position to EOA
- Community intervention prevented execution

**Pattern to detect:**
- Governance with short voting periods
- Emergency powers without timelock
- Large position concentration risks

---

### 5. Cashio Dollar Infinite Mint ($52M, Mar 2022)

**Attack Vector:** Missing collateral validation in mint function

**Mechanism:**
- Attacker created fake collateral account
- Mint function didn't validate collateral authenticity
- Minted unlimited CASH stablecoin
- Dumped on DEX

**Pattern to detect:**
```rust
// VULNERABLE: Collateral validation incomplete
pub fn mint_cash(ctx: Context<MintCash>, amount: u64) -> Result<()> {
    // Missing: verify collateral_account.owner == expected_program
    // Missing: verify collateral_account.mint == expected_mint
}
```

**Detection strategy:**
- Check mint functions validate all collateral properties
- Verify collateral ownership and type
- Look for missing `has_one` constraints

---

### 6. Nirvana Finance Hack ($3.5M, Jul 2022)

**Attack Vector:** Flash loan attack on ANA token

**Mechanism:**
- Flash loaned USDC
- Swapped for ANA token at inflated price
- ANA price increased during swap
- Protocol's buyback mechanism paid out at new price
- Profit from price difference

**Pattern to detect:**
- Buyback/burn mechanisms that reference spot price
- Flash loan accessibility to protocol functions
- Price impact during single transaction

---

## DeFi Attack Patterns (Cross-Chain Applicable)

### 7. Reentrancy (Classic Pattern)

**Attack Vector:** Callback during state update

**Mechanism:**
- External call made before state update
- Callee calls back into vulnerable function
- State not yet updated, allows repeat action

**Solana context:** Less common due to runtime restrictions, but possible via:
- CPI to malicious program that CPIs back
- Cross-instruction reentrancy in same transaction

**Pattern to detect:**
```rust
// VULNERABLE: State update after external call
transfer_tokens(&ctx.accounts.token_program, amount)?;  // External call
ctx.accounts.user.balance -= amount;  // State update AFTER

// SAFE: State update before external call
ctx.accounts.user.balance -= amount;  // State update FIRST
transfer_tokens(&ctx.accounts.token_program, amount)?;  // External call
```

---

### 8. Flash Loan Attacks

**Attack Vector:** Manipulate state within single atomic transaction

**Common patterns:**
- Borrow large amount
- Manipulate oracle/price
- Exploit protocol at manipulated price
- Repay loan + keep profit

**Detection strategy:**
- Identify operations that assume multi-block time passage
- Check for single-transaction price dependencies
- Look for governance/voting manipulation

---

### 9. Sandwich Attacks

**Attack Vector:** Front-run and back-run victim transaction

**Mechanism:**
- Observe pending transaction (swap)
- Submit front-running transaction (buy)
- Victim transaction executes at worse price
- Back-running transaction (sell) profits

**Solana context:** MEV on Solana via Jito bundles

**Detection strategy:**
- Slippage protection adequacy
- Price impact calculations
- Deadline parameters

---

### 10. Governance Attacks

**Attack Vector:** Exploit governance mechanisms

**Patterns:**
- Flash loan voting tokens
- Bribe attacks
- Timing attacks on proposals
- Malicious proposal execution

**Detection strategy:**
- Voting token lockup requirements
- Proposal execution delays
- Quorum requirements
- Emergency pause capabilities

---

## Anchor-Specific Vulnerabilities

### 11. Missing `init_if_needed` Protection

**Attack Vector:** Reinitialization of accounts

```rust
// VULNERABLE: Allows reinitialization
#[account(init_if_needed, ...)]
pub user_account: Account<'info, UserData>,
```

**Detection:** Search for `init_if_needed` and verify intentional usage

---

### 12. Arbitrary CPI

**Attack Vector:** Substitute malicious program for CPI target

```rust
// VULNERABLE: No program ID validation
pub token_program: UncheckedAccount<'info>,

// Later:
invoke(&transfer_instruction, &[...], token_program.key)?;
```

**Detection:** All CPI targets should use `Program<'info, T>` or explicit validation

---

### 13. PDA Seed Collision

**Attack Vector:** Different logical entities share same PDA

```rust
// VULNERABLE: Seeds too generic
seeds = [b"pool", token_mint.key().as_ref()]
// Different users get same pool PDA
```

**Detection:** Verify PDA seeds include all relevant discriminating values

---

### 14. Signer Validation Bypass

**Attack Vector:** Function doesn't require signer for sensitive operation

```rust
// VULNERABLE: No signer check
pub authority: AccountInfo<'info>,  // Should be Signer<'info>
```

**Detection:** All authority accounts should be `Signer<'info>`

---

### 15. Duplicate Account Exploit

**Attack Vector:** Same account passed as multiple parameters

```rust
// VULNERABLE: No duplicate check
pub fn transfer(ctx: Context<Transfer>) -> Result<()> {
    // What if from_account == to_account?
}
```

**Detection:** Add key equality checks for related mutable accounts

---

## Rust-Specific Vulnerabilities (Trail of Bits Patterns)

### 16. Integer Overflow in Release Builds

**Attack Vector:** Exploit debug/release behavior difference

**Mechanism:**
- Code uses unchecked arithmetic (`+`, `-`, `*`)
- Debug builds panic on overflow
- Release builds silently wrap
- Attacker triggers overflow only in production

**Pattern to detect:**
```rust
// VULNERABLE: Unchecked arithmetic
let total = amount_a + amount_b;  // Panics debug, wraps release

// SAFE: Explicit checked math
let total = amount_a.checked_add(amount_b)
    .ok_or(ErrorCode::Overflow)?;
```

**Detection strategy:**
- Search for `+`, `-`, `*` on numeric types without `.checked_*`
- Verify release builds don't have `overflow-checks = true`

---

### 17. Panic-Based Denial of Service

**Attack Vector:** Trigger panic to halt program execution

**Common panic sources:**
```rust
// VULNERABLE: Panics on None
let value = option.unwrap();

// VULNERABLE: Panics on Err
let result = fallible_fn().expect("failed");

// VULNERABLE: Array index out of bounds
let item = array[user_controlled_index];

// VULNERABLE: Slice out of bounds
let sub = &data[start..end];
```

**Detection strategy:**
- Search for `.unwrap()`, `.expect()`, array indexing
- Verify all can handle adversarial input

---

### 18. Timing Side-Channel Attacks

**Attack Vector:** Exploit non-constant-time comparison

**Mechanism:**
- Standard equality comparison returns early on mismatch
- Attacker measures response time
- Byte-by-byte MAC/signature guessing

**Pattern to detect:**
```rust
// VULNERABLE: Variable-time comparison
if computed_mac == expected_mac { ... }

// SAFE: Constant-time comparison
use subtle::ConstantTimeEq;
if computed_mac.ct_eq(&expected_mac).into() { ... }
```

**Detection:** Search for `==` comparison on cryptographic values (MAC, signature, hash, key)

---

## Insecure Defaults Patterns (Trail of Bits)

### 19. Hardcoded Keys/Secrets

**Attack Vector:** Discover and use hardcoded credentials

**Pattern to detect:**
```rust
// VULNERABLE: Hardcoded secret
const ADMIN_KEY: [u8; 32] = [0x12, 0x34, ...];
const API_SECRET: &str = "sk_live_...";
```

**Detection strategy:**
- Search for `const` with sensitive names (key, secret, password, token)
- Search for base64/hex-encoded strings

---

### 20. Fail-Open Authorization

**Attack Vector:** Authorization defaults to "allowed" on error

**Pattern to detect:**
```rust
// VULNERABLE: Fail-open
fn is_authorized(ctx: &Context) -> bool {
    match check_permission(ctx) {
        Ok(allowed) => allowed,
        Err(_) => true,  // ERROR: defaults to authorized!
    }
}

// SAFE: Fail-closed
fn is_authorized(ctx: &Context) -> Result<bool> {
    check_permission(ctx)  // Error propagates, denies access
}
```

**Detection:** Search for error handlers that return `true` or `Ok` on auth checks

---

### 21. Missing Rate Limits

**Attack Vector:** Resource exhaustion via repeated calls

**Pattern to detect:**
- Instructions with no cooldown/rate limit
- No per-user caps on operations
- No global throughput limits

**Detection:** Check for time-based or count-based limits on expensive operations

---

## Additional Solana-Specific Patterns

### 22. Account Revival Attack

**Attack Vector:** Restore "closed" account in same transaction

**Mechanism:**
- Account closed (lamports drained)
- Later instruction refunds lamports
- Account revived with stale data

**Pattern to detect:**
```rust
// VULNERABLE: Incomplete closure
pub fn close_account(ctx: Context<Close>) -> Result<()> {
    let account = &mut ctx.accounts.target;
    **account.to_account_info().try_borrow_mut_lamports()? = 0;
    // Missing: discriminator not cleared!
}

// SAFE: Complete closure
#[account(mut, close = destination)]
pub target: Account<'info, Data>,
```

**Detection:** Check that closed accounts have discriminator cleared and can't be revived

---

### 23. Cross-Instruction State Inconsistency

**Attack Vector:** Exploit state changes between instructions in same tx

**Mechanism:**
- Instruction A reads state
- Instruction B modifies state
- Instruction A uses stale assumptions

**Detection:** Check for multi-instruction flows with shared mutable state

---

### 24. Missing Program ID Validation on CPIs

**Attack Vector:** Substitute malicious program

**Pattern to detect:**
```rust
// VULNERABLE: Accepts any program
pub token_program: UncheckedAccount<'info>,

// SAFE: Type-checked program
pub token_program: Program<'info, Token>,
```

**Detection:** Search for `UncheckedAccount` or `AccountInfo` used in CPI targets

---

### 25. PDA Bump Seed Manipulation

**Attack Vector:** Use non-canonical bump to create alternate PDAs

**Pattern to detect:**
```rust
// VULNERABLE: User-provided bump
pub fn process(ctx: Context<MyCtx>, bump: u8) -> Result<()> {
    let seeds = &[b"seed", &[bump]];  // Attacker can try different bumps
}

// SAFE: Canonical bump only
#[account(seeds = [b"seed"], bump)]
pub pda: Account<'info, MyData>,
```

**Detection:** Search for bump seeds not using Anchor's canonical bump validation

---

### 26. Token Account Confusion

**Attack Vector:** Pass wrong token account type

**Pattern to detect:**
```rust
// VULNERABLE: No mint validation
pub user_token_account: Account<'info, TokenAccount>,

// SAFE: Mint validated
#[account(
    token::mint = expected_mint,
    token::authority = user,
)]
pub user_token_account: Account<'info, TokenAccount>,
```

**Detection:** Check all TokenAccount constraints include mint validation

---

## Cryptographic API Footguns

### 27. Algorithm Confusion

**Attack Vector:** Exploit flexible algorithm selection

**Pattern to detect:**
```rust
// VULNERABLE: Algorithm as parameter
fn verify(data: &[u8], sig: &[u8], algo: &str) -> bool {
    match algo {
        "none" => true,  // Bypass!
        _ => ...
    }
}
```

**Detection:** Search for algorithm/mode selection from user input

---

### 28. Nonce Reuse

**Attack Vector:** Reuse nonce to break encryption

**Pattern to detect:**
```rust
// VULNERABLE: Fixed nonce
let nonce = [0u8; 12];  // Same for all encryptions

// VULNERABLE: Counter overflow
static COUNTER: AtomicU64;  // Can wrap around
```

**Detection:** Search for nonce generation patterns, verify randomness or proper increment

---

## Strategy Generation Template

When generating attack hypotheses, use this structure:

```markdown
## H{number}: {Attack Name}

**Category:** {Access Control | Arithmetic | State Machine | ...}

**Hypothesis:**
{What the attacker is trying to achieve}

**Attack Vector:**
{Step-by-step how the attack would work}

**Target Code:**
- `file.rs`: `function_name` (lines X-Y)
- {Additional targets}

**Prerequisites:**
- {What attacker needs to execute this}

**Potential Impact:**
- {Severity: Critical/High/Medium/Low}
- {What damage could occur}

**Historical Precedent:**
- {Similar past exploit or "Novel attack"}

**Investigation Approach:**
1. {First thing to check}
2. {Second thing to check}
3. {How to confirm/deny vulnerability}

**Indicators to look for:**
- {Code pattern that suggests vulnerability}
- {Missing check that would indicate risk}
```

---

## Severity Rating Guide

| Severity | Criteria |
|----------|----------|
| **CRITICAL** | Direct fund loss, complete protocol compromise, no user action required |
| **HIGH** | Significant fund loss, privilege escalation, complex but achievable |
| **MEDIUM** | Limited fund loss, requires specific conditions, recoverable |
| **LOW** | Minor issues, theoretical concerns, requires unlikely conditions |
| **INFO** | Best practices, code quality, no direct security impact |

---

## External Resources

When generating strategies, consider consulting:

1. **Rekt.news** - DeFi exploit database
2. **Immunefi** - Bug bounty writeups
3. **Solana Security Best Practices** - solana.com/docs
4. **Anchor Book** - Security section
5. **OWASP Smart Contract Top 10**
6. **Trail of Bits publications**
7. **OpenZeppelin security advisories** (Ethereum patterns often apply)
