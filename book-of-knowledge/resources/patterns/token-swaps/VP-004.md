# VP-004: Minimum Output Enforcement

**Category:** Token Swaps
**Verification tool:** Kani

## What Can Go Wrong
A swap function may calculate the correct output but fail to check it against a user-provided minimum before transferring tokens. This can happen when the check is placed after the transfer, is conditionally skipped, or is missing entirely in certain code paths.

## Why It Matters
Without min_output enforcement, users are fully exposed to price manipulation. Even in normal market conditions, large swaps against thin liquidity can result in unexpectedly poor execution. The user has no recourse once tokens are transferred.

## Real-World Incident
Multiple Solana DEX forks launched without slippage checks, leading to user fund losses during volatile market conditions. The lack of min_output was a recurring finding in Solana security audits throughout 2022-2023.

## Invariant

### Formal Property
```
swap(input, min_output) → output WHERE:
  output >= min_output ∨ REVERT
  There exists no code path where output < min_output AND transaction succeeds
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_min_output_always_checked() {
    let output: u64 = kani::any();
    let min_output: u64 = kani::any();

    kani::assume!(min_output > 0);

    // Simulate swap result
    let swap_succeeds = output >= min_output;

    if swap_succeeds {
        kani::assert!(output >= min_output);
    }
    // If !swap_succeeds, the real function must revert
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn min_output_always_enforced(
        reserve_x in 1_000_000u64..1_000_000_000,
        reserve_y in 1_000_000u64..1_000_000_000,
        input in 1u64..100_000_000,
        min_output in 1u64..100_000_000
    ) {
        match do_swap(reserve_x, reserve_y, input, min_output) {
            Ok(output) => prop_assert!(output >= min_output),
            Err(e) => {
                // Expected: swap correctly rejected
                let theoretical = calculate_output(reserve_x, reserve_y, input);
                prop_assert!(theoretical < min_output as u128);
            }
        }
    }
}
```

### LiteSVM Assertion
```rust
// Test: min_output = u64::MAX should always fail
let ix = build_swap_ix(input_amount, u64::MAX);
let result = process_transaction(&mut banks_client, ix, &payer).await;
assert!(result.is_err(), "swap must revert when min_output impossible");
```

## Suggested Fix
```rust
pub fn swap(ctx: Context<Swap>, input: u64, min_output: u64) -> Result<()> {
    let output = calculate_output(&ctx.accounts.pool, input)?;
    // Check BEFORE any transfer
    require!(output >= min_output, SwapError::SlippageExceeded);
    transfer_tokens(ctx, output)?;
    Ok(())
}
```
