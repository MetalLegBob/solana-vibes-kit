# VP-034: Cross-Token Yield Normalization

**Category:** Interest/Yield
**Verification tool:** Proptest

## What Can Go Wrong
When yield is earned in one token but deposited in another (different decimals), the conversion must account for decimal differences. USDC (6 decimals) yield on a SOL (9 decimals) deposit requires multiplying by 10^3. If this normalization is wrong, yields are off by orders of magnitude.

## Why It Matters
A 3-decimal error means either 1000x too much yield (draining the protocol) or 1000x too little (users earn nothing). Both are catastrophic.

## Real-World Incident
Cross-token decimal normalization bugs have been found in multiple Solana DeFi audits. Jet Protocol and Solend both had to carefully handle decimal differences between collateral and borrowed tokens.

## Invariant

### Formal Property
```
yield_normalized = yield_raw * 10^(target_decimals) / 10^(source_decimals)
Or equivalently: yield_normalized = yield_raw * 10^(target_decimals - source_decimals)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_decimal_normalization() {
    let yield_raw: u64 = kani::any();
    let source_decimals: u8 = kani::any();
    let target_decimals: u8 = kani::any();

    kani::assume!(yield_raw > 0 && yield_raw < 1_000_000_000_000);
    kani::assume!(source_decimals <= 18 && target_decimals <= 18);

    if target_decimals >= source_decimals {
        let scale = 10u128.pow((target_decimals - source_decimals) as u32);
        let normalized = (yield_raw as u128).checked_mul(scale);
        kani::assert!(normalized.is_some(), "normalization overflow");
    } else {
        let scale = 10u128.pow((source_decimals - target_decimals) as u32);
        let normalized = (yield_raw as u128) / scale;
        kani::assert!(normalized <= yield_raw as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn normalize_roundtrip(
        amount in 1u64..1_000_000_000,
        src_dec in 0u8..=9,
        tgt_dec in 0u8..=9
    ) {
        let normalized = normalize_decimals(amount, src_dec, tgt_dec);
        let back = normalize_decimals(normalized, tgt_dec, src_dec);
        // Round-trip may lose precision (truncation) but should be close
        let diff = if back > amount { back - amount } else { amount - back };
        let tolerance = if src_dec > tgt_dec {
            10u64.pow((src_dec - tgt_dec) as u32)
        } else { 1 };
        prop_assert!(diff < tolerance, "roundtrip error {} > tolerance {}", diff, tolerance);
    }
}
```

### LiteSVM Assertion
```rust
// Deposit 1 SOL (9 decimals), earn yield in USDC (6 decimals)
let yield_usdc = 1_000_000u64; // 1 USDC
let yield_in_sol_units = normalize_decimals(yield_usdc, 6, 9);
assert_eq!(yield_in_sol_units, 1_000_000_000, "1 USDC should be 10^9 in SOL decimals");
```

## Suggested Fix
```rust
pub fn normalize_decimals(amount: u64, from_decimals: u8, to_decimals: u8) -> u64 {
    if from_decimals == to_decimals {
        amount
    } else if to_decimals > from_decimals {
        let scale = 10u64.pow((to_decimals - from_decimals) as u32);
        amount.checked_mul(scale).expect("decimal normalization overflow")
    } else {
        let scale = 10u64.pow((from_decimals - to_decimals) as u32);
        amount / scale // truncation is acceptable (rounds down)
    }
}
```
