# VP-026: Reward Distribution Total Never Exceeds Allocation

**Category:** Staking Rewards
**Verification tool:** LiteSVM

## What Can Go Wrong
If the sum of all individual rewards exceeds the total tokens allocated to the reward pool, the last claimers will find the pool empty. This can happen due to rounding up individual rewards (each claim takes ceil, but total was computed as floor) or due to reward rate drift.

## Why It Matters
An insolvent reward pool means some users can't claim their rewards. This is a protocol-breaking bug that destroys trust. The protocol either needs to inject emergency funds or some users lose their earned rewards.

## Real-World Incident
Multiple DeFi reward programs have faced insolvency due to reward overpayment. The Solana ecosystem saw several staking programs run out of reward tokens due to rounding errors accumulating faster than expected.

## Invariant

### Formal Property
```
Σ(all_user_rewards_claimed) <= total_rewards_deposited
At any point: pool.reward_vault.amount >= Σ(all_user_pending_rewards)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_total_rewards_bounded() {
    let total_allocated: u64 = kani::any();
    let num_stakers: u8 = kani::any();

    kani::assume!(total_allocated > 1_000_000);
    kani::assume!(num_stakers > 0 && num_stakers <= 10);

    // Each staker claims floor of their share
    let per_staker = total_allocated as u128 / (num_stakers as u128);
    let total_claimed = per_staker * (num_stakers as u128);

    kani::assert!(total_claimed <= total_allocated as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn total_claims_within_budget(
        total_reward in 1_000_000u64..1_000_000_000,
        stakes in prop::collection::vec(1_000u64..1_000_000, 2..=20)
    ) {
        let total_staked: u128 = stakes.iter().map(|&s| s as u128).sum();
        let total_claimed: u128 = stakes.iter()
            .map(|&s| (total_reward as u128) * (s as u128) / total_staked)
            .sum();
        prop_assert!(total_claimed <= total_reward as u128,
            "claimed {} > allocated {}", total_claimed, total_reward);
    }
}
```

### LiteSVM Assertion
```rust
let vault_before = get_token_balance(&ctx, reward_vault).await;
// All stakers claim
for user in &stakers {
    claim(&mut ctx, user).await.unwrap();
}
let vault_after = get_token_balance(&ctx, reward_vault).await;
assert!(vault_after >= 0, "reward vault went negative");
let total_distributed = vault_before - vault_after;
assert!(total_distributed <= total_rewards_deposited,
    "distributed {} > deposited {}", total_distributed, total_rewards_deposited);
```

## Suggested Fix
```rust
// Use floor division for individual rewards (protocol keeps dust)
pub fn claim_reward(user: &mut UserStake, pool: &Pool, vault: &mut TokenAccount) -> Result<u64> {
    let pending = pool.reward_per_token_stored
        * (user.staked_amount as u128) / PRECISION;
    let reward = pending.saturating_sub(user.reward_debt) as u64;
    // Floor division ensures sum of claims <= total
    require!(vault.amount >= reward, StakeError::InsufficientRewards);
    user.reward_debt = pending;
    Ok(reward)
}
```
