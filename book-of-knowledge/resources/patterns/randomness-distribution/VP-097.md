# VP-097: VRF Output Distribution Fairness

**Category:** Randomness/Distribution
**Verification tool:** Proptest

## What Can Go Wrong
VRF (Verifiable Random Function) outputs are deterministic given a seed but should appear uniformly random. If the VRF output is used without proper hashing or truncation, the distribution may be non-uniform. Additionally, if the seed is predictable, the randomness is exploitable.

## Why It Matters
Non-uniform VRF output means some lottery tickets, NFT traits, or random selections are more likely than others. Predictable seeds mean the outcome is known before the transaction, enabling front-running.

## Real-World Incident
Switchboard VRF on Solana provides verifiable randomness. Before VRF adoption, many Solana programs used blockhash as a randomness source, which validators could manipulate.

## Invariant

### Formal Property
```
For VRF output hash H and bucket count n:
  P(H mod n = k) ≈ 1/n for all k ∈ [0, n)
  Chi-squared test p-value > 0.01 over sufficient samples
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_vrf_output_in_range() {
    let vrf_output: [u8; 32] = kani::any();
    let n: u64 = kani::any();

    kani::assume!(n > 0);

    let value = u64::from_le_bytes(vrf_output[0..8].try_into().unwrap());
    let result = value % n;

    kani::assert!(result < n);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn vrf_output_uniform(n in 2u64..100) {
        let mut counts = vec![0u64; n as usize];
        let samples = 50_000;
        for seed in 0..samples {
            let hash = sha256(&seed.to_le_bytes());
            let value = u64::from_le_bytes(hash[0..8].try_into().unwrap());
            counts[(value % n) as usize] += 1;
        }
        let expected = samples / n;
        let tolerance = expected / 5;
        for (i, &c) in counts.iter().enumerate() {
            prop_assert!((c as i64 - expected as i64).unsigned_abs() < tolerance,
                "bucket {} biased: {} vs expected {}", i, c, expected);
        }
    }
}
```

### LiteSVM Assertion
```rust
let vrf_result = request_vrf(&mut ctx, seed).await.unwrap();
assert!(vrf_result.len() == 32, "VRF output should be 32 bytes");
let value = u64::from_le_bytes(vrf_result[0..8].try_into().unwrap());
let selection = value % num_participants;
assert!(selection < num_participants);
```

## Suggested Fix
```rust
pub fn vrf_to_range(vrf_output: &[u8; 32], max: u64) -> u64 {
    // Use first 8 bytes as u64, with rejection sampling for unbiased result
    let raw = u64::from_le_bytes(vrf_output[0..8].try_into().unwrap());
    let limit = u64::MAX - (u64::MAX % max);
    if raw >= limit {
        // Fallback: use next 8 bytes
        let raw2 = u64::from_le_bytes(vrf_output[8..16].try_into().unwrap());
        return raw2 % max;
    }
    raw % max
}
```
