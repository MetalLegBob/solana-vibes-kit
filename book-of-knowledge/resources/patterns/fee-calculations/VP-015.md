# VP-015: Basis Point Calculation Overflow

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
Multiplying amount * fee_bps can overflow u64 when amount is large. u64::MAX * 10_000 overflows u64. If the multiplication is done in u64 without widening to u128 first, the result wraps around, producing an incorrect (usually tiny) fee.

## Why It Matters
On Solana, token amounts can be up to u64::MAX (~18.4 quintillion). A fee calculation that overflows produces a garbage result — potentially a fee of 0 on a billion-dollar transaction, or a fee larger than the transaction.

## Real-World Incident
Integer overflow is listed as the #1 smart contract issue by QuillAudits' Solana Top 10 analysis. The Sec3 blog documents that Rust programs in release mode silently wrap on overflow, making fee BPS multiplication a particularly dangerous operation for Solana programs.

## Invariant

### Formal Property
```
∀ amount: u64, fee_bps: u16:
  amount as u128 * fee_bps as u128 <= u128::MAX (always true)
  No u64 overflow occurs in intermediate calculation
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_no_fee_overflow() {
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(fee_bps <= 10_000);

    // u128 intermediate: cannot overflow
    let result = (amount as u128) * (fee_bps as u128);
    kani::assert!(result <= u128::MAX);

    let fee = result / 10_000;
    kani::assert!(fee <= amount as u128);

    // Verify fits back in u64
    kani::assert!(fee <= u64::MAX as u128);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_calc_no_overflow(
        amount in 0u64..u64::MAX,
        fee_bps in 0u16..=10_000
    ) {
        // This must not panic
        let fee = safe_fee(amount, fee_bps);
        prop_assert!(fee <= amount);
    }
}
```

### LiteSVM Assertion
```rust
// Max amount swap should still compute fee correctly
let max_swap_ix = build_swap_ix(u64::MAX - 1, 0);
let result = process_transaction(&mut ctx, max_swap_ix, &payer).await;
// Should either succeed with correct fee or fail gracefully (not panic/overflow)
```

## Suggested Fix
```rust
pub fn safe_fee(amount: u64, bps: u16) -> u64 {
    // ALWAYS widen to u128 BEFORE multiplying
    let fee = (amount as u128) * (bps as u128) / 10_000;
    fee as u64 // Safe: result <= amount since bps <= 10_000
}
```
