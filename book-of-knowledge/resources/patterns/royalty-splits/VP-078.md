# VP-078: Percentage Distribution Sums to 100%

**Category:** Royalty/Revenue Splits
**Verification tool:** Kani

## What Can Go Wrong
In a revenue split configuration, all recipient share percentages (expressed in basis points) must sum to exactly 10,000 (100%). If shares sum to less than 10,000, a fraction of every distribution is permanently locked in the contract. If shares sum to more than 10,000, the final transfer over-drafts the escrow or the last recipient silently receives less than their entitlement.

## Why It Matters
A misconfigured split where shares total 9,900 bps silently traps 1% of all incoming revenue. On a marketplace routing 10M SOL annually through creator royalties, that is 100,000 SOL locked with no reclamation path. Both over- and under-sum failures are silent at configuration time and only surface under live payment flow.

## Real-World Incident
Percentage validation bugs are among the most frequent findings in payment-splitter audits. OpenZeppelin's PaymentSplitter and Thirdweb's Split contract both include explicit sum-to-total checks after multiple audit reports flagged missing validation in fork deployments.

## Invariant

### Formal Property
```
forall shares[] where len(shares) in [1, MAX_RECIPIENTS]:
  sum(shares[i].bps for i in 0..len) == 10000
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_shares_sum_to_total() {
    let n: usize = kani::any();
    kani::assume!(n >= 1 && n <= 10);
    let mut shares = [0u16; 10];
    let mut sum: u32 = 0;
    for i in 0..n {
        shares[i] = kani::any();
        kani::assume!(shares[i] >= 1 && shares[i] <= 10_000);
        sum += shares[i] as u32;
    }
    kani::assume!(sum == 10_000);
    let recomputed: u32 = shares[..n].iter().map(|s| *s as u32).sum();
    kani::assert!(recomputed == 10_000);
    for i in 0..n {
        kani::assert!(shares[i] >= 1);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn shares_always_sum_to_10000(
        n in 2usize..=10,
        seed in prop::collection::vec(1u16..5000, 10)
    ) {
        let raw_sum: u32 = seed[..n].iter().map(|s| *s as u32).sum();
        let mut shares: Vec<u16> = seed[..n]
            .iter()
            .map(|s| ((*s as u32) * 10_000 / raw_sum) as u16)
            .collect();
        let partial: u32 = shares.iter().map(|s| *s as u32).sum();
        shares[n - 1] = shares[n - 1].checked_add((10_000u32 - partial) as u16).unwrap();
        let total: u32 = shares.iter().map(|s| *s as u32).sum();
        prop_assert_eq!(total, 10_000, "shares must sum to 10000 bps");
        for s in &shares {
            prop_assert!(*s >= 1, "zero-share recipient is invalid");
        }
    }
}
```

### LiteSVM Assertion
```rust
let shares = vec![2500u16, 2500, 2500, 2500]; // valid: sums to 10000
let ix = create_split_config(&program_id, &authority, &recipients, &shares);
let result = process_transaction(&mut banks_client, ix, &payer).await;
assert!(result.is_ok(), "valid 10000 bps config should succeed");

let bad_shares = vec![2500u16, 2500, 2500, 1500]; // invalid: sums to 9000
let bad_ix = create_split_config(&program_id, &authority, &recipients, &bad_shares);
let bad_result = process_transaction(&mut banks_client, bad_ix, &payer).await;
assert!(bad_result.is_err(), "config summing to 9000 bps must be rejected");
```

## Suggested Fix
```rust
pub fn validate_shares(shares: &[u16]) -> Result<(), SplitError> {
    if shares.is_empty() || shares.len() > MAX_RECIPIENTS {
        return Err(SplitError::InvalidRecipientCount);
    }
    let total: u32 = shares.iter().map(|s| *s as u32).sum();
    if total != 10_000 {
        return Err(SplitError::SharesSumMismatch { expected: 10_000, actual: total });
    }
    if shares.iter().any(|s| *s == 0) {
        return Err(SplitError::ZeroShare);
    }
    Ok(())
}
```
