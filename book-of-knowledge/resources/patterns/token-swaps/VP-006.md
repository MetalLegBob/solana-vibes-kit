# VP-006: Concentrated Liquidity Tick Math Precision

**Category:** Token Swaps
**Verification tool:** Proptest

## What Can Go Wrong
Concentrated liquidity AMMs use tick-to-price conversions (price = 1.0001^tick). The conversion between ticks and sqrt prices involves fixed-point arithmetic that can lose precision. If tick_to_sqrt_price and sqrt_price_to_tick are not inverses within acceptable bounds, positions can be placed at wrong price ranges.

## Why It Matters
Precision loss in tick math means liquidity providers get placed at incorrect price ranges, potentially earning no fees or being exposed to more impermanent loss than expected. Arbitrageurs can exploit price discontinuities between ticks.

## Real-World Incident
Crema Finance (Solana, July 2022) had tick manipulation issues in their concentrated liquidity implementation. Uniswap V3 forks frequently ship with tick math precision bugs due to the complexity of the fixed-point arithmetic.

## Invariant

### Formal Property
```
∀ tick ∈ [MIN_TICK, MAX_TICK]:
  |sqrt_price_to_tick(tick_to_sqrt_price(tick)) - tick| <= 1
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_tick_roundtrip() {
    let tick: i32 = kani::any();
    kani::assume!(tick >= -443636 && tick <= 443636); // Uniswap V3 range

    let sqrt_price = tick_to_sqrt_price(tick);
    let recovered_tick = sqrt_price_to_tick(sqrt_price);

    // Round-trip must be within 1 tick
    kani::assert!((recovered_tick - tick).abs() <= 1);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn tick_sqrt_price_roundtrip(tick in -443636i32..443636) {
        let sqrt_price = tick_to_sqrt_price(tick);
        let recovered = sqrt_price_to_tick(sqrt_price);
        prop_assert!((recovered - tick).abs() <= 1,
            "tick {} -> sqrt_price {} -> tick {}", tick, sqrt_price, recovered);
    }
}
```

### LiteSVM Assertion
```rust
for tick in [-443636, -1000, -1, 0, 1, 1000, 443636] {
    let sqrt_price = tick_to_sqrt_price(tick);
    let recovered = sqrt_price_to_tick(sqrt_price);
    assert!((recovered - tick).abs() <= 1, "tick roundtrip failed at {}", tick);
}
```

## Suggested Fix
```rust
pub fn tick_to_sqrt_price(tick: i32) -> u128 {
    // Use Q64.64 fixed-point with sufficient intermediate precision
    let abs_tick = tick.unsigned_abs();
    let mut ratio: u256 = if abs_tick & 0x1 != 0 {
        U256::from(0xfffcb933bd6fad37aa2d162d1a594001u128)
    } else {
        U256::from(1u128) << 128
    };
    // ... successive multiplications with full precision
    // Final: shift and round
}
```
