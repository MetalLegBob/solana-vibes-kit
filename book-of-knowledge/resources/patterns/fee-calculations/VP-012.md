# VP-012: Fee Never Exceeds Principal

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
If fee_bps > 10_000 is allowed, or if multiplication overflows before division, the computed fee can exceed the input amount. Subtracting this fee from the input causes an underflow — either reverting (safe) or wrapping to a huge number (catastrophic).

## Why It Matters
A fee exceeding the principal means the user would owe more in fees than they sent. This is always a bug. If unchecked math is used, the underflow wraps to near-u64::MAX, and the swap operates on a phantom amount, potentially draining the entire pool.

## Real-World Incident
No specific public incident documented, but fee-exceeds-principal is a recurring audit finding. Neodyme's Solana audit reports consistently flag missing upper-bound checks on fee parameters.

## Invariant

### Formal Property
```
∀ amount, fee_bps:
  fee_bps <= 10_000
  fee(amount, fee_bps) <= amount
  amount - fee(amount, fee_bps) >= 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_bounded_by_principal() {
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(fee_bps <= 10_000);
    kani::assume!(amount > 0);

    let fee = (amount as u128) * (fee_bps as u128) / 10_000;

    kani::assert!(fee <= amount as u128);
    kani::assert!((amount as u128) - fee >= 0);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn fee_never_exceeds_amount(amount in 1u64..u64::MAX, fee_bps in 0u16..=10_000) {
        let fee = calculate_fee(amount, fee_bps);
        prop_assert!(fee <= amount, "fee {} > amount {}", fee, amount);
    }
}
```

### LiteSVM Assertion
```rust
// Try setting fee_bps to 10_001 — must be rejected
let result = update_fee_rate(&mut ctx, 10_001).await;
assert!(result.is_err(), "fee_bps > 10_000 must be rejected");
```

## Suggested Fix
```rust
pub fn calculate_fee(amount: u64, fee_bps: u16) -> Result<u64> {
    require!(fee_bps <= 10_000, FeeError::RateExceedsMax);
    let fee = (amount as u128) * (fee_bps as u128) / 10_000;
    Ok(fee as u64) // Safe: fee <= amount when fee_bps <= 10_000
}
```
