# VP-068: Rounding in Borrower vs Protocol Favor

**Category:** Collateral Ratios
**Verification tool:** Kani

## What Can Go Wrong
When computing collateral values and debt amounts, rounding must be directionally safe: collateral rounds down and debt rounds up (both conservative for the protocol). If rounding goes the wrong direction, borrowers extract tiny amounts of excess value on each operation. Over millions of transactions, this drains the protocol's lending pool.

## Why It Matters
An attacker performs many small borrow-repay cycles, each extracting a fraction of a token due to favorable rounding. With sufficient iterations the attacker drains meaningful value. This is especially effective with tokens that have few decimal places, where a single unit of rounding error represents a larger dollar value.

## Real-World Incident
The Compound V2 codebase explicitly documents rounding direction requirements for this reason. Multiple Solana lending audits have flagged cases where truncation favored the borrower when it should have favored the protocol, including a high-severity finding in a Port Finance audit.

## Invariant

### Formal Property
```
forall amount, rate_bps:
  collateral_value = floor(amount * rate_bps / 10000)
  debt_value       = ceil(amount * rate_bps / 10000)
  debt_value - collateral_value <= 1
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rounding_direction() {
    let amount: u64 = kani::any();
    let rate_bps: u64 = kani::any();

    kani::assume!(amount > 0 && amount < 1_000_000_000);
    kani::assume!(rate_bps > 0 && rate_bps <= 10_000);

    let num = (amount as u128) * (rate_bps as u128);
    let floor_val = num / 10_000;
    let ceil_val = (num + 9_999) / 10_000;

    kani::assert!(ceil_val >= floor_val);
    kani::assert!(ceil_val - floor_val <= 1);
    kani::assert!(floor_val * 10_000 <= num);
    kani::assert!(ceil_val * 10_000 >= num);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn rounding_favors_protocol(
        amount in 1u64..1_000_000_000,
        rate_bps in 1u64..10_000,
    ) {
        let num = (amount as u128) * (rate_bps as u128);
        let collateral = num / 10_000;
        let debt = (num + 9_999) / 10_000;
        prop_assert!(debt >= collateral);
        prop_assert!(debt - collateral <= 1);
        prop_assert!(collateral * 10_000 <= num);
    }
}
```

### LiteSVM Assertion
```rust
let position = create_position(&mut ctx, borrower, collateral_amount).await;
let state = get_position_state(&ctx, position).await;

let exact = (collateral_amount as u128) * (price as u128);
assert!(state.collateral_value as u128 <= exact / PRECISION, "collateral must floor");

borrow(&mut ctx, position, borrow_amount).await.unwrap();
let state = get_position_state(&ctx, position).await;
let exact_debt = (borrow_amount as u128) * (price as u128);
assert!(state.debt_value as u128 >= (exact_debt + PRECISION - 1) / PRECISION, "debt must ceil");
```

## Suggested Fix
```rust
pub fn value_floor(amount: u64, rate_bps: u64) -> Result<u64> {
    let result = (amount as u128).checked_mul(rate_bps as u128)
        .ok_or(LendingError::Overflow)? / 10_000;
    Ok(result as u64)
}

pub fn value_ceil(amount: u64, rate_bps: u64) -> Result<u64> {
    let num = (amount as u128).checked_mul(rate_bps as u128)
        .ok_or(LendingError::Overflow)?;
    Ok((num.checked_add(9_999).ok_or(LendingError::Overflow)? / 10_000) as u64)
}
```
