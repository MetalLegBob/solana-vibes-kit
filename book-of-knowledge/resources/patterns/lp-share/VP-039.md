# VP-039: Imbalanced Deposit Share Fairness

**Category:** LP Share
**Verification tool:** LiteSVM

## What Can Go Wrong
In a two-token pool, a balanced deposit adds both tokens proportionally. An imbalanced deposit (adding only one token) should give fewer shares due to the implicit swap required. If the share calculation doesn't penalize imbalanced deposits, arbitrageurs can profit by depositing single-sided and withdrawing balanced.

## Why It Matters
Without an imbalance penalty, depositing one token and immediately withdrawing both tokens is equivalent to a fee-free swap, bypassing the pool's swap fee. This drains fee revenue and can destabilize the pool.

## Real-World Incident
Balancer V1 on Ethereum had imbalanced deposit exploits. Raydium on Solana addressed this by requiring balanced deposits or applying single-sided deposit fees.

## Invariant

### Formal Property
```
For imbalanced deposit of only token A:
  shares_imbalanced < shares_balanced_equivalent
  The difference accounts for the implicit swap fee
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_imbalanced_penalty() {
    let reserve_a: u64 = kani::any();
    let reserve_b: u64 = kani::any();
    let total_shares: u64 = kani::any();
    let deposit_a: u64 = kani::any();

    kani::assume!(reserve_a > 1_000_000 && reserve_b > 1_000_000);
    kani::assume!(total_shares > 1_000);
    kani::assume!(deposit_a > 0 && deposit_a < reserve_a);

    // Balanced: deposit proportional A and B
    let balanced_shares = (deposit_a as u128) * (total_shares as u128) / (reserve_a as u128);

    // Imbalanced: only deposit A (must be < balanced due to swap penalty)
    let effective_after_swap = deposit_a as u128 / 2; // half gets "swapped"
    let swap_fee = effective_after_swap * 30 / 10_000; // 30bps fee
    let imbalanced_shares = (deposit_a as u128 - swap_fee) * (total_shares as u128) / (reserve_a as u128 * 2);

    kani::assert!(imbalanced_shares < balanced_shares);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn imbalanced_gives_fewer_shares(
        reserve in 1_000_000u64..1_000_000_000,
        shares in 1_000u64..1_000_000_000,
        deposit in 1_000u64..10_000_000
    ) {
        let balanced = compute_balanced_shares(reserve, reserve, shares, deposit, deposit);
        let imbalanced = compute_imbalanced_shares(reserve, reserve, shares, deposit, 0);
        prop_assert!(imbalanced <= balanced,
            "imbalanced {} > balanced {}", imbalanced, balanced);
    }
}
```

### LiteSVM Assertion
```rust
// Balanced deposit
let shares_balanced = deposit_balanced(&mut ctx, &alice, 1_000_000, 1_000_000).await;
// Imbalanced deposit (same total value, but all in token A)
let shares_imbalanced = deposit_single_sided(&mut ctx, &bob, 2_000_000, 0).await;
assert!(shares_imbalanced < shares_balanced,
    "imbalanced {} >= balanced {}", shares_imbalanced, shares_balanced);
```

## Suggested Fix
```rust
pub fn deposit_single_sided(pool: &mut Pool, token: Token, amount: u64) -> Result<u64> {
    // Calculate implicit swap: half of deposit swaps to other token
    let swap_amount = amount / 2;
    let swap_fee = fee_ceil(swap_amount, pool.fee_bps);
    let effective = amount - swap_fee;
    // Mint shares based on effective (penalized) amount
    let shares = effective as u128 * pool.total_shares as u128 / pool.total_value() as u128;
    Ok(shares as u64)
}
```
