# VP-082: 6-to-9 Decimal Conversion Precision

**Category:** Decimal Normalization
**Verification tool:** Kani

## What Can Go Wrong
Converting USDC (6 decimals) amounts to SOL (9 decimals) requires multiplying by 10^3. Converting back requires dividing by 10^3 with truncation. The round-trip loses precision — 1 USDC-unit (0.000001) becomes 1000 SOL-units but 999 SOL-units becomes 0 USDC-units.

## Why It Matters
Cross-token operations (swaps, collateral valuation) that don't handle decimal differences can be off by 1000x. A 1 USDC value interpreted in 9-decimal space without conversion would be 0.000000001 instead of 0.000001.

## Real-World Incident
Multiple Solana lending protocol audits flagged decimal normalization issues between USDC (6 decimals) and SOL (9 decimals). Jet Protocol v1 had a decimal handling fix during audit.

## Invariant

### Formal Property
```
normalize(amount, 6, 9) = amount * 1000
normalize(amount, 9, 6) = amount / 1000
normalize(normalize(amount, 6, 9), 9, 6) = amount (exact round-trip for USDC→SOL→USDC)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_6_to_9_roundtrip() {
    let amount: u64 = kani::any();
    kani::assume!(amount > 0 && amount < u64::MAX / 1000);

    let to_9 = amount * 1000;
    let back_to_6 = to_9 / 1000;

    kani::assert!(back_to_6 == amount, "roundtrip lost precision");
    kani::assert!(to_9 >= amount, "normalization decreased amount");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn decimal_6_to_9_roundtrip(amount in 1u64..1_000_000_000_000) {
        let up = normalize(amount, 6, 9);
        let down = normalize(up, 9, 6);
        prop_assert_eq!(down, amount, "roundtrip failed for {}", amount);
    }
}
```

### LiteSVM Assertion
```rust
let usdc_amount = 1_000_000u64; // 1 USDC
let sol_equivalent = normalize_decimals(usdc_amount, 6, 9);
assert_eq!(sol_equivalent, 1_000_000_000, "1 USDC should be 10^9 in SOL units");
```

## Suggested Fix
```rust
pub fn normalize_decimals(amount: u64, from: u8, to: u8) -> Result<u64> {
    if from == to { return Ok(amount); }
    if to > from {
        let scale = 10u64.checked_pow((to - from) as u32).ok_or(MathError::Overflow)?;
        amount.checked_mul(scale).ok_or(MathError::Overflow)
    } else {
        let scale = 10u64.pow((from - to) as u32);
        Ok(amount / scale)
    }
}
```
