# VP-072: Quorum Calculation Accuracy

**Category:** Vote/Governance
**Verification tool:** Kani

## What Can Go Wrong
Quorum threshold is calculated as `total_supply * quorum_bps / 10000`. When total_supply is very large (e.g., 10^18 for typical token supplies), the multiplication can overflow u64. When quorum_bps is very small relative to total_supply, integer division can truncate the quorum to zero, allowing any single vote to meet quorum. Conversely, overflow wraps the result to an impossibly large or impossibly small value, either freezing governance or making it trivially passable.

## Why It Matters
If quorum truncates to zero, an attacker passes a malicious governance proposal with a single vote, draining the treasury or upgrading the program to a backdoored version. If the multiplication overflows and wraps to a huge value, no proposal can ever reach quorum, permanently freezing governance. Both outcomes are catastrophic: one gives attackers instant control, the other permanently disables the DAO.

## Real-World Incident
No single named exploit, but quorum calculation bugs have been flagged in multiple DAO governance audits. The Beanstalk governance attack (April 2022, $182M lost) exploited a quorum-related flaw where flash-loaned governance tokens met the quorum threshold in a single block.

## Invariant

### Formal Property
```
For total_supply > 0, quorum_bps > 0, quorum_bps <= 10000:
  quorum = total_supply * quorum_bps / 10000
  quorum > 0                                    (no trivial quorum)
  quorum <= total_supply                        (reachable quorum)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_quorum_calculation() {
    let supply: u64 = kani::any();
    let bps: u16 = kani::any();

    kani::assume!(supply > 0 && supply <= 10_000_000_000_000_000_000); // up to 10^19
    kani::assume!(bps > 0 && bps <= 10_000);

    // Use u128 to prevent overflow
    let quorum = (supply as u128) * (bps as u128) / 10_000;

    kani::assert!(quorum > 0);                       // never zero
    kani::assert!(quorum <= supply as u128);          // always reachable
    kani::assert!(quorum <= u64::MAX as u128);        // fits in u64
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn quorum_nonzero_and_reachable(
        supply in 1u64..10_000_000_000_000_000_000,
        bps in 1u16..=10_000
    ) {
        let quorum = (supply as u128) * (bps as u128) / 10_000;
        prop_assert!(quorum > 0, "quorum is zero for supply={}, bps={}", supply, bps);
        prop_assert!(quorum <= supply as u128, "quorum exceeds total supply");

        // Verify u64 naive calculation would overflow for large supply
        let naive = (supply as u128) * (bps as u128);
        if naive > u64::MAX as u128 {
            // This would overflow without u128 intermediate
            prop_assert!(true, "u128 prevented overflow");
        }
    }
}
```

### LiteSVM Assertion
```rust
// Create a proposal with high supply and low quorum_bps
let supply: u64 = 10_000_000_000_000_000_000; // 10^19
let quorum_bps: u16 = 1; // 0.01%
process_transaction(&mut banks_client, create_proposal_ix, &payer).await.unwrap();

let proposal = get_proposal_state(&banks_client, proposal_key).await;
assert!(proposal.quorum_threshold > 0, "quorum must not be zero");
assert!(proposal.quorum_threshold <= supply, "quorum must be reachable");
// Expected: 10^19 * 1 / 10000 = 10^15
assert_eq!(proposal.quorum_threshold, 1_000_000_000_000_000);
```

## Suggested Fix
```rust
pub fn calculate_quorum(total_supply: u64, quorum_bps: u16) -> Result<u64> {
    require!(quorum_bps > 0 && quorum_bps <= 10_000, GovernanceError::InvalidBps);
    let quorum = (total_supply as u128)
        .checked_mul(quorum_bps as u128)
        .ok_or(GovernanceError::Overflow)?
        / 10_000;
    // Enforce minimum quorum of 1 to prevent trivial passage
    let quorum = quorum.max(1);
    Ok(quorum as u64)
}
```
