# VP-095: Leverage Ratio Boundary Enforcement

**Category:** Leverage/Perpetuals
**Verification tool:** Kani

## What Can Go Wrong
Effective leverage = position_notional / margin. As the market moves against a position, unrealized losses reduce the effective margin, increasing effective leverage beyond the maximum. If the protocol doesn't continuously check this, positions can reach extreme leverage before liquidation triggers.

## Why It Matters
A position at 200x effective leverage (when max is 100x) has twice the intended risk. If liquidation doesn't trigger until the position is underwater, the bad debt exceeds what the insurance fund can cover.

## Real-World Incident
The FTX/Alameda situation involved positions with effectively unlimited leverage. On-chain perpetual protocols have strict maximum leverage enforcement to prevent this.

## Invariant

### Formal Property
```
effective_leverage = position_notional / (margin + unrealized_pnl)
effective_leverage <= max_leverage at all times
If effective_leverage > max_leverage â†’ trigger deleveraging or liquidation
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_leverage_bounded() {
    let notional: u64 = kani::any();
    let margin: u64 = kani::any();
    let max_leverage: u8 = kani::any();

    kani::assume!(notional > 0 && margin > 0);
    kani::assume!(max_leverage > 0 && max_leverage <= 100);

    let effective = notional as u128 / margin as u128;

    if effective > max_leverage as u128 {
        // Must trigger liquidation/deleveraging
        kani::assert!(effective > max_leverage as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn initial_leverage_within_max(
        notional in 1_000_000u64..1_000_000_000,
        max_lev in 2u8..100
    ) {
        let min_margin = margin_required_ceil(notional, max_lev);
        let effective = notional as f64 / min_margin as f64;
        prop_assert!(effective <= max_lev as f64 + 0.01,
            "effective {} > max {}", effective, max_lev);
    }
}
```

### LiteSVM Assertion
```rust
// Open at max leverage
let margin = notional / max_leverage as u64;
open_position(&mut ctx, &user, notional, margin).await.unwrap();
let eff_lev = get_effective_leverage(&ctx, &user).await;
assert!(eff_lev <= max_leverage as f64 + 0.1, "exceeded max leverage");
```

## Suggested Fix
```rust
pub fn check_leverage(position: &Position, margin: u64, max: u8) -> Result<()> {
    let effective = position.notional as u128 / margin.max(1) as u128;
    require!(effective <= max as u128, PerpError::ExcessiveLeverage);
    Ok(())
}
```
