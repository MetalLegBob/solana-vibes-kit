# VP-043: Decimal Normalization Between Oracle and Token

**Category:** Price Oracle
**Verification tool:** Kani

## What Can Go Wrong
Oracle prices are reported with their own decimal precision (e.g., Pyth uses variable exponents). Tokens have their own decimals (USDC=6, SOL=9). When computing `value = amount * price`, the decimals must be correctly normalized. A mismatch means values are off by orders of magnitude.

## Why It Matters
If price decimals and token decimals aren't aligned, a user's $100 position might be valued at $100,000 (allowing excess borrowing) or $0.10 (triggering unfair liquidation). Both are catastrophic.

## Real-World Incident
Multiple Solana lending protocol audits have flagged decimal normalization bugs between Pyth price feeds and SPL token amounts. Jet Protocol v1 had a decimal handling issue found during audit.

## Invariant

### Formal Property
```
value_usd = token_amount * price / 10^(token_decimals + price_exponent_offset)
The result must be in consistent units (e.g., USD with 6 decimals)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_oracle_decimal_normalization() {
    let amount: u64 = kani::any();
    let price: u64 = kani::any();
    let token_decimals: u8 = kani::any();
    let price_exponent: i8 = kani::any();

    kani::assume!(amount > 0 && amount < 1_000_000_000_000);
    kani::assume!(price > 0 && price < 1_000_000_000);
    kani::assume!(token_decimals <= 9);
    kani::assume!(price_exponent >= -12 && price_exponent <= 0);

    let value = (amount as u128) * (price as u128);
    let total_decimals = token_decimals as i32 + price_exponent as i32;

    // Normalization to target (e.g., 6 decimal USD)
    let target_decimals = 6i32;
    let shift = total_decimals - target_decimals;

    if shift > 0 {
        let divisor = 10u128.pow(shift as u32);
        let normalized = value / divisor;
        kani::assert!(normalized <= value);
    } else {
        let multiplier = 10u128.pow((-shift) as u32);
        let normalized = value.checked_mul(multiplier);
        kani::assert!(normalized.is_some(), "normalization overflow");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn oracle_normalization_consistent(
        amount_sol in 1_000_000_000u64..10_000_000_000_000, // 1-10000 SOL
        price_usd in 10_000_000u64..500_000_000 // $10-$500 with 6 decimals
    ) {
        let value = normalize_value(amount_sol, 9, price_usd, -6, 6);
        // 1 SOL at $100 should be ~100_000_000 (100 * 10^6)
        prop_assert!(value > 0, "zero value for nonzero inputs");
    }
}
```

### LiteSVM Assertion
```rust
// 1 SOL (10^9 lamports) at $100 (Pyth price) should â‰ˆ $100
let value = compute_collateral_value(&ctx, sol_mint, 1_000_000_000).await;
assert!(value > 99_000_000 && value < 101_000_000, "value {} not ~$100", value);
```

## Suggested Fix
```rust
pub fn compute_value(amount: u64, token_decimals: u8, price: i64, price_expo: i32, target_decimals: u8) -> Result<u128> {
    let raw = (amount as u128) * (price.unsigned_abs() as u128);
    let net_expo = (token_decimals as i32) + price_expo - (target_decimals as i32);
    if net_expo >= 0 {
        Ok(raw / 10u128.pow(net_expo as u32))
    } else {
        raw.checked_mul(10u128.pow((-net_expo) as u32))
            .ok_or(OracleError::NormalizationOverflow)
    }
}
```
