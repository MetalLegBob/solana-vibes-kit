# VP-075: Fee-on-Fee Interaction

**Category:** Token-2022 Fees
**Verification tool:** Proptest

## What Can Go Wrong
When a token with transfer fees is swapped for another fee-bearing token, the fees compound rather than adding linearly. The first transfer deducts fee_A from the input, and the second deducts fee_B from the already-reduced output. The effective rate becomes `1 - (1 - rA)(1 - rB)` which always exceeds `rA + rB`. If the UI shows a simple sum, users pay more than displayed and MEV bots exploit the discrepancy via sandwich attacks.

## Why It Matters
Users swapping fee-bearing Token-2022 assets on a DEX see "total fees: 1%" but actually pay a compounded rate. MEV bots sandwich these swaps, profiting from the gap between expected and actual output. Over millions of swaps the displayed estimates diverge significantly from reality, eroding user trust and protocol credibility.

## Real-World Incident
No single named exploit, but fee-on-fee compounding is a recurring finding in Token-2022 DEX integration audits. Jupiter aggregator documentation explicitly warns about this interaction when routing through fee-bearing tokens.

## Invariant

### Formal Property
```
For amount A, fee rates bps_a and bps_b:
  compounded_fee = fee_a + fee_b_on_reduced <= fee_a_on_full + fee_b_on_full
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_fee_on_fee_bounded() {
    let amount: u64 = kani::any();
    let bps_a: u16 = kani::any();
    let bps_b: u16 = kani::any();
    kani::assume!(amount > 0 && amount < 1_000_000_000_000);
    kani::assume!(bps_a > 0 && bps_a <= 1_000);
    kani::assume!(bps_b > 0 && bps_b <= 1_000);

    let amt = amount as u128;
    let fee_a = (amt * bps_a as u128 + 9_999) / 10_000;
    let fee_b = ((amt - fee_a) * bps_b as u128 + 9_999) / 10_000;
    let indep_b = (amt * bps_b as u128 + 9_999) / 10_000;

    kani::assert!(fee_a + fee_b <= fee_a + indep_b);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn compounded_fee_bounded_by_sum(
        amount in 1u64..1_000_000_000,
        bps_a in 1u16..=1_000,
        bps_b in 1u16..=1_000
    ) {
        let amt = amount as u128;
        let fee_a = (amt * bps_a as u128 + 9_999) / 10_000;
        let after_a = amt - fee_a;
        let fee_b = (after_a * bps_b as u128 + 9_999) / 10_000;
        let indep_a = (amt * bps_a as u128 + 9_999) / 10_000;
        let indep_b = (amt * bps_b as u128 + 9_999) / 10_000;

        prop_assert!(fee_a + fee_b <= indep_a + indep_b,
            "compounded {} > independent {}", fee_a + fee_b, indep_a + indep_b);
        prop_assert!(amt - fee_a - fee_b > 0, "user receives nothing");
    }
}
```

### LiteSVM Assertion
```rust
let amount: u64 = 1_000_000;
process_transaction(&mut banks_client, swap_ix(amount), &payer).await.unwrap();
let fee_a = get_transfer_fee(&banks_client, mint_a, amount).await;
let after_a = amount - fee_a;
let fee_b = get_transfer_fee(&banks_client, mint_b, after_a).await;
let naive_b = get_transfer_fee(&banks_client, mint_b, amount).await;
assert!(fee_a + fee_b <= fee_a + naive_b, "compounded fee exceeds independent sum");
assert!(after_a - fee_b > 0, "user receives zero tokens");
```

## Suggested Fix
```rust
pub fn net_after_double_fee(amount: u64, bps_a: u16, bps_b: u16) -> Result<u64> {
    let fee_a = fee_ceil(amount, bps_a)?;
    let after_a = amount.checked_sub(fee_a).ok_or(TokenError::Underflow)?;
    let fee_b = fee_ceil(after_a, bps_b)?;
    after_a.checked_sub(fee_b).ok_or(TokenError::Underflow)
}

fn fee_ceil(amount: u64, bps: u16) -> Result<u64> {
    let num = (amount as u128).checked_mul(bps as u128).ok_or(TokenError::Overflow)?;
    Ok(((num + 9_999) / 10_000) as u64)
}
```
