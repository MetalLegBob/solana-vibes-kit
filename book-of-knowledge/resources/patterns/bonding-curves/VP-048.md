# VP-048: Integral Consistency Between Buy and Sell

**Category:** Bonding Curves
**Verification tool:** Kani

## What Can Go Wrong
The cost to buy N tokens should be the integral of the price curve from supply to supply+N. The proceeds from selling N tokens should be the integral from supply-N to supply. If buy and sell use different calculations, the round-trip creates a profit or loss beyond fees.

## Why It Matters
If buy_cost(N) > sell_proceeds(N) + fees by more than expected, users lose value on the round trip. If sell_proceeds(N) > buy_cost(N) - fees, users can profit from buy-then-sell cycles, draining the reserve.

## Real-World Incident
Several bonding curve implementations on Solana (pump.fun clones) had buy/sell integral mismatches that allowed profitable round-trip trading at the expense of the curve's reserve.

## Invariant

### Formal Property
```
buy_cost(N) >= sell_proceeds(N) + fees
sell_proceeds(N) = buy_cost(N) - fees (for matching integrals)
Round-trip: user ends with <= initial_balance - 2*fees
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_buy_sell_consistency() {
    let current_supply: u64 = kani::any();
    let amount: u64 = kani::any();
    let fee_bps: u16 = kani::any();

    kani::assume!(current_supply > 0 && current_supply < u64::MAX / 4);
    kani::assume!(amount > 0 && amount < current_supply);
    kani::assume!(fee_bps > 0 && fee_bps <= 1000);

    let buy_cost = curve_integral(current_supply, current_supply + amount);
    let sell_proceeds = curve_integral(current_supply, current_supply + amount); // same integral

    // Before fees, buy and sell integrals should be identical
    kani::assert!(buy_cost == sell_proceeds);

    // After fees: sell gives less
    let sell_after_fee = sell_proceeds * (10_000 - fee_bps as u128) / 10_000;
    kani::assert!(sell_after_fee < buy_cost);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn roundtrip_loses_fees(
        supply in 1_000u64..1_000_000_000,
        amount in 1u64..1_000_000,
        fee_bps in 1u16..300
    ) {
        let buy_cost = compute_buy_cost(supply, amount, fee_bps);
        let sell_proceeds = compute_sell_proceeds(supply + amount, amount, fee_bps);
        prop_assert!(sell_proceeds < buy_cost,
            "profitable round-trip: bought for {}, sold for {}", buy_cost, sell_proceeds);
    }
}
```

### LiteSVM Assertion
```rust
let balance_before = get_sol_balance(&ctx, &user).await;
buy_tokens(&mut ctx, &user, token_amount).await.unwrap();
sell_tokens(&mut ctx, &user, token_amount).await.unwrap();
let balance_after = get_sol_balance(&ctx, &user).await;
assert!(balance_after < balance_before, "profitable round-trip on bonding curve");
```

## Suggested Fix
```rust
/// Use same integral for both buy and sell, only differ by fee direction
pub fn curve_integral(from_supply: u64, to_supply: u64) -> u128 {
    // For linear curve: integral = base_price * (to - from) + slope * (to^2 - from^2) / 2
    let diff = (to_supply - from_supply) as u128;
    let sum = (to_supply + from_supply) as u128;
    BASE_PRICE as u128 * diff + SLOPE as u128 * diff * sum / (2 * PRECISION)
}
```
