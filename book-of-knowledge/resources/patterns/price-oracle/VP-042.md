# VP-042: Stale Price Detection Boundary

**Category:** Price Oracle
**Verification tool:** LiteSVM

## What Can Go Wrong
Oracle prices have a freshness window — prices older than a threshold are "stale" and shouldn't be used. If the staleness check uses `<=` instead of `<`, or if the threshold is too generous, the protocol may use outdated prices that don't reflect current market conditions.

## Why It Matters
Using a stale price during a market crash means the protocol values collateral at pre-crash prices. Borrowers aren't liquidated when they should be, and the protocol becomes undercollateralized. Conversely, using stale prices during a rally means users are liquidated unfairly.

## Real-World Incident
The Mango Markets exploit (October 2022, $116M lost) involved oracle price manipulation of the MNGO token. The attacker manipulated prices on illiquid secondary markets, and the oracle did not have adequate staleness or manipulation detection. Solend was also exploited in November 2022 for $1.26M in bad debt when an attacker manipulated oracle prices.

## Invariant

### Formal Property
```
For oracle price with timestamp T and staleness threshold S:
  current_time - T > S → price is STALE → reject
  current_time - T <= S → price is FRESH → accept
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_stale_price_rejected() {
    let price_time: u64 = kani::any();
    let current_time: u64 = kani::any();
    let staleness_threshold: u64 = kani::any();

    kani::assume!(current_time >= price_time);
    kani::assume!(staleness_threshold > 0 && staleness_threshold <= 3600);

    let age = current_time - price_time;
    let is_stale = age > staleness_threshold;

    if is_stale {
        // Must not use this price
        kani::assert!(age > staleness_threshold);
    } else {
        kani::assert!(age <= staleness_threshold);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn stale_prices_always_rejected(
        price_age in 0u64..7200,
        threshold in 30u64..3600
    ) {
        let is_fresh = price_age <= threshold;
        let result = validate_price_freshness(price_age, threshold);
        match result {
            Ok(_) => prop_assert!(is_fresh),
            Err(_) => prop_assert!(!is_fresh),
        }
    }
}
```

### LiteSVM Assertion
```rust
// Set oracle price, advance time past staleness threshold
set_oracle_price(&mut ctx, 100_000_000).await.unwrap();
advance_clock(&mut ctx, STALENESS_THRESHOLD + 1).await;
// Operation that needs fresh price should fail
let result = borrow(&mut ctx, &user, amount).await;
assert!(result.is_err(), "operation succeeded with stale oracle price");
```

## Suggested Fix
```rust
pub fn get_validated_price(oracle: &OracleAccount, clock: &Clock, max_age: u64) -> Result<u64> {
    let age = (clock.unix_timestamp as u64).checked_sub(oracle.last_update)?;
    require!(age <= max_age, OracleError::StalePrice);
    Ok(oracle.price)
}
```
