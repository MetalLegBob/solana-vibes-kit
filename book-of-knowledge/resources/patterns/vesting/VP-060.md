# VP-060: Timestamp Vesting Boundary

**Category:** Vesting
**Verification tool:** Proptest

## What Can Go Wrong
Off-by-one errors at vesting start and end timestamps cause incorrect unlock amounts. At `start_time` the unlocked amount should be zero (or the cliff amount if a cliff exists). At `end_time` the unlocked amount should equal the full grant exactly. Fencepost errors can leave dust permanently locked in the contract, or release one extra second of tokens at the boundary, effectively shifting the entire vesting curve by one unit.

## Why It Matters
An attacker claims at exact boundary timestamps to exploit the off-by-one. At `end_time` minus one second, the full grant may already be unlocked due to an inclusive comparison, allowing the attacker to front-run the final second. Alternatively, at `end_time` the last fractional token remains permanently locked, accumulating across many vesting schedules into significant unrecoverable value trapped in the contract.

## Real-World Incident
No specific public incident documented, but this failure mode is well-known in DeFi security literature. Off-by-one timestamp bugs are among the most common vesting vulnerabilities found in audits. They are particularly insidious because they pass casual testing but fail at exact boundaries.

## Invariant

### Formal Property
```
forall start, end, now, grant:
  now <= start  implies unlocked = 0
  now >= end    implies unlocked = grant
  unlock(t+1) >= unlock(t)   // monotonically non-decreasing
  start < end                 // valid schedule
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_timestamp_boundaries() {
    let start: u64 = kani::any();
    let end: u64 = kani::any();
    let now: u64 = kani::any();
    let grant: u64 = kani::any();

    kani::assume!(start < end && end - start > 0);
    kani::assume!(grant > 0 && grant <= 10_000_000_000);
    kani::assume!(now >= start && now <= end);

    let elapsed = now - start;
    let duration = end - start;
    let unlocked = (grant as u128 * elapsed as u128 / duration as u128) as u64;

    kani::assert!(now > start || unlocked == 0, "non-zero unlock at start");
    kani::assert!(now < end || unlocked == grant, "incomplete unlock at end");
    kani::assert!(unlocked <= grant, "unlocked exceeds grant");

    // Verify monotonicity with next second
    if now < end {
        let next_elapsed = elapsed + 1;
        let next_unlocked = (grant as u128 * next_elapsed as u128 / duration as u128) as u64;
        kani::assert!(next_unlocked >= unlocked, "non-monotonic unlock");
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn boundary_correctness(
        start in 1_000_000u64..1_500_000_000,
        duration in 1u64..315_360_000,     // up to 10 years
        grant in 1u64..10_000_000_000u64
    ) {
        let end = start.checked_add(duration).unwrap();

        // At start: zero unlocked
        let at_start = linear_unlock(grant, start, start, end);
        prop_assert_eq!(at_start, 0, "start boundary: unlocked {} != 0", at_start);

        // At end: full grant unlocked
        let at_end = linear_unlock(grant, end, start, end);
        prop_assert_eq!(at_end, grant, "end boundary: unlocked {} != grant {}", at_end, grant);

        // One second before end: strictly less than grant
        if duration > 1 {
            let before_end = linear_unlock(grant, end - 1, start, end);
            prop_assert!(before_end < grant, "before end: {} should be < {}", before_end, grant);
        }

        // Monotonicity across 10 sample points
        let mut prev = 0u64;
        for step in 0..=10 {
            let now = start + (duration * step / 10);
            let unlocked = linear_unlock(grant, now, start, end);
            prop_assert!(unlocked >= prev, "non-monotonic at step {}: {} < {}", step, unlocked, prev);
            prev = unlocked;
        }
    }
}
```

### LiteSVM Assertion
```rust
let schedule = create_vesting_schedule(&mut ctx, admin, beneficiary, grant, start_ts, duration);
let end_ts = start_ts + duration;

// Boundary: at start, nothing claimable
ctx.warp_to_timestamp(start_ts);
let at_start = get_claimable_amount(&ctx, schedule);
assert_eq!(at_start, 0, "non-zero claimable at start: {}", at_start);

// Boundary: one second before end, less than full grant
ctx.warp_to_timestamp(end_ts - 1);
let before_end = get_claimable_amount(&ctx, schedule);
assert!(before_end < grant, "full grant unlocked before end: {}", before_end);

// Boundary: exactly at end, full grant
ctx.warp_to_timestamp(end_ts);
let at_end = get_claimable_amount(&ctx, schedule);
assert_eq!(at_end, grant, "end boundary: {} != grant {}", at_end, grant);

// Boundary: well past end, still exactly full grant (no extra tokens)
ctx.warp_to_timestamp(end_ts + 1_000_000);
let past_end = get_claimable_amount(&ctx, schedule);
assert_eq!(past_end, grant, "past end: {} != grant {}", past_end, grant);
```

## Suggested Fix
```rust
pub fn linear_unlock(grant: u64, now: u64, start: u64, end: u64) -> u64 {
    if now <= start {
        return 0;
    }
    if now >= end {
        return grant;
    }
    let elapsed = now - start;     // safe: now > start
    let duration = end - start;    // safe: end > start (checked at creation)
    // u128 intermediate prevents overflow for large grants
    let unlocked = (grant as u128)
        .checked_mul(elapsed as u128)
        .expect("u128 overflow impossible for u64 inputs")
        / (duration as u128);
    unlocked as u64
}
```
