# VP-013: Zero-Fee at Zero Input

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
If the fee function doesn't handle zero input correctly, it might return a non-zero fee for a zero-amount operation. This creates "phantom fees" â€” the user sends nothing but is charged. With ceiling division, fee_ceil(0, rate) could return 1 instead of 0.

## Why It Matters
Phantom fees on zero-amount operations can be exploited to drain user token accounts. If a protocol allows zero-input swaps and charges fees, an attacker can repeatedly call swap(0) to drain fees from users who approved token spending.

## Real-World Incident
No specific public incident documented, but this is a standard edge case tested in all DeFi audit frameworks. The ERC-4626 specification explicitly addresses zero-amount deposit/withdrawal behavior.

## Invariant

### Formal Property
```
fee(0, any_rate) = 0
fee(any_amount, 0) = 0
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_zero_input_zero_fee() {
    let fee_bps: u16 = kani::any();
    kani::assume!(fee_bps <= 10_000);

    let fee = calculate_fee(0, fee_bps);
    kani::assert!(fee == 0, "phantom fee on zero input");
}

#[kani::proof]
fn verify_zero_rate_zero_fee() {
    let amount: u64 = kani::any();
    let fee = calculate_fee(amount, 0);
    kani::assert!(fee == 0, "phantom fee on zero rate");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn no_phantom_fees(fee_bps in 0u16..=10_000) {
        prop_assert_eq!(calculate_fee(0, fee_bps), 0);
    }

    #[test]
    fn zero_rate_no_fees(amount in 0u64..u64::MAX) {
        prop_assert_eq!(calculate_fee(amount, 0), 0);
    }
}
```

### LiteSVM Assertion
```rust
let balance_before = get_token_balance(&ctx, user_token).await;
execute_swap(&mut ctx, 0, 0).await.unwrap();
let balance_after = get_token_balance(&ctx, user_token).await;
assert_eq!(balance_before, balance_after, "zero-amount swap changed balance");
```

## Suggested Fix
```rust
pub fn calculate_fee(amount: u64, fee_bps: u16) -> u64 {
    if amount == 0 || fee_bps == 0 {
        return 0;
    }
    // Ceiling division for non-zero amounts
    let num = (amount as u128) * (fee_bps as u128);
    ((num + 9_999) / 10_000) as u64
}
```
