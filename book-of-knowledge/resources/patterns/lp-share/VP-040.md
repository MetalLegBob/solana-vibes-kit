# VP-040: Total Shares Never Exceed Maximum Supply

**Category:** LP Share
**Verification tool:** Kani

## What Can Go Wrong
If there's no cap on total LP shares and the share calculation doesn't guard against overflow, total_shares can wrap around u64::MAX. After wrapping, share accounting breaks completely â€” existing shares represent a massive percentage of the (wrapped) total.

## Why It Matters
A wrapped total_shares means every share calculation is wrong. New deposits get incorrect shares, withdrawals receive incorrect amounts, and the pool is effectively bricked.

## Real-World Incident
No specific public incident documented, but u64 overflow in share tracking has been flagged in multiple Solana audit reports.

## Invariant

### Formal Property
```
total_shares + new_shares_minted <= u64::MAX
total_shares.checked_add(minted).is_some()
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_shares_no_overflow() {
    let total_shares: u64 = kani::any();
    let new_shares: u64 = kani::any();

    let result = total_shares.checked_add(new_shares);

    if result.is_none() {
        // This must be caught and rejected
        kani::assert!(total_shares as u128 + new_shares as u128 > u64::MAX as u128);
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn share_minting_checked(
        total in 0u64..u64::MAX,
        deposit in 1u64..1_000_000_000
    ) {
        let result = mint_shares_safe(total, deposit);
        match result {
            Ok(new_total) => prop_assert!(new_total >= total),
            Err(_) => {} // overflow correctly caught
        }
    }
}
```

### LiteSVM Assertion
```rust
// Try to mint shares that would overflow u64
// This test verifies the program handles near-max gracefully
let pool = get_pool_state(&ctx).await;
if pool.total_shares > u64::MAX - 1000 {
    let result = deposit(&mut ctx, &user, 1_000_000).await;
    assert!(result.is_err(), "should reject deposit that overflows shares");
}
```

## Suggested Fix
```rust
pub fn mint_lp_shares(pool: &mut Pool, shares: u64) -> Result<()> {
    pool.total_shares = pool.total_shares
        .checked_add(shares)
        .ok_or(PoolError::ShareOverflow)?;
    Ok(())
}
```
