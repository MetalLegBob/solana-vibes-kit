# VP-056: Cascading Liquidation Prevention

**Category:** Liquidation
**Verification tool:** LiteSVM

## What Can Go Wrong
When a large position is liquidated, the liquidator sells seized collateral on the open market, depressing the collateral token price. This pushes other borrowers below their liquidation threshold, triggering additional liquidations, more selling, and further price decline. Without circuit breakers or per-slot limits, a single large liquidation can cascade through the entire protocol, liquidating dozens of positions in rapid succession and creating a death spiral.

## Why It Matters
An attacker deliberately triggers a cascade by creating a large barely-healthy position and manipulating the oracle price just enough to trigger its liquidation. The cascade amplifies a small price movement into a protocol-wide liquidation event. The attacker profits from each liquidation bonus while innocent users lose collateral at distressed prices far below fair market value.

## Real-World Incident
March 2020 Black Thursday on MakerDAO: ETH price crash triggered cascading liquidations. Liquidators won auctions for $0 due to network congestion, resulting in $5.32M in protocol bad debt. The cascade was worsened by lack of per-block liquidation caps.

## Invariant

### Formal Property
```
forall liquidation_event:
  let newly_liquidatable = count_below_threshold(after) - count_below_threshold(before)
  newly_liquidatable <= MAX_CASCADE_DEPTH OR
  total_collateral_seized_this_slot <= CIRCUIT_BREAKER_LIMIT
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_cascade_prevention() {
    let num_positions: u32 = kani::any();
    let collateral_seized: u64 = kani::any();
    let original_price: u64 = kani::any();
    let price_impact_bps: u64 = kani::any();
    let circuit_breaker_limit: u64 = kani::any();

    kani::assume!(num_positions > 0 && num_positions <= 100);
    kani::assume!(collateral_seized > 0 && collateral_seized <= 1_000_000_000);
    kani::assume!(original_price > 0 && original_price <= 1_000_000);
    kani::assume!(price_impact_bps > 0 && price_impact_bps <= 3000);
    kani::assume!(circuit_breaker_limit > 0);

    let new_price = original_price * (10_000 - price_impact_bps) / 10_000;
    let price_drop_pct = ((original_price - new_price) as u128 * 100) / original_price as u128;

    // With circuit breaker: seized collateral per slot is bounded
    let capped_seized = if collateral_seized > circuit_breaker_limit {
        circuit_breaker_limit
    } else {
        collateral_seized
    };
    let capped_impact = (capped_seized as u128 * price_impact_bps as u128) / 10_000;

    kani::assert!(capped_seized <= circuit_breaker_limit, "circuit breaker exceeded");
    kani::assert!(capped_impact <= collateral_seized as u128, "impact exceeds seized amount");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn no_cascade_beyond_limit(
        health_ratios in prop::collection::vec(100u64..200, 10..50),
        liquidation_pct in 1u64..50,
        price_impact_bps in 1u64..2000,
        circuit_breaker_max in 1u32..5
    ) {
        let threshold = 110u64; // 110% health ratio = liquidation threshold
        let mut cascade_count = 0u32;
        let mut current_ratios = health_ratios.clone();

        // Simulate liquidation rounds with price impact
        for _round in 0..10 {
            let liquidatable: Vec<usize> = current_ratios.iter().enumerate()
                .filter(|(_, &r)| r < threshold)
                .map(|(i, _)| i)
                .collect();
            if liquidatable.is_empty() { break; }

            cascade_count += 1;
            if cascade_count >= circuit_breaker_max { break; } // circuit breaker fires

            // Apply price impact from this round's liquidations
            for ratio in current_ratios.iter_mut() {
                let impact = (*ratio as u128 * price_impact_bps as u128 / 10_000) as u64;
                *ratio = ratio.saturating_sub(impact);
            }
        }

        prop_assert!(
            cascade_count <= circuit_breaker_max,
            "cascade {} exceeded breaker limit {}", cascade_count, circuit_breaker_max
        );
    }
}
```

### LiteSVM Assertion
```rust
let positions_before = get_all_positions(&ctx, lending_pool);
let healthy_before = positions_before.iter()
    .filter(|p| p.health_ratio >= LIQUIDATION_THRESHOLD)
    .count();

// Execute first liquidation
execute_liquidation(&mut ctx, liquidator, positions_before[0].key, max_repay);
let slot_stats = get_slot_liquidation_stats(&ctx, lending_pool);

// Verify circuit breaker is enforced
assert!(
    slot_stats.total_collateral_seized <= CIRCUIT_BREAKER_LIMIT,
    "Slot seized {} exceeds circuit breaker {}", slot_stats.total_collateral_seized, CIRCUIT_BREAKER_LIMIT
);
assert!(
    slot_stats.liquidation_count <= MAX_CASCADE_DEPTH,
    "Cascade depth {} exceeds max {}", slot_stats.liquidation_count, MAX_CASCADE_DEPTH
);
```

## Suggested Fix
```rust
pub fn liquidate(
    ctx: Context<Liquidate>,
    max_repay: u64,
) -> Result<()> {
    let pool = &mut ctx.accounts.lending_pool;
    let slot = Clock::get()?.slot;

    // Reset per-slot counters on new slot
    if pool.last_liquidation_slot != slot {
        pool.last_liquidation_slot = slot;
        pool.slot_seized_total = 0;
        pool.slot_liquidation_count = 0;
    }

    // Circuit breaker: cap liquidations per slot
    require!(
        pool.slot_liquidation_count < MAX_CASCADE_DEPTH,
        LendingError::CascadeCircuitBreaker
    );
    let remaining_capacity = CIRCUIT_BREAKER_LIMIT
        .checked_sub(pool.slot_seized_total)
        .ok_or(LendingError::CascadeCircuitBreaker)?;
    let effective_repay = max_repay.min(remaining_capacity);
    require!(effective_repay > 0, LendingError::CascadeCircuitBreaker);

    let collateral_seized = calculate_seizure(effective_repay, pool)?;
    pool.slot_seized_total = pool.slot_seized_total
        .checked_add(collateral_seized)
        .ok_or(LendingError::Overflow)?;
    pool.slot_liquidation_count += 1;

    transfer_collateral(ctx.accounts, collateral_seized)?;
    Ok(())
}
```
