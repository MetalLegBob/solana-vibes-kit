# VP-025: Dust Reward Accumulation

**Category:** Staking Rewards
**Verification tool:** Proptest

## What Can Go Wrong
When a staker's share of rewards per update is less than 1 token unit, the truncated reward is effectively lost. Over many updates, these "dust" rewards accumulate into a significant shortfall. The staker earns nothing while the rewards are silently consumed.

## Why It Matters
Small stakers are disproportionately affected — their per-update reward might always round to 0. This creates a de facto minimum stake requirement that isn't documented. Over time, dust from all small stakers accumulates as orphaned tokens in the reward pool.

## Real-World Incident
Marinade Finance and other Solana staking protocols addressed dust accumulation by using high-precision accumulators (10^12 multiplier). Early versions of several farms had dust issues affecting small stakers.

## Invariant

### Formal Property
```
∀ staker with amount > 0 and reward_rate > 0:
  After sufficient time T, user.pending_reward > 0
  Dust per update < 1 lamport but must accumulate over time via high-precision accumulator
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_dust_eventually_materializes() {
    let small_stake: u64 = kani::any();
    let rate: u64 = kani::any();
    let total_staked: u64 = kani::any();

    kani::assume!(small_stake >= 1 && small_stake <= 1000);
    kani::assume!(rate > 0 && rate <= 1_000_000);
    kani::assume!(total_staked > small_stake && total_staked < 1_000_000_000);

    // With precision multiplier, even tiny shares accumulate
    let rpt_increment = (rate as u128) * PRECISION / (total_staked as u128);
    let user_reward = rpt_increment * (small_stake as u128) / PRECISION;

    // May be 0 for single update, but rpt_increment > 0 always
    kani::assert!(rpt_increment > 0, "accumulator not advancing");
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn dust_accumulates_over_time(
        small_stake in 1u64..100,
        rate in 1u64..1_000_000,
        total_staked in 1_000_000u64..1_000_000_000,
        updates in 100u32..10_000
    ) {
        let mut rpt: u128 = 0;
        for _ in 0..updates {
            rpt += (rate as u128) * PRECISION / (total_staked as u128);
        }
        let reward = rpt * (small_stake as u128) / PRECISION;
        prop_assert!(reward > 0, "stake of {} earned 0 after {} updates", small_stake, updates);
    }
}
```

### LiteSVM Assertion
```rust
// Stake 1 lamport
stake(&mut ctx, &small_user, 1).await.unwrap();
// Advance many epochs
for _ in 0..1000 {
    advance_clock(&mut ctx, 60).await;
    update_pool(&mut ctx).await.unwrap();
}
let pending = get_pending(&ctx, &small_user).await;
assert!(pending > 0, "1-lamport staker earned 0 after 1000 updates");
```

## Suggested Fix
```rust
const PRECISION: u128 = 1_000_000_000_000; // 10^12 — enough for dust accumulation

pub fn pending_reward(user: &UserStake, pool: &Pool) -> u64 {
    let raw = pool.reward_per_token_stored
        .checked_mul(user.staked_amount as u128).unwrap()
        / PRECISION;
    raw.saturating_sub(user.reward_debt) as u64
}
```
