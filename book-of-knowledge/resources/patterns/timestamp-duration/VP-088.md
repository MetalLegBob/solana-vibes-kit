# VP-088: Epoch Boundary Calculation Off-by-One

**Category:** Timestamp/Duration
**Verification tool:** Kani

## What Can Go Wrong
Epoch transitions (for staking, reward distribution, or governance) can skip or double-count the boundary slot. If epoch N ends at slot 100 and epoch N+1 starts at slot 101, a slot-100 transaction might be counted in both epochs (or neither) depending on `<` vs `<=` in the boundary check.

## Why It Matters
Double-counting at epoch boundaries means rewards are paid twice for that slot. Skipping means a slot's rewards are lost. For governance voting, an off-by-one could exclude votes cast at the boundary.

## Real-World Incident
No specific public incident documented. Solana's native epoch boundaries are handled by the runtime, but program-level epoch logic (custom reward periods) frequently has boundary bugs.

## Invariant

### Formal Property
```
epoch(slot) = slot / epoch_length
boundary: epoch(N * epoch_length - 1) = N - 1, epoch(N * epoch_length) = N
No slot belongs to two epochs, no slot belongs to zero epochs
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_epoch_boundary() {
    let slot: u64 = kani::any();
    let epoch_length: u64 = kani::any();

    kani::assume!(epoch_length > 0 && epoch_length < 1_000_000);
    kani::assume!(slot < u64::MAX / 2);

    let epoch = slot / epoch_length;
    let next_epoch_start = (epoch + 1) * epoch_length;
    let this_epoch_start = epoch * epoch_length;

    kani::assert!(slot >= this_epoch_start);
    kani::assert!(slot < next_epoch_start);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn epochs_partition_slots(slot in 0u64..100_000_000, epoch_len in 1u64..100_000) {
        let epoch = slot / epoch_len;
        let start = epoch * epoch_len;
        let end = (epoch + 1) * epoch_len;
        prop_assert!(slot >= start && slot < end,
            "slot {} not in epoch {} [{}, {})", slot, epoch, start, end);
    }
}
```

### LiteSVM Assertion
```rust
let epoch_len = 1000u64;
// Last slot of epoch 0
assert_eq!(compute_epoch(999, epoch_len), 0);
// First slot of epoch 1
assert_eq!(compute_epoch(1000, epoch_len), 1);
```

## Suggested Fix
```rust
pub fn compute_epoch(slot: u64, epoch_length: u64) -> u64 {
    slot / epoch_length // integer division naturally gives floor
}

pub fn epoch_start(epoch: u64, epoch_length: u64) -> u64 {
    epoch * epoch_length // inclusive
}

pub fn epoch_end(epoch: u64, epoch_length: u64) -> u64 {
    (epoch + 1) * epoch_length - 1 // inclusive
}
```
