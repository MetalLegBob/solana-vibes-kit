# SOS Audit Stacking — Design Document

**Date:** 2026-02-18
**Status:** Approved
**Scope:** Stronghold of Security — multi-audit lifecycle support

---

## Problem

SOS currently treats every audit as a one-shot event. Running `/SOS:scan` a second time overwrites the previous `.audit/` directory. There is no concept of audit history, no way to learn from previous audits, and no mechanism to track how a codebase's security posture evolves over time.

Users who are actively developing their project need to audit repeatedly — after major features, before deployments, after fixing findings. Each subsequent audit should be smarter than the last, not a blank slate.

## Design Principle

**Previous audits inform prioritization, never skip analysis.**

The handover from a previous audit provides context that makes the next audit more targeted and efficient, but every phase still examines all code. Inherited conclusions are treated as signals, not truths. Nothing is skipped — analysis depth is adjusted based on what changed.

---

## 1. Archive Structure & Auto-Detection

### Behavior

When `/SOS:scan` runs, the first thing it does (before any codebase analysis) is check for a previous completed audit in `.audit/`.

If a completed audit is detected:
1. Read `STATE.json` to get the git ref and audit metadata
2. Move the entire `.audit/` to `.audit-history/<YYYY-MM-DD>-<short-hash>/`
3. Create a fresh `.audit/` for the new audit
4. Run `git diff <previous-ref>..HEAD` to compute the change delta
5. Generate `HANDOVER.md` in the new `.audit/`

If no previous audit exists, scan runs exactly as it does today. Zero behavior change for first-time users.

### Directory Structure

```
.audit/                              ← always the current audit
.audit-history/
  2026-02-10-a1b2c3d/              ← archived audit #1
    STATE.json
    FINAL_REPORT.md
    ARCHITECTURE.md
    STRATEGIES.md
    COVERAGE.md
    context/
    findings/
  2026-02-15-e4f5g6h/              ← archived audit #2
    ...
```

### State Linkage

`STATE.json` gains a new field:

```json
{
  "previous_audit": {
    "path": ".audit-history/2026-02-10-a1b2c3d",
    "audit_id": "uuid",
    "git_ref": "a1b2c3d4e5f6",
    "date": "2026-02-10",
    "summary": {
      "confirmed": 3,
      "potential": 7,
      "files_scanned": 128
    }
  }
}
```

This creates a linked chain — audit #3 can trace back through #2 and #1 by following each `previous_audit` reference.

---

## 2. The Handover Document

`HANDOVER.md` is the single artifact that bridges audits. Generated by scan, consumed by downstream phases. Each phase loads only the sections it needs (sections are delimited with markers for selective extraction).

### Contents

**Delta Summary**

Categorizes every file by change status since the previous audit:
- `NEW` — did not exist in the previous audit
- `MODIFIED` — changed since last audit (includes rough magnitude: minor tweak vs major rewrite)
- `UNCHANGED` — identical to previous audit
- `DELETED` — removed since last audit

**Previous Findings Digest**

Every CONFIRMED and POTENTIAL finding from the archived FINAL_REPORT.md, tagged with current relevance:
- Finding in a `MODIFIED` file → tag: `RECHECK` (fix may have landed, or change may have made it worse)
- Finding in an `UNCHANGED` file → tag: `VERIFY` (lighter pass — confirm it still holds)
- Finding in a `DELETED` file → tag: `RESOLVED_BY_REMOVAL`

**Previous False Positive Log**

Hypotheses from the previous STRATEGIES.md that were investigated and classified NOT_VULNERABLE:
- Grouped by file
- Entries targeting `UNCHANGED` files are retained (so downstream phases can deprioritize re-investigating identical dead ends)
- Entries targeting `MODIFIED` files are dropped (the dismissal no longer applies)
- Compressed format: hypothesis ID, one-line description, target file, dismissal reason (~1-2K tokens even for large audits)

**Architecture Snapshot**

Condensed version of the previous ARCHITECTURE.md — key trust boundaries, invariants, and data flow assertions. Not a full copy. Phase 2 will verify these still hold against the current codebase.

**Audit Lineage**

One line per previous audit: audit number, date, commit ref, high-level stats (X confirmed, Y potential, Z files scanned). Used by the final report to show the full history chain.

---

## 3. Phase-by-Phase Behavior Changes

### Phase 0.25 — Indexing (Haiku)

INDEX.md gains a new column per file: `delta_status` — one of `NEW`, `MODIFIED`, `UNCHANGED`, `DELETED`. Derived from the handover's delta summary. Trivial token cost (~200-500 tokens).

### Phase 0.5 — Static Pre-Scan

**No change.** Grep patterns run against all files regardless. Hot spots are hot spots.

### Phase 1 — Parallel Context Auditors (existing model assignments)

Each auditor receives the handover sections relevant to their focus area:
- **`MODIFIED` and `NEW` files:** Full deep analysis, same as today
- **`UNCHANGED` files:** Handled by separate verification agents (see below)
- **`RECHECK` findings** in their focus area are explicitly surfaced as high-priority investigation targets

**New: Verification Agents (Sonnet)**

Separate from the primary auditors. One per focus area, running in parallel. Each receives:
- The previous audit's condensed summary for their focus area
- The delta summary showing what changed elsewhere
- Task: "Verify these conclusions still hold given changes to other parts of the codebase"

This keeps verification work out of the primary auditor's context window entirely.

### Phase 1.5 — Quality Gate (Haiku)

**No change.** Validates all context files (including verification outputs) as before.

### Phase 2 — Context Synthesis (main context)

Reads condensed summaries from both primary auditors and verification agents. Uses the architecture snapshot from the handover as a starting reference, but verifies against current analysis. Produces ARCHITECTURE.md as before.

### Phase 3 — Strategy Generation (Opus)

Loads the compressed false positive log and previous findings digest. Behavioral rules:
- **Do not** regenerate hypotheses that were investigated and dismissed on `UNCHANGED` code — these are confirmed dead ends
- **Do** regenerate hypotheses on `MODIFIED` code even if previously dismissed — the code changed, the dismissal is void
- Previous CONFIRMED findings on `MODIFIED` code become **automatic Tier 1 hypotheses** ("did the fix actually work?")
- The 20%+ novel hypothesis requirement still applies to newly generated strategies
- Net effect: significant token savings by avoiding known dead ends, while maintaining thoroughness on changed code

### Phase 4 — Investigation (existing model assignments)

Investigators handling `RECHECK` hypotheses receive the previous finding file as additional context: "here's what was found last time at this location, here's what changed, determine if this is fixed/worse/different." ~200-500 extra tokens per investigator.

### Phase 4.5 — Coverage Verification (Sonnet)

**No change.** Runs its standard 3-dimension check regardless.

### Phase 5 — Final Synthesis (Opus)

Gains new output sections:
- **Audit Lineage** — Full chain of previous audits with summary stats
- **Finding Evolution** — For each finding, notes whether it is:
  - `NEW` — first seen in this audit
  - `RECURRENT` — seen in previous audit(s) and still present
  - `REGRESSION` — was previously fixed, now broken again
  - `RESOLVED` — was in previous audit, no longer present
- Recurrent findings (surviving 2+ audits) are flagged prominently
- Regressions are escalated in severity

---

## 4. Context Budget

The handover must not blow up context windows. Token overhead per phase:

| Phase | Handover content loaded | Estimated extra tokens |
|-------|------------------------|----------------------|
| Phase 0.25 (Indexing, Haiku) | Delta file list only | ~200-500 |
| Phase 1 (Primary Auditors) | RECHECK findings for their focus area | ~500-1K per auditor |
| Phase 1 (Verification Agents, Sonnet) | Previous condensed summary + delta | ~1-2K per agent |
| Phase 3 (Strategist, Opus) | False positive log + findings digest + architecture snapshot | ~3-5K |
| Phase 4 (Investigators) | Previous finding file (only for RECHECK hypotheses) | ~200-500 per investigator |
| Phase 5 (Synthesizer, Opus) | Audit lineage + evolution data | ~1-2K |

**Target:** A stacked audit should cost roughly 10-15% more tokens than a fresh audit for the handover processing and verification agents.

**Key mitigations:**
- Handover is sectioned with markers — phases extract only relevant sections, never load the full document
- False positive log is pre-compressed during scan (grouped, filtered, one-line summaries)
- Verification agents are separate from primary auditors — no context window bloat on the deep analysis path
- Phase 3 drops false positives targeting modified files before loading (reduces log size)

---

## 5. User Experience

### What the user sees

**`/SOS:scan` output** — After normal pre-flight info, a new block:

```
Previous Audit Detected
  Audit #1 — 2026-02-10 @ commit a1b2c3d
  Found: 3 confirmed, 7 potential, 128 files scanned
  Since then: 12 files modified, 4 new files, 2 deleted
  Handover generated → .audit/HANDOVER.md
```

No action required. The user continues running the pipeline as normal.

**`/SOS:status`** — Gains an audit lineage section showing the chain of previous audits with summary stats.

**`/SOS:report` final output** — Finding Evolution section shows how findings have changed across audits.

### Edge Cases

**Massive rewrite (>70% files changed):** Handover detects this and flags it. Verification agents are skipped entirely — nothing meaningful to verify when the architecture has shifted. The audit runs essentially fresh but carries forward the findings digest for evolution tracking in the report.

**User wants a clean audit with no history:** Delete `.audit-history/`. Simple, no special flag needed day one.

**Multiple rapid audits (no code changes):** Delta is empty. Every file is UNCHANGED. Verification agents run, confirm everything, report says "no changes since previous audit — all findings carry forward." Fast, cheap, honest.

**Verify vs re-audit distinction:** `/SOS:verify` remains the lightweight post-fix check within the current audit cycle. It does not trigger archiving or handover generation. A full re-audit via `/SOS:scan` is the heavier "audit the whole codebase again with previous context." These are complementary, not competing.

---

## 6. Model Assignments (Complete)

| Role | Model | Rationale |
|------|-------|-----------|
| Handover generation (during scan) | Main context | Reading files + git diff, no subagent needed |
| Indexing with delta tags | Haiku | Mechanical — adding a column to INDEX.md |
| Primary context auditors | Existing assignment | No change — full deep analysis on changed/new code |
| Verification agents (unchanged code) | Sonnet | Comparing previous conclusions against current delta context; benefits from Sonnet 4.6's larger context window |
| Quality gate | Haiku | No change |
| Strategy generation | Opus | No change — creative + synthesis work |
| Investigators | Existing assignment | No change; RECHECK investigators get slightly more context |
| Coverage verification | Sonnet | No change |
| Final synthesis | Opus | No change — gains evolution tracking output |

---

## 7. Implementation Scope

### What changes in existing files

- **scan.md** — Add archive detection, handover generation, delta computation
- **Phase 0.25 (indexing)** — Add `delta_status` column to INDEX.md template
- **analyze.md** — Add verification agent spawning for unchanged code alongside primary auditors
- **strategize.md** — Add false positive log loading and hypothesis deduplication rules
- **investigate.md** — Add previous finding context loading for RECHECK hypotheses
- **report.md** — Add audit lineage and finding evolution sections
- **status.md** — Add lineage display
- **STATE.json schema** — Add `previous_audit` field
- **Templates** — Update FINAL_REPORT template with evolution section

### New files

- **HANDOVER.md template** — Structured template with section markers for selective extraction
- **Verification agent template** — Agent prompt for unchanged code verification (Sonnet)

### What does NOT change

- verify.md — remains a post-fix tool within the current audit cycle
- Knowledge base — no changes
- Agent templates for primary auditors, investigators, synthesizer — they receive handover context through their existing input mechanisms, not through prompt changes
