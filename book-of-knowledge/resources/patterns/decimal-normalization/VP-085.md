# VP-085: Truncation vs Rounding Consistency

**Category:** Decimal Normalization
**Verification tool:** Proptest

## What Can Go Wrong
Different code paths may use truncation (floor) for some operations and rounding (ceil or nearest) for others. This inconsistency means the same logical operation produces different results depending on which code path executes, creating exploitable discrepancies.

## Why It Matters
If deposits use ceiling (user gets fewer shares) but withdrawals also use ceiling (user gets more tokens), the protocol leaks value on every withdrawal. Consistency in rounding direction is critical for solvency.

## Real-World Incident
ERC-4626 vault specification explicitly mandates rounding direction per operation type. Multiple vault implementations on Solana had inconsistent rounding found during audit.

## Invariant

### Formal Property
```
Deposits: round AGAINST depositor (protocol keeps dust)
Withdrawals: round AGAINST withdrawer (protocol keeps dust)
Fees: round IN FAVOR of protocol
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_rounding_consistency() {
    let amount: u64 = kani::any();
    let divisor: u64 = kani::any();

    kani::assume!(amount > 0 && divisor > 0);

    let floor = amount as u128 / divisor as u128;
    let ceil = (amount as u128 + divisor as u128 - 1) / divisor as u128;

    kani::assert!(ceil >= floor);
    kani::assert!(ceil - floor <= 1);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn consistent_rounding_across_operations(
        amount in 1u64..1_000_000_000,
        scale in 2u64..1000
    ) {
        let deposit_shares = shares_for_deposit(amount, scale); // should floor
        let withdraw_amount = amount_for_shares(deposit_shares, scale); // should floor
        // Round-trip: user should get back <= original
        prop_assert!(withdraw_amount <= amount,
            "user profited from deposit+withdraw: {} -> {}", amount, withdraw_amount);
    }
}
```

### LiteSVM Assertion
```rust
let balance_before = get_balance(&ctx, &user).await;
deposit(&mut ctx, &user, amount).await.unwrap();
let shares = get_shares(&ctx, &user).await;
withdraw_all(&mut ctx, &user).await.unwrap();
let balance_after = get_balance(&ctx, &user).await;
assert!(balance_after <= balance_before, "user profited from round-trip");
```

## Suggested Fix
```rust
/// Floor: favors protocol on payouts
pub fn div_floor(a: u128, b: u128) -> u128 { a / b }

/// Ceil: favors protocol on collections
pub fn div_ceil(a: u128, b: u128) -> u128 { (a + b - 1) / b }

// Deposits: shares = floor(amount * total_shares / total_value) → fewer shares
// Withdrawals: amount = floor(shares * total_value / total_shares) → less received
// Fees: fee = ceil(amount * rate / 10_000) → more fee collected
```
