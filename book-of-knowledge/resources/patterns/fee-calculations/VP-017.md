# VP-017: Fee-on-Fee Compounding Error

**Category:** Fee Calculations
**Verification tool:** Kani

## What Can Go Wrong
When multiple fees apply to the same transaction (e.g., protocol fee + LP fee, or referral fee + base fee), applying them sequentially (fee on already-reduced amount) vs. independently (both fees on original amount) produces different results. Incorrect ordering or double-application can overcharge or undercharge.

## Why It Matters
If fee A is 1% and fee B is 1%, sequential application gives 1.99% total (not 2%). If both are applied to the original amount, the total is 2%. The difference matters at scale and must match the protocol's intended fee structure.

## Real-World Incident
No specific public incident documented, but nested fee application bugs are frequently found in DeFi audits. Saber (Solana stable swap) addressed this by explicitly documenting their fee application order.

## Invariant

### Formal Property
```
For fees applied sequentially:
  net_amount = amount * (1 - fee_a/10000) * (1 - fee_b/10000)
  total_fee = amount - net_amount
  total_fee < fee_a_alone + fee_b_alone (no double-counting)
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_compound_fee_correct() {
    let amount: u64 = kani::any();
    let fee_a_bps: u16 = kani::any();
    let fee_b_bps: u16 = kani::any();

    kani::assume!(amount > 10_000 && amount < u64::MAX / 10_000);
    kani::assume!(fee_a_bps > 0 && fee_a_bps <= 1000);
    kani::assume!(fee_b_bps > 0 && fee_b_bps <= 1000);

    // Sequential: fee_b applied to post-fee_a amount
    let after_a = (amount as u128) * (10_000 - fee_a_bps as u128) / 10_000;
    let after_b = after_a * (10_000 - fee_b_bps as u128) / 10_000;
    let total_fee = (amount as u128) - after_b;

    // Total fee must be less than sum of independent fees
    let independent_sum = (amount as u128) * (fee_a_bps as u128 + fee_b_bps as u128) / 10_000;
    kani::assert!(total_fee <= independent_sum);
    kani::assert!(total_fee > 0);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn compound_fees_bounded(
        amount in 10_000u64..1_000_000_000,
        fee_a in 1u16..500,
        fee_b in 1u16..500
    ) {
        let result = apply_compound_fees(amount, fee_a, fee_b);
        prop_assert!(result < amount, "no fee deducted");
        prop_assert!(result > 0, "entire amount consumed by fees");
        let total_fee = amount - result;
        let max_fee = (amount as u128) * (fee_a as u128 + fee_b as u128) / 10_000;
        prop_assert!(total_fee as u128 <= max_fee + 2, "compound fee exceeds independent sum");
    }
}
```

### LiteSVM Assertion
```rust
let amount = 1_000_000_000u64;
let result = apply_fees(&mut ctx, amount, protocol_fee_bps, lp_fee_bps).await;
let total_fee = amount - result;
let expected_max = amount as u128 * (protocol_fee_bps + lp_fee_bps) as u128 / 10_000;
assert!(total_fee as u128 <= expected_max + 1, "fees exceed independent sum");
```

## Suggested Fix
```rust
/// Apply multiple fees sequentially with explicit ordering
pub fn apply_fees(amount: u64, fees: &[(u16, &str)]) -> Result<(u64, Vec<(String, u64)>)> {
    let mut remaining = amount;
    let mut fee_log = Vec::new();
    for &(bps, name) in fees {
        let fee = fee_ceil(remaining, bps);
        remaining = remaining.checked_sub(fee).ok_or(FeeError::Underflow)?;
        fee_log.push((name.to_string(), fee));
    }
    Ok((remaining, fee_log))
}
```
