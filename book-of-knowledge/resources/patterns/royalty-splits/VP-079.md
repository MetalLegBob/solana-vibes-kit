# VP-079: Dust Handling in Multi-Party Splits

**Category:** Royalty/Revenue Splits
**Verification tool:** Kani

## What Can Go Wrong
When splitting a payment among multiple recipients using integer division, truncation produces a remainder (dust). If the sum of individual payouts is less than the total and no code assigns the remainder, those lamports stay locked in the escrow forever. Over thousands of distributions the contract accumulates significant unclaimable balance. The dust from a single distribution is bounded by (num_recipients - 1) lamports.

## Why It Matters
A 3-recipient split at 3333/3333/3334 bps distributing 10,001 lamports pays 3333+3333+3334=9,999, leaving 2 lamports as dust. A marketplace processing 100,000 distributions per day at average dust of 1.5 lamports accumulates over 50 SOL per year in locked funds. The correct approach assigns the remainder to a designated recipient so zero value is lost.

## Real-World Incident
Dust handling in payment splitters is one of the most common audit findings. OpenZeppelin's PaymentSplitter v4.x accumulates dust implicitly, leading to community proposals for explicit assignment. Several Metaplex marketplace forks were flagged for missing dust reconciliation during Sec3 audits.

## Invariant

### Formal Property
```
forall total > 0, shares[] where sum(shares) == 10000, n = len(shares):
  let payout_i = floor(total * shares[i] / 10000)
  let dust = total - sum(payout_i)
  dust >= 0 AND dust < n
  sum(payout_i) + dust == total
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_dust_bounded() {
    let total: u64 = kani::any();
    let n: usize = kani::any();
    kani::assume!(total > 0 && total < 1_000_000_000);
    kani::assume!(n >= 2 && n <= 10);
    let mut shares = [0u16; 10];
    let mut remaining_bps: u32 = 10_000;
    for i in 0..(n - 1) {
        shares[i] = kani::any();
        kani::assume!(shares[i] >= 1 && (shares[i] as u32) < remaining_bps);
        remaining_bps -= shares[i] as u32;
    }
    shares[n - 1] = remaining_bps as u16;
    kani::assume!(shares[n - 1] >= 1);
    let paid: u64 = shares[..n]
        .iter()
        .map(|s| (total as u128 * *s as u128 / 10_000) as u64)
        .sum();
    let dust = total - paid;
    kani::assert!(dust < n as u64);
    kani::assert!(paid + dust == total);
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn dust_is_bounded(
        total in 1u64..1_000_000_000,
        n in 2usize..=8,
        seed in prop::collection::vec(1u16..5000, 8)
    ) {
        let raw_sum: u32 = seed[..n].iter().map(|s| *s as u32).sum();
        let mut shares: Vec<u16> = seed[..n]
            .iter()
            .map(|s| ((*s as u32) * 10_000 / raw_sum) as u16)
            .collect();
        let partial: u32 = shares.iter().map(|s| *s as u32).sum();
        shares[n - 1] += (10_000u32 - partial) as u16;
        let paid: u64 = shares.iter()
            .map(|s| (total as u128 * *s as u128 / 10_000) as u64)
            .sum();
        let dust = total - paid;
        prop_assert!(dust < n as u64, "dust {} >= num_recipients {}", dust, n);
        prop_assert_eq!(paid + dust, total);
    }
}
```

### LiteSVM Assertion
```rust
let total_amount: u64 = 10_001;
let shares = vec![3333u16, 3333, 3334];
let ix = distribute(&program_id, &split_account, total_amount);
process_transaction(&mut banks_client, ix, &payer).await.unwrap();

let bal_a = get_balance(&banks_client, &recipient_a).await;
let bal_b = get_balance(&banks_client, &recipient_b).await;
let bal_c = get_balance(&banks_client, &recipient_c).await;
assert_eq!(bal_a + bal_b + bal_c, total_amount, "all lamports distributed");
let escrow_bal = get_balance(&banks_client, &split_account).await;
assert_eq!(escrow_bal, 0, "no dust left in escrow");
```

## Suggested Fix
```rust
pub fn distribute_with_dust(total: u64, shares: &[u16]) -> Vec<u64> {
    let mut payouts: Vec<u64> = shares
        .iter()
        .map(|s| (total as u128).checked_mul(*s as u128).unwrap() / 10_000)
        .map(|v| v as u64)
        .collect();
    let paid: u64 = payouts.iter().sum();
    let dust = total.checked_sub(paid).unwrap();
    if let Some(last) = payouts.last_mut() {
        *last = last.checked_add(dust).unwrap();
    }
    payouts
}
```
