# VP-076: Withheld Fee Accumulation Overflow

**Category:** Token-2022 Fees
**Verification tool:** Kani

## What Can Go Wrong
Token-2022 transfer fees accumulate in a `withheld_amount` field on each token account. Every transfer adds the computed fee to this u64 counter. On high-volume tokens processing millions of transfers daily, the accumulated fees approach u64::MAX. If `withheld_amount + new_fee` overflows without checked arithmetic, the counter wraps to a small number, permanently destroying the record of all previously accumulated fees.

## Why It Matters
An attacker monitors a high-volume token's withheld fee counter. When it nears u64::MAX, the attacker submits transfers sized to push `withheld_amount + fee` past the overflow boundary. The counter wraps to near zero, and the attacker (or an accomplice as fee authority) harvests the tiny residual. All previously accumulated fees are irrecoverably lost.

## Real-World Incident
No single named exploit, but fee accumulation overflow has been flagged in Token-2022 extension security reviews. The SPL Token-2022 reference implementation uses checked arithmetic for withheld amount updates specifically to prevent this. Third-party programs omitting checked math are a recurring audit finding.

## Invariant

### Formal Property
```
For withheld_amount W and new_fee F (both u64):
  if W + F > u64::MAX: return error
  else: withheld_after == W + F >= W
```

### Kani Precondition/Postcondition
```rust
#[kani::proof]
fn verify_withheld_fee_no_overflow() {
    let withheld: u64 = kani::any();
    let new_fee: u64 = kani::any();
    kani::assume!(new_fee > 0);

    match withheld.checked_add(new_fee) {
        Some(result) => {
            kani::assert!(result == withheld + new_fee);
            kani::assert!(result >= withheld);
        }
        None => {
            kani::assert!((withheld as u128) + (new_fee as u128) > u64::MAX as u128);
        }
    }
}
```

### Proptest Property
```rust
proptest! {
    #[test]
    fn withheld_accumulation_safe(
        withheld in 0u64..u64::MAX,
        new_fee in 1u64..1_000_000_000
    ) {
        let sum_128 = withheld as u128 + new_fee as u128;
        if sum_128 <= u64::MAX as u128 {
            let result = withheld.checked_add(new_fee);
            prop_assert!(result.is_some(), "checked_add failed for safe sum");
            prop_assert_eq!(result.unwrap() as u128, sum_128);
        } else {
            prop_assert!(withheld.checked_add(new_fee).is_none(), "missed overflow");
        }
    }
}
```

### LiteSVM Assertion
```rust
// Set withheld amount near u64::MAX, then attempt transfer that would overflow
let near_max = u64::MAX - 500;
set_withheld_amount(&mut ctx, token_account, near_max).await;

let result = process_transaction(&mut banks_client, transfer_ix(large_amount), &payer).await;
assert!(result.is_err(), "transfer should fail when withheld fee would overflow");

let state = get_token_account(&banks_client, token_account).await;
assert_eq!(state.withheld_amount, near_max, "withheld amount corrupted by overflow");
```

## Suggested Fix
```rust
pub fn accumulate_withheld_fee(account: &mut TokenAccount, fee: u64) -> Result<()> {
    account.withheld_amount = account.withheld_amount
        .checked_add(fee).ok_or(TokenError::WithheldFeeOverflow)?;
    Ok(())
}
```
